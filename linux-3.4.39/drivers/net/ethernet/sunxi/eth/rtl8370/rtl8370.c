#include <linux/clk.h>
#include <linux/mii.h>
#include <linux/gpio.h>
#include <linux/crc32.h>
#include <linux/skbuff.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/interrupt.h>
#include <linux/dma-mapping.h>
#include <linux/platform_device.h>
#include <linux/pinctrl/consumer.h>
#include <linux/pinctrl/pinctrl.h>
#include <linux/crypto.h>
#include <linux/err.h>
#include <linux/netdevice.h>
#include <linux/proc_fs.h>
#include <mach/hardware.h>
#include <mach/sun8i/platform-sun8iw6p1.h>
#include <linux/delay.h>
#include <linux/kthread.h>

#include "rtk_types.h"
#include "rtk_error.h"
#include "rtl8370.h"
#include "rtl8370_reg.h"
#include "rtl8370_asicdrv.h"
#include "rtl8370_asicdrv_phy.h"
#include "rtl8370_asicdrv_port.h"
#include "rtk_api_ext.h"

#include "smi.h"
#include "rtk_acl.h"
#include "rtl8370_asicdrv_lut.h"

#if defined(PRODUCT_MTG2500MAIN)
#include "rtk_api_ext.h"
#include "rtk_api.h"
#include "rtl8370_asicdrv_trunking.h"
#include "rtl8370_asicdrv_mib.h"
#include "rtl8370_asicdrv_qos.h"
#include "rtl8370_asicdrv_scheduling.h"
#endif

#if defined(PRODUCT_MTG2500MAIN)
#define NAME			"rtk8370m"
#define RTL8370M_DEVNAME	"rtk8370m"
#define BOARD_MTG2000  3 
#define BOARD_MTG3000  2
#define BOARD_MTG2500  1  
#define BOARD_MTG3000C  0

int rtk8370m_major = 206;
static struct class *rtk_dev_class = NULL;
static struct device *rtk_device = NULL;
int ulEthPortApplyMode = DEV_ETHNET_PORT_NORMAL; //0:sdh 或 transcode 单语音口 1:transcode 双语音口 2: porttrunking功能是否启用，启用后GE1和GE0相符备份，作为业务口用，网管口没有
int back_board_type;
extern int back_board_id;

extern int rtk8370m_link_status_get(rtk_port_t port, rtk_port_linkStatus_t *pLinkStatus);
int rtk8370_auto_learning_cfg(void);
void rtk8370_set_ge_autoneg(void);
void rtk8370_hardware_init(void);
int rtk8370_isolation_cfg_normal(void);
#endif
static struct task_struct *led_run_tsk;


#define SUNXI_PIO_BASE              (((u32)SUNXI_IO_VBASE) + 0xC20800)

#define RTL8370_REGBITLENGTH               16
#define RTL8370_REGDATAMAX                 0xFFFF

#define RTL8370_VIDMAX                     0xFFF
#define RTL8370_EVIDMAX                    0x1FFF
#define RTL8370_CVLANMCNO                  32
#define RTL8370_CVIDXMAX                   (RTL8370_CVLANMCNO-1)

#define RTL8370_PRIMAX                     7

#define RTL8370_PRIDECMAX                  0xFF

#define RTL8370_PORTNO                     16   
#define RTL8370_PORTIDMAX                  (RTL8370_PORTNO-1)
#define RTL8370_PMSKMAX                    ((1<<(RTL8370_PORTNO))-1) 
#define RTL8370_PORTMASK                   0xFFFF

#define RTL8370_SVIDXNO                    64
#define RTL8370_SVIDXMAX                   (RTL8370_SVIDXNO-1)
#define RTL8370_MSTIMAX                    15  

#define RTL8370_METERNO                    64
#define RTL8370_METERMAX                   (RTL8370_METERNO-1)

#define RTL8370_QUEUENO                    8
#define RTL8370_QIDMAX                     (RTL8370_QUEUENO-1)       


#define RTL8370_PHY_BUSY_CHECK_COUNTER     1000    
#define RTL8370_PHYNO                      8 
#define RTL8370_PHYIDMAX                  (RTL8370_PHYNO-1)

#define RTL8370_QOS_GRANULARTY_MAX         0x1FFFF
#define RTL8370_QOS_GRANULARTY_LSB_MASK    0xFFFF
#define RTL8370_QOS_GRANULARTY_LSB_OFFSET  0
#define RTL8370_QOS_GRANULARTY_MSB_MASK    0x10000
#define RTL8370_QOS_GRANULARTY_MSB_OFFSET  16

#define RTL8370_QOS_GRANULARTY_UNIT_KBPS   8

#define RTL8370_QOS_RATE_INPUT_MAX         (0x1FFFF * 8)
#define RTL8370_QOS_RATE_INPUT_MIN         8

#define RTL8370_QUEUE_MASK                 0xFF

#define RTL8370_EFIDMAX                    0x7
#define RTL8370_FIDMAX                     0xFFF

/* the above macro is generated by genDotH */
#define RTL8370_VALID_REG_NO               3236

#define RTL8370_PHY_INTERNALNOMAX	    0x7
#define RTL8370_PHY_REGNOMAX		    0x1F
#define RTL8370_PHY_EXTERNALMAX	    0x7

#define	RTL8370_PHY_BASE   	        0x2000
#define	RTL8370_PHY_EXT_BASE   	    0xA000

#define	RTL8370_PHY_OFFSET	            5
#define	RTL8370_PHY_EXT_OFFSET  	    9
#define RTL8370_PHY_EXTLED_OFFSET  	8

#define RTK_INDRECT_ACCESS_CRTL                     0x1f00
#define RTK_INDRECT_ACCESS_STATUS                   0x1f01
#define RTK_INDRECT_ACCESS_ADDRESS                  0x1f02
#define RTK_INDRECT_ACCESS_WRITE_DATA               0x1f03
#define RTK_INDRECT_ACCESS_READ_DATA                0x1f04
#define RTK_INDRECT_ACCESS_DELAY                    0x1f80
#define RTK_INDRECT_ACCESS_BURST                    0x1f81
#define RTK_RW_MASK                                 0x2
#define RTK_CMD_MASK                                0x1
#define RTK_PHY_BUSY_OFFSET                         2
#define RTK_PHY_ID_MAX                             (RTK_MAX_NUM_OF_PORT-3)
#define RTK_PORT_ID_MAX                             (RTK_MAX_NUM_OF_PORT-1)
#define RTK_MAX_PORT_MASK                           0x3FF

#define RTK_MAX_NUM_OF_PORT                         10

#define RTK_MAX_NUM_OF_LEARN_LIMIT                  0x2040

#define RTL8370_LUT_LEARNLIMITMAX   0x2040

#define    RTL8370_LUT_PORT_LEARN_LIMITNO_BASE    RTL8370_REG_LUT_PORT0_LEARN_LIMITNO
#define    RTL8370_LUT_PORT_LEARN_LIMITNO_REG(port)    (RTL8370_LUT_PORT_LEARN_LIMITNO_BASE + port)

#define RTK_TOTAL_NUM_OF_WORD_FOR_1BIT_PORT_LIST    1

#define RTL8370_LEDGROUPMAX					2	
#define RTL8370_LEDGROUPMASK               0x7
#define RTL8370_LED_FORCE_MODE_BASE        RTL8370_REG_CPU_FORCE_LED0_CFG0
#define RTL8370_LED_FORCE_CTRL             RTL8370_REG_CPU_FORCE_LED_CFG
#define RTL8370_LEDPORTMAX				   8

/* port num */
#define PORT0                                       0
#define PORT1                                       1
#define PORT2                                       2
#define PORT3                                       3
#define PORT4                                       4
#define PORT5                                       5
#define PORT6                                       6
#define PORT7                                       7
#define PORT8                                       8
#define PORT9                                       9

#define RTK_EXT_0                                   0
#define RTK_EXT_1                                   1

#define    RTL8370_EXTNO       2

#define RTL8370_MIB_PORT_OFFSET    0x50
#define RTL8370_MIB_LEARNENTRYDISCARD_OFFSET    0x500

#define    RTL8370_MIB_CTRL_REG    RTL8370_REG_MIB_CTRL0
#define    RTL8370_MIB_COUNTER_BASE_REG    RTL8370_REG_MIB_COUNTER0

#define    RTL8370_PORT_ISOLATION_PORT_MASK_BASE    RTL8370_REG_PORT_ISOLATION_PORT0_MASK
#define    RTL8370_PORT_ISOLATION_PORT_MASK_REG(port)    (RTL8370_PORT_ISOLATION_PORT_MASK_BASE + port)

#define PHY_CONTROL_REG                             0
#define PHY_STATUS_REG                              1
#define PHY_AN_ADVERTISEMENT_REG                    4
#define PHY_AN_LINKPARTNER_REG                      5
#define PHY_1000_BASET_CONTROL_REG                  9
#define PHY_1000_BASET_STATUS_REG                   10
#define PHY_RESOLVED_REG                            17
#define PHY_POWERSAVING_REG                         21
#define PHY_POWERSAVING_OFFSET                      12
#define PHY_POWERSAVING_MASK                        0x1000
#define PHY_PAGE_ADDRESS                            31

typedef int32_t                   rtk_api_ret_t;
typedef int32_t                   ret_t;
typedef uint32_t  rtk_port_t;        /* port is type */


typedef uint32  rtk_data_t;


enum RTL8370_LEDSERACT{

    LEDSERACT_HIGH=0,         
    LEDSERACT_LOW,        
    LEDSERACT_MAX,
};

enum RTL8370_LEDSER{

    LEDSER_16G=0,         
    LEDSER_8G,        
    LEDSER_MAX,
};

enum RTL8370_LEDOP{

    LEDOP_SCAN0=0,         
    LEDOP_SCAN1,        
    LEDOP_PARALLEL,        
    LEDOP_SERIAL, 
    LEDOP_MAX,
};

enum RTL8370_LEDFORCEMODE{

    LEDFORCEMODE_NORMAL=0,
    LEDFORCEMODE_BLINK,
    LEDFORCEMODE_OFF,
    LEDFORCEMODE_ON,
    LEDFORCEMODE_MAX,
};


enum RTL8370_LEDCONF{

    LEDCONF_LEDOFF=0,         
    LEDCONF_DUPCOL,        
    LEDCONF_LINK_ACT,        
    LEDCONF_SPD1000,        
    LEDCONF_SPD100,        
    LEDCONF_SPD10,            
    LEDCONF_SPD1000ACT,    
    LEDCONF_SPD100ACT,    
    LEDCONF_SPD10ACT,        
    LEDCONF_SPD10010ACT,  
    LEDCONF_LOOPDETECT,            
    LEDCONF_EEE,            
    LEDCONF_LINKRX,        
    LEDCONF_LINKTX,        
    LEDCONF_MASTER,        
    LEDCONF_ACT,    
};

enum RTL8370_LEDBLINKRATE{

    LEDBLINKRATE_32MS=0,        
    LEDBLINKRATE_64MS,      
    LEDBLINKRATE_128MS,
    LEDBLINKRATE_256MS,
    LEDBLINKRATE_512MS,
    LEDBLINKRATE_1024MS,
    LEDBLINKRATE_48MS,
    LEDBLINKRATE_96MS,
    LEDBLINKRATE_MAX,

};


#define printf      printk

static uint32 bFixLed = 0;  /* 是否需要修复GE0黄灯常亮 */
static uint32 ulMaxDtuNum = 4; /* MTG2500最多有6块DTU2业务板 */
static uint32 slot_port[RTK_MAX_SLOT] = { PORT3, PORT6, PORT2, PORT7,PORT5,PORT4};
void __iomem *gpiobase;
extern acl_cb_t *acl_cb;
///-
//static int test_flag = 0;

extern int rtk8370_acl_cfg(void);
extern void _rtl865x_gpio_set_direction(int pin, int dir);
extern void _rtl865x_setGpioDataBit(int pin, uint32 val);
extern void _rtl865x_getGpioDataBit(int pin, uint32 *ret);
extern rtk_api_ret_t rtk_mirror_portBased_get(rtk_port_t *pMirroring_port, rtk_portmask_t *pMirrored_rx_portmask, rtk_portmask_t *pMirrored_tx_portmask);
extern rtk_api_ret_t rtk_mirror_portBased_set(rtk_port_t mirroring_port, rtk_portmask_t *pMirrored_rx_portmask, rtk_portmask_t *pMirrored_tx_portmask);
extern void rtk_acl_exit(void);

extern void acl_lock(void);
extern void acl_unlock(void);

extern struct reg_save_t reg_save[65536];
extern int changable;

static void mii_phy_reset(int hard_reset);
extern int rtk_qos_cfg(void);
const uint16 switch_init0_chipData0[][2] = {{0x133f,0x0030},{0x133e,0x000e},{0x221f,0x0000},{0x2215,0x1006},
                                     {0x221f,0x0005},{0x2200,0x00c6},{0x221f,0x0007},{0x221e,0x0048},
                                     {0x2215,0x6412},{0x2216,0x6412},{0x2217,0x6412},{0x2218,0x6412},
                                     {0x2219,0x6412},{0x221A,0x6412},{0x221f,0x0001},{0x220c,0xdbf0},
                                     {0x2209,0x2576},{0x2207,0x287E},{0x220A,0x68E5},{0x221D,0x3DA4},
                                     {0x221C,0xE7F7},{0x2214,0x7F52},{0x2218,0x7FCE},{0x2208,0x04B7},
                                     {0x2206,0x4072},{0x2210,0xF05E},{0x221B,0xB414},{0x221F,0x0003},
                                     {0x221A,0x06A6},{0x2210,0xF05E},{0x2213,0x06EB},{0x2212,0xF4D2},
                                     {0x220E,0xE120},{0x2200,0x7C00},{0x2202,0x5FD0},{0x220D,0x0207},
                                     {0x221f,0x0002},{0x2205,0x0978},{0x2202,0x8C01},{0x2207,0x3620},
                                     {0x221C,0x0001},{0x2203,0x0420},{0x2204,0x80C8},{0x133e,0x0ede},
                                     {0x221f,0x0002},{0x220c,0x0073},{0x220d,0xEB65},{0x220e,0x51d1},
                                     {0x220f,0x5dcb},{0x2210,0x3044},{0x2211,0x1800},{0x2212,0x7E00},
                                     {0x2213,0x0000},{0x133f,0x0010},{0x133e,0x0ffe},{0x207f,0x0002},
                                     {0x2074,0x3D22},{0x2075,0x2000},{0x2076,0x6040},{0x2077,0x0000},
                                     {0x2078,0x0f0a},{0x2079,0x50AB},{0x207a,0x0000},{0x207b,0x0f0f},
                                     {0x205f,0x0002},{0x2054,0xFF00},{0x2055,0x000A},{0x2056,0x000A},
                                     {0x2057,0x0005},{0x2058,0x0005},{0x2059,0x0000},{0x205A,0x0005},
                                     {0x205B,0x0005},{0x205C,0x0005},{0x209f,0x0002},{0x2094,0x00AA},
                                     {0x2095,0x00AA},{0x2096,0x00AA},{0x2097,0x00AA},{0x2098,0x0055},
                                     {0x2099,0x00AA},{0x209A,0x00AA},{0x209B,0x00AA},{0x1363,0x8354},
                                     {0x1270,0x3333},{0x1271,0x3333},{0x1272,0x3333},{0x1330,0x00DB},
                                     {0x1203,0xff00},{0x1200,0x7fc4},{0x121d,0x1006},{0x121e,0x03e8},
                                     {0x121f,0x02b3},{0x1220,0x028f},{0x1221,0x029b},{0x1222,0x0277},
                                     {0x1223,0x02b3},{0x1224,0x028f},{0x1225,0x029b},{0x1226,0x0277},
                                     {0x1227,0x00c0},{0x1228,0x00b4},{0x122f,0x00c0},{0x1230,0x00b4},
                                     {0x1229,0x0020},{0x122a,0x000c},{0x1231,0x0030},{0x1232,0x0024},
                                     {0x0219,0x0032},{0x0200,0x03e8},{0x0201,0x03e8},{0x0202,0x03e8},
                                     {0x0203,0x03e8},{0x0204,0x03e8},{0x0205,0x03e8},{0x0206,0x03e8},
                                     {0x0207,0x03e8},{0x0218,0x0032},{0x0208,0x029b},{0x0209,0x029b},
                                     {0x020a,0x029b},{0x020b,0x029b},{0x020c,0x029b},{0x020d,0x029b},
                                     {0x020e,0x029b},{0x020f,0x029b},{0x0210,0x029b},{0x0211,0x029b},
                                     {0x0212,0x029b},{0x0213,0x029b},{0x0214,0x029b},{0x0215,0x029b},
                                     {0x0216,0x029b},{0x0217,0x029b},{0x0900,0x0000},{0x0901,0x0000},
                                     {0x0902,0x0000},{0x0903,0x0000},{0x0865,0x3210},{0x087b,0x0000},
                                     {0x087c,0xff00},{0x087d,0x0000},{0x087e,0x0000},{0x0801,0x0100},
                                     {0x0802,0x0100},{0x1700,0x014C},{0x0301,0x00FF},{0x12AA,0x0096},
                                     {0x133f,0x0030},{0x133e,0x000e},{0x221f,0x0005},{0x2200,0x00C4},
                                     {0x221f,0x0000},{0x2210,0x05EF},{0x2204,0x05E1},{0x2200,0x1340},
                                     {0x133f,0x0010},{0x20A0,0x1940},{0x20C0,0x1940},{0x20E0,0x1940},
                                     {0xFFFF, 0xABCD}};

const uint16 switch_init0_chipData1[][2] = {{0x133f,0x0030},{0x133e,0x000e},{0x221f,0x0000},{0x2215,0x1006},
                                     {0x221f,0x0005},{0x2200,0x00c6},{0x221f,0x0007},{0x221e,0x0048},
                                     {0x2215,0x6412},{0x2216,0x6412},{0x2217,0x6412},{0x2218,0x6412},
                                     {0x2219,0x6412},{0x221A,0x6412},{0x221f,0x0001},{0x220c,0xdbf0},
                                     {0x2209,0x2576},{0x2207,0x287E},{0x220A,0x68E5},{0x221D,0x3DA4},
                                     {0x221C,0xE7F7},{0x2214,0x7F52},{0x2218,0x7FCE},{0x2208,0x04B7},
                                     {0x2206,0x4072},{0x2210,0xF05E},{0x221B,0xB414},{0x221F,0x0003},
                                     {0x221A,0x06A6},{0x2210,0xF05E},{0x2213,0x06EB},{0x2212,0xF4D2},
                                     {0x220E,0xE120},{0x2200,0x7C00},{0x2202,0x5FD0},{0x220D,0x0207},
                                     {0x221f,0x0002},{0x2205,0x0978},{0x2202,0x8C01},{0x2207,0x3620},
                                     {0x221C,0x0001},{0x2203,0x0420},{0x2204,0x80C8},{0x133e,0x0ede},
                                     {0x221f,0x0002},{0x220c,0x0073},{0x220d,0xEB65},{0x220e,0x51d1},
                                     {0x220f,0x5dcb},{0x2210,0x3044},{0x2211,0x1800},{0x2212,0x7E00},
                                     {0x2213,0x0000},{0x133f,0x0010},{0x133e,0x0ffe},{0x207f,0x0002},
                                     {0x2074,0x3D22},{0x2075,0x2000},{0x2076,0x6040},{0x2077,0x0000},
                                     {0x2078,0x0f0a},{0x2079,0x50AB},{0x207a,0x0000},{0x207b,0x0f0f},
                                     {0x205f,0x0002},{0x2054,0xFF00},{0x2055,0x000A},{0x2056,0x000A},
                                     {0x2057,0x0005},{0x2058,0x0005},{0x2059,0x0000},{0x205A,0x0005},
                                     {0x205B,0x0005},{0x205C,0x0005},{0x209f,0x0002},{0x2094,0x00AA},
                                     {0x2095,0x00AA},{0x2096,0x00AA},{0x2097,0x00AA},{0x2098,0x0055},
                                     {0x2099,0x00AA},{0x209A,0x00AA},{0x209B,0x00AA},{0x1363,0x8354},
                                     {0x1270,0x3333},{0x1271,0x3333},{0x1272,0x3333},{0x1330,0x00DB},
                                     {0x1203,0xff00},{0x1200,0x7fc4},{0x121d,0x1b06},{0x121e,0x07f0},
                                     {0x121f,0x0438},{0x1220,0x040f},{0x1221,0x040f},{0x1222,0x03eb},
                                     {0x1223,0x0438},{0x1224,0x040f},{0x1225,0x040f},{0x1226,0x03eb},
                                     {0x1227,0x0144},{0x1228,0x0138},{0x122f,0x0144},{0x1230,0x0138},
                                     {0x1229,0x0020},{0x122a,0x000c},{0x1231,0x0030},{0x1232,0x0024},
                                     {0x0219,0x0032},{0x0200,0x07d0},{0x0201,0x07d0},{0x0202,0x07d0},
                                     {0x0203,0x07d0},{0x0204,0x07d0},{0x0205,0x07d0},{0x0206,0x07d0},
                                     {0x0207,0x07d0},{0x0218,0x0032},{0x0208,0x0190},{0x0209,0x0190},
                                     {0x020a,0x0190},{0x020b,0x0190},{0x020c,0x0190},{0x020d,0x0190},
                                     {0x020e,0x0190},{0x020f,0x0190},{0x0210,0x0190},{0x0211,0x0190},
                                     {0x0212,0x0190},{0x0213,0x0190},{0x0214,0x0190},{0x0215,0x0190},
                                     {0x0216,0x0190},{0x0217,0x0190},{0x0900,0x0000},{0x0901,0x0000},
                                     {0x0902,0x0000},{0x0903,0x0000},{0x0865,0x3210},{0x087b,0x0000},
                                     {0x087c,0xff00},{0x087d,0x0000},{0x087e,0x0000},{0x0801,0x0100},
                                     {0x0802,0x0100},{0x1700,0x0125},{0x0301,0x00FF},{0x12AA,0x0096},
                                     {0x133f,0x0030},{0x133e,0x000e},{0x221f,0x0005},{0x2200,0x00C4},
                                     {0x221f,0x0000},{0x2210,0x05EF},{0x2204,0x05E1},{0x2200,0x1340},
                                     {0x133f,0x0010},{0xFFFF, 0xABCD}};


static rtk_api_ret_t _rtk_switch_init0(void)
{
    rtk_api_ret_t retVal;
    uint32 index,regData;
    uint32 busyFlag,cnt;

    if ((retVal = rtl8370_setAsicReg(0x13C2,0x0249))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_getAsicRegBits(0x1302, 0x7,&regData))!=RT_ERR_OK)
        return retVal;

    index = 0;
    switch(regData)
    {
    case 0x0000:
        while (switch_init0_chipData0[index][0] != 0xFFFF && switch_init0_chipData0[index][1] != 0xABCD)
        {
            if ((switch_init0_chipData0[index][0]&0xF000)==0x2000)
            {
                cnt = 0;
                busyFlag = 1;
                while (busyFlag&&cnt<5)
                {
                    cnt++;
                    if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                        return retVal;
                }
                if (5 == cnt)
                    return RT_ERR_BUSYWAIT_TIMEOUT;

                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32)switch_init0_chipData0[index][1])) !=  RT_ERR_OK)
                    return retVal;
                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32)switch_init0_chipData0[index][0])) !=  RT_ERR_OK)
                    return retVal;
                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                    return retVal;
            }
            else
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32) switch_init0_chipData0[index][0],(uint32) switch_init0_chipData0[index][1]))
                    return RT_ERR_FAILED;
            }
            index ++;
        }
    case 0x0001:
        while (switch_init0_chipData1[index][0] != 0xFFFF && switch_init0_chipData1[index][1] != 0xABCD)
        {
            if ((switch_init0_chipData1[index][0]&0xF000)==0x2000)
            {
                cnt = 0;
                busyFlag = 1;
                while (busyFlag&&cnt<5)
                {
                    cnt++;
                    if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                        return retVal;
                }
                if (5 == cnt)
                    return RT_ERR_BUSYWAIT_TIMEOUT;

                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32) switch_init0_chipData1[index][1])) !=  RT_ERR_OK)
                    return retVal;
                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32) switch_init0_chipData1[index][0])) !=  RT_ERR_OK)
                    return retVal;
                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                    return retVal;
            }
            else
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32) switch_init0_chipData1[index][0],(uint32) switch_init0_chipData1[index][1]))
                    return RT_ERR_FAILED;
            }
            index ++;
        }

        if (RT_ERR_OK != rtl8370_setAsicReg(0x1700,0x135))
            return RT_ERR_FAILED;
        break;
    case 0x0002:
        while (switch_init0_chipData1[index][0] != 0xFFFF && switch_init0_chipData1[index][1] != 0xABCD)
        {
            if ((switch_init0_chipData1[index][0]&0xF000)==0x2000)
            {
                cnt = 0;
                busyFlag = 1;
                while (busyFlag&&cnt<5)
                {
                    cnt++;
                    if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                        return retVal;
                }
                if (5 == cnt)
                    return RT_ERR_BUSYWAIT_TIMEOUT;

                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32) switch_init0_chipData1[index][1])) !=  RT_ERR_OK)
                    return retVal;
                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32) switch_init0_chipData1[index][0])) !=  RT_ERR_OK)
                    return retVal;
                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                    return retVal;
            }
            else
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32) switch_init0_chipData1[index][0],(uint32) switch_init0_chipData1[index][1]))
                    return RT_ERR_FAILED;
            }
            index ++;
        }

        if (RT_ERR_OK != rtl8370_setAsicReg(0x1700,0x135))
            return RT_ERR_FAILED;
        break;
    default:
        return RT_ERR_FAILED;
    }

    if ((retVal = rtl8370_setAsicReg(RTL8370_REG_LED_ACTIVE_LOW_CFG0, 0x6677))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_setAsicReg(RTL8370_REG_LED_ACTIVE_LOW_CFG1, 0x7406))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_getAsicReg(RTL8370_REG_MISCELLANEOUS_CONFIGURE0,&regData))!=RT_ERR_OK)
        return retVal;

    if (regData & RTL8370_EFUSE_EN_MASK)
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT3_LED_ACTIVE_LOW_OFFSET+2, 0))!=RT_ERR_OK)
            return retVal;
    }
    else
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT3_LED_ACTIVE_LOW_OFFSET+2, 1))!=RT_ERR_OK)
            return retVal;
    }

    if (regData & RTL8370_AUTOLOAD_EN_MASK)
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT2_LED_ACTIVE_LOW_OFFSET, 0))!=RT_ERR_OK)
            return retVal;
    }
    else
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT2_LED_ACTIVE_LOW_OFFSET, 1))!=RT_ERR_OK)
            return retVal;
    }

    if (regData & RTL8370_DW8051_EN_MASK)
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT2_LED_ACTIVE_LOW_OFFSET+2, 0))!=RT_ERR_OK)
            return retVal;
    }
    else
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT2_LED_ACTIVE_LOW_OFFSET+2, 1))!=RT_ERR_OK)
            return retVal;
    }

    if ((retVal = rtl8370_getAsicReg(RTL8370_REG_MISCELLANEOUS_CONFIGURE1,&regData))!=RT_ERR_OK)
        return retVal;

    if (regData & RTL8370_EEPROM_ADDRESS_16B_MASK)
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG1, RTL8370_PORT4_LED_ACTIVE_LOW_OFFSET, 1))!=RT_ERR_OK)
            return retVal;
    }
    else
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG1, RTL8370_PORT4_LED_ACTIVE_LOW_OFFSET, 0))!=RT_ERR_OK)
            return retVal;
    }

    if (regData & 0x1000)
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT3_LED_ACTIVE_LOW_OFFSET, 1))!=RT_ERR_OK)
            return retVal;
    }
    else
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT3_LED_ACTIVE_LOW_OFFSET, 0))!=RT_ERR_OK)
            return retVal;
    }

    if ((retVal = rtl8370_getAsicReg(RTL8370_REG_DW8051_RDY,&regData))!=RT_ERR_OK)
        return retVal;

    if (regData & 0x10)
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG1, RTL8370_PORT5_LED_ACTIVE_LOW_OFFSET, 1))!=RT_ERR_OK)
            return retVal;
    }
    else
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG1, RTL8370_PORT5_LED_ACTIVE_LOW_OFFSET, 0))!=RT_ERR_OK)
            return retVal;
    }

    if (regData & 0x20)
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT1_LED_ACTIVE_LOW_OFFSET+2, 1))!=RT_ERR_OK)
            return retVal;
    }
    else
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT1_LED_ACTIVE_LOW_OFFSET+2, 0))!=RT_ERR_OK)
            return retVal;
    }

    if (regData & 0x40)
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT1_LED_ACTIVE_LOW_OFFSET, 1))!=RT_ERR_OK)
            return retVal;
    }
    else
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT1_LED_ACTIVE_LOW_OFFSET, 0))!=RT_ERR_OK)
            return retVal;
    }

    if ((retVal = rtl8370_setAsicReg(RTL8370_REG_PARA_LED_IO_EN1,0))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_setAsicReg(RTL8370_REG_PARA_LED_IO_EN2,0))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_setAsicReg(RTL8370_REG_SCAN0_LED_IO_EN,0))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_setAsicReg(RTL8370_REG_SCAN1_LED_IO_EN,0))!=RT_ERR_OK)
        return retVal;

    /*Set learn limit to 8256*/
    for (index= 0; index <= RTK_MAX_NUM_OF_PORT; index++)
    {
        if ((retVal = rtl8370_setAsicLutLearnLimitNo(index,RTK_MAX_NUM_OF_LEARN_LIMIT))!=RT_ERR_OK)
            return retVal;
    }



    return RT_ERR_OK;
}

const uint16 switch_init1_chipData0[][2] = {{0x1B24, 0x0000},{0x1B25, 0x0000},{0x1B26, 0x0000},{0x1B27, 0x0000},
                                    {0x207F, 0x0007},{0x207E, 0x000B},{0x2076, 0x1A00},{0x207F, 0x0000},
                                    {0x205F, 0x0007},{0x205E, 0x000A},{0x2059, 0x0000},{0x205A, 0x0000},
                                    {0x205B, 0x0000},{0x205C, 0x0000},{0x205E, 0x000B},{0x2055, 0x0500},
                                    {0x2056, 0x0000},{0x2057, 0x0000},{0x2058, 0x0000},{0x205F, 0x0000},
                                    {0x133F, 0x0030},{0x133E, 0x000E},{0x221F, 0x0005},{0x2201, 0x0700},
                                    {0x2205, 0x8B82},{0x2206, 0x05CB},{0x221F, 0x0007},{0x221E, 0x0008},
                                    {0x2219, 0x80C2},{0x221A, 0x0938},{0x221F, 0x0000},{0x221F, 0x0003},
                                    {0x2212, 0xC4D2},{0x220D, 0x0207},{0x221F, 0x0001},{0x2207, 0x267E},
                                    {0x221C, 0xE5F7},{0x221B, 0x0424},{0x221F, 0x0007},{0x221E, 0x0040},
                                    {0x2218, 0x0000},{0x221F, 0x0007},{0x221E, 0x002C},{0x2218, 0x008B},
                                    {0x221F, 0x0005},{0x2205, 0xFFF6},{0x2206, 0x0080},{0x2205, 0x8000},
                                    {0x2206, 0xF8E0},{0x2206, 0xE000},{0x2206, 0xE1E0},{0x2206, 0x01AC},
                                    {0x2206, 0x2408},{0x2206, 0xE08B},{0x2206, 0x84F7},{0x2206, 0x20E4},
                                    {0x2206, 0x8B84},{0x2206, 0xFC05},{0x2206, 0xF8FA},{0x2206, 0xEF69},
                                    {0x2206, 0xE08B},{0x2206, 0x86AC},{0x2206, 0x201A},{0x2206, 0xBF80},
                                    {0x2206, 0x59D0},{0x2206, 0x2402},{0x2206, 0x803D},{0x2206, 0xE0E0},
                                    {0x2206, 0xE4E1},{0x2206, 0xE0E5},{0x2206, 0x5806},{0x2206, 0x68C0},
                                    {0x2206, 0xD1D2},{0x2206, 0xE4E0},{0x2206, 0xE4E5},{0x2206, 0xE0E5},
                                    {0x2206, 0xEF96},{0x2206, 0xFEFC},{0x2206, 0x05FB},{0x2206, 0x0BFB},
                                    {0x2206, 0x58FF},{0x2206, 0x9E11},{0x2206, 0x06F0},{0x2206, 0x0C81},
                                    {0x2206, 0x8AE0},{0x2206, 0x0019},{0x2206, 0x1B89},{0x2206, 0xCFEB},
                                    {0x2206, 0x19EB},{0x2206, 0x19B0},{0x2206, 0xEFFF},{0x2206, 0x0BFF},
                                    {0x2206, 0x0425},{0x2206, 0x0807},{0x2206, 0x2640},{0x2206, 0x7227},
                                    {0x2206, 0x267E},{0x2206, 0x2804},{0x2206, 0xB729},{0x2206, 0x2576},
                                    {0x2206, 0x2A68},{0x2206, 0xE52B},{0x2206, 0xAD00},{0x2206, 0x2CDB},
                                    {0x2206, 0xF02D},{0x2206, 0x67BB},{0x2206, 0x2E7B},{0x2206, 0x0F2F},
                                    {0x2206, 0x7365},{0x2206, 0x31AC},{0x2206, 0xCC32},{0x2206, 0x2300},
                                    {0x2206, 0x332D},{0x2206, 0x1734},{0x2206, 0x7F52},{0x2206, 0x3510},
                                    {0x2206, 0x0036},{0x2206, 0x1000},{0x2206, 0x3710},{0x2206, 0x0038},
                                    {0x2206, 0x7FCE},{0x2206, 0x3CE5},{0x2206, 0xF73D},{0x2206, 0x3DA4},
                                    {0x2206, 0x6530},{0x2206, 0x3E67},{0x2206, 0x0053},{0x2206, 0x69D2},
                                    {0x2206, 0x0F6A},{0x2206, 0x012C},{0x2206, 0x6C2B},{0x2206, 0x136E},
                                    {0x2206, 0xE100},{0x2206, 0x6F12},{0x2206, 0xF771},{0x2206, 0x006B},
                                    {0x2206, 0x7306},{0x2206, 0xEB74},{0x2206, 0x94C7},{0x2206, 0x7698},
                                    {0x2206, 0x0A77},{0x2206, 0x5000},{0x2206, 0x788A},{0x2206, 0x1579},
                                    {0x2206, 0x7F6F},{0x2206, 0x7A06},{0x2206, 0xA600},{0x2205, 0x8B90},
                                    {0x2206, 0x8000},{0x2205, 0x8B92},{0x2206, 0x8000},{0x2205, 0x8B94},
                                    {0x2206, 0x8014},{0x2208, 0xFFFA},{0x2202, 0x3C65},{0x2205, 0xFFF6},
                                    {0x2206, 0x00F7},{0x221F, 0x0000},{0x221F, 0x0007},{0x221E, 0x0042},
                                    {0x2218, 0x0000},{0x221E, 0x002D},{0x2218, 0xF010},{0x221E, 0x0020},
                                    {0x2215, 0x0000},{0x221E, 0x0023},{0x2216, 0x8000},{0x221F, 0x0000},
                                    {0x133F, 0x0010},{0x133E, 0x0FFE},{0x1362, 0x0115},{0x1363, 0x0002},
                                    {0x1363, 0x0000},{0x1306, 0x000C},{0x1307, 0x000C},{0x1303, 0x0367},
                                    {0x1304, 0x7777},{0x1203, 0xFF00},{0x1200, 0x7FC4},{0x121D, 0x7D16},
                                    {0x121E, 0x03E8},{0x121F, 0x024E},{0x1220, 0x0230},{0x1221, 0x0244},
                                    {0x1222, 0x0226},{0x1223, 0x024E},{0x1224, 0x0230},{0x1225, 0x0244},
                                    {0x1226, 0x0226},{0x1227, 0x00C0},{0x1228, 0x00B4},{0x122F, 0x00C0},
                                    {0x1230, 0x00B4},{0x0208, 0x03E8},{0x0209, 0x03E8},{0x020A, 0x03E8},
                                    {0x020B, 0x03E8},{0x020C, 0x03E8},{0x020D, 0x03E8},{0x020E, 0x03E8},
                                    {0x020F, 0x03E8},{0x0210, 0x03E8},{0x0211, 0x03E8},{0x0212, 0x03E8},
                                    {0x0213, 0x03E8},{0x0214, 0x03E8},{0x0215, 0x03E8},{0x0216, 0x03E8},
                                    {0x0217, 0x03E8},{0x0865, 0x3210},{0x087B, 0x0000},{0x087C, 0xFF00},
                                    {0x087D, 0x0000},{0x087E, 0x0000},{0x0801, 0x0100},{0x0802, 0x0100},
                                    {0x0A20, 0x2040},{0x0A21, 0x2040},{0x0A22, 0x2040},{0x0A23, 0x2040},
                                    {0x0A24, 0x2040},{0x0A28, 0x2040},{0x0A29, 0x2040},{0x20A0, 0x1940},
                                    {0x20C0, 0x1940},{0x20E0, 0x1940},{0x130C, 0x0050},{0x1B03, 0x0876},
                                    {0xFFFF, 0xABCD}};

const uint16 switch_init1_chipData1[][2] = {{0x1B24, 0x0000},{0x1B25, 0x0000},{0x1B26, 0x0000},{0x1B27, 0x0000},
                                    {0x207F, 0x0007},{0x207E, 0x000B},{0x2076, 0x1A00},{0x207F, 0x0000},
                                    {0x205F, 0x0007},{0x205E, 0x000A},{0x2059, 0x0000},{0x205A, 0x0000},
                                    {0x205B, 0x0000},{0x205C, 0x0000},{0x205E, 0x000B},{0x2055, 0x0500},
                                    {0x2056, 0x0000},{0x2057, 0x0000},{0x2058, 0x0000},{0x205F, 0x0000},
                                    {0x133F, 0x0030},{0x133E, 0x000E},{0x221F, 0x0005},{0x2201, 0x0700},
                                    {0x2205, 0x8B82},{0x2206, 0x05CB},{0x221F, 0x0007},{0x221E, 0x0008},
                                    {0x2219, 0x80C2},{0x221A, 0x0938},{0x221F, 0x0000},{0x221F, 0x0003},
                                    {0x2212, 0xC4D2},{0x220D, 0x0207},{0x221F, 0x0001},{0x2207, 0x267E},
                                    {0x221C, 0xE5F7},{0x221B, 0x0424},{0x221F, 0x0007},{0x221E, 0x0040},
                                    {0x2218, 0x0000},{0x221F, 0x0007},{0x221E, 0x002C},{0x2218, 0x008B},
                                    {0x221F, 0x0005},{0x2205, 0xFFF6},{0x2206, 0x0080},{0x2205, 0x8000},
                                    {0x2206, 0xF8E0},{0x2206, 0xE000},{0x2206, 0xE1E0},{0x2206, 0x01AC},
                                    {0x2206, 0x2408},{0x2206, 0xE08B},{0x2206, 0x84F7},{0x2206, 0x20E4},
                                    {0x2206, 0x8B84},{0x2206, 0xFC05},{0x2206, 0xF8FA},{0x2206, 0xEF69},
                                    {0x2206, 0xE08B},{0x2206, 0x86AC},{0x2206, 0x201A},{0x2206, 0xBF80},
                                    {0x2206, 0x59D0},{0x2206, 0x2402},{0x2206, 0x803D},{0x2206, 0xE0E0},
                                    {0x2206, 0xE4E1},{0x2206, 0xE0E5},{0x2206, 0x5806},{0x2206, 0x68C0},
                                    {0x2206, 0xD1D2},{0x2206, 0xE4E0},{0x2206, 0xE4E5},{0x2206, 0xE0E5},
                                    {0x2206, 0xEF96},{0x2206, 0xFEFC},{0x2206, 0x05FB},{0x2206, 0x0BFB},
                                    {0x2206, 0x58FF},{0x2206, 0x9E11},{0x2206, 0x06F0},{0x2206, 0x0C81},
                                    {0x2206, 0x8AE0},{0x2206, 0x0019},{0x2206, 0x1B89},{0x2206, 0xCFEB},
                                    {0x2206, 0x19EB},{0x2206, 0x19B0},{0x2206, 0xEFFF},{0x2206, 0x0BFF},
                                    {0x2206, 0x0425},{0x2206, 0x0807},{0x2206, 0x2640},{0x2206, 0x7227},
                                    {0x2206, 0x267E},{0x2206, 0x2804},{0x2206, 0xB729},{0x2206, 0x2576},
                                    {0x2206, 0x2A68},{0x2206, 0xE52B},{0x2206, 0xAD00},{0x2206, 0x2CDB},
                                    {0x2206, 0xF02D},{0x2206, 0x67BB},{0x2206, 0x2E7B},{0x2206, 0x0F2F},
                                    {0x2206, 0x7365},{0x2206, 0x31AC},{0x2206, 0xCC32},{0x2206, 0x2300},
                                    {0x2206, 0x332D},{0x2206, 0x1734},{0x2206, 0x7F52},{0x2206, 0x3510},
                                    {0x2206, 0x0036},{0x2206, 0x1000},{0x2206, 0x3710},{0x2206, 0x0038},
                                    {0x2206, 0x7FCE},{0x2206, 0x3CE5},{0x2206, 0xF73D},{0x2206, 0x3DA4},
                                    {0x2206, 0x6530},{0x2206, 0x3E67},{0x2206, 0x0053},{0x2206, 0x69D2},
                                    {0x2206, 0x0F6A},{0x2206, 0x012C},{0x2206, 0x6C2B},{0x2206, 0x136E},
                                    {0x2206, 0xE100},{0x2206, 0x6F12},{0x2206, 0xF771},{0x2206, 0x006B},
                                    {0x2206, 0x7306},{0x2206, 0xEB74},{0x2206, 0x94C7},{0x2206, 0x7698},
                                    {0x2206, 0x0A77},{0x2206, 0x5000},{0x2206, 0x788A},{0x2206, 0x1579},
                                    {0x2206, 0x7F6F},{0x2206, 0x7A06},{0x2206, 0xA600},{0x2205, 0x8B90},
                                    {0x2206, 0x8000},{0x2205, 0x8B92},{0x2206, 0x8000},{0x2205, 0x8B94},
                                    {0x2206, 0x8014},{0x2208, 0xFFFA},{0x2202, 0x3C65},{0x2205, 0xFFF6},
                                    {0x2206, 0x00F7},{0x221F, 0x0000},{0x221F, 0x0007},{0x221E, 0x0042},
                                    {0x2218, 0x0000},{0x221E, 0x002D},{0x2218, 0xF010},{0x221E, 0x0020},
                                    {0x2215, 0x0000},{0x221E, 0x0023},{0x2216, 0x8000},{0x221F, 0x0000},
                                    {0x133F, 0x0010},{0x133E, 0x0FFE},{0x1362, 0x0115},{0x1363, 0x0002},
                                    {0x1363, 0x0000},{0x1306, 0x000C},{0x1307, 0x000C},{0x1303, 0x0367},
                                    {0x1304, 0x7777},{0x1203, 0xFF00},{0x1200, 0x7FC4},{0x0865, 0x3210},
                                    {0x087B, 0x0000},{0x087C, 0xFF00},{0x087D, 0x0000},{0x087E, 0x0000},
                                    {0x0801, 0x0100},{0x0802, 0x0100},{0x0A20, 0x2040},{0x0A21, 0x2040},
                                    {0x0A22, 0x2040},{0x0A23, 0x2040},{0x0A24, 0x2040},{0x0A25, 0x2040},
                                    {0x0A26, 0x2040},{0x0A27, 0x2040},{0x0A28, 0x2040},{0x0A29, 0x2040},
                                    {0x130C, 0x0050},{0x1B03, 0x0876},{0xFFFF, 0xABCD}};


static rtk_api_ret_t _rtk_switch_init1(void)
{
    rtk_api_ret_t retVal;
    uint32 index,regData;
#ifndef MDC_MDIO_OPERATION
    uint32 busyFlag,cnt;
#endif

    if ((retVal = rtl8370_setAsicReg(0x13C2,0x0249))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_getAsicRegBits(0x1302, 0x7,&regData))!=RT_ERR_OK)
        return retVal;

#ifdef MDC_MDIO_OPERATION
    index = 0;
    switch(regData)
    {
        case 0x0000:
            while (switch_init1_chipData0[index][0] != 0xFFFF && switch_init1_chipData0[index][1] != 0xABCD)
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init1_chipData0[index][0],(uint32)switch_init1_chipData0[index][1]))
                    return RT_ERR_FAILED;
                index ++;
            }
            break;
        case 0x0001:
            while (switch_init1_chipData1[index][0] != 0xFFFF && switch_init1_chipData1[index][1] != 0xABCD)
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init1_chipData1[index][0],(uint32)switch_init1_chipData1[index][1]))
                    return RT_ERR_FAILED;
                index ++;
            }
            break;
        case 0x0002:
            while (switch_init1_chipData1[index][0] != 0xFFFF && switch_init1_chipData1[index][1] != 0xABCD)
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init1_chipData1[index][0],(uint32)switch_init1_chipData1[index][1]))
                    return RT_ERR_FAILED;
                index ++;
            }
            break;
        default:
            return RT_ERR_FAILED;
    }
#else
    index = 0;
    switch(regData)
    {

        case 0x0000:
            while (switch_init1_chipData0[index][0] != 0xFFFF && switch_init1_chipData0[index][1] != 0xABCD)
            {
                if ((switch_init1_chipData0[index][0]&0xF000)==0x2000)
                {
                    cnt = 0;
                    busyFlag = 1;
                    while (busyFlag&&cnt<5)
                    {
                        cnt++;
                        if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                            return retVal;
                    }
                    if (5 == cnt)
                        return RT_ERR_BUSYWAIT_TIMEOUT;

                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32)switch_init1_chipData0[index][1])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32)switch_init1_chipData0[index][0])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                        return retVal;
                }
                else
                {
                    if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init1_chipData0[index][0],(uint32)switch_init1_chipData0[index][1]))
                        return RT_ERR_FAILED;
                }
                index ++;
            }
            break;
        case 0x0001:
            while (switch_init1_chipData1[index][0] != 0xFFFF && switch_init1_chipData1[index][1] != 0xABCD)
            {
                if ((switch_init1_chipData1[index][0]&0xF000)==0x2000)
                {
                    cnt = 0;
                    busyFlag = 1;
                    while (busyFlag&&cnt<5)
                    {
                        cnt++;
                        if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                            return retVal;
                    }
                    if (5 == cnt)
                        return RT_ERR_BUSYWAIT_TIMEOUT;

                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32)switch_init1_chipData1[index][1])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32)switch_init1_chipData1[index][0])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                        return retVal;
                }
                else
                {
                    if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init1_chipData1[index][0],(uint32)switch_init1_chipData1[index][1]))
                        return RT_ERR_FAILED;
                }
                index ++;
            }
            break;
        case 0x0002:
            while (switch_init1_chipData1[index][0] != 0xFFFF && switch_init1_chipData1[index][1] != 0xABCD)
            {
                if ((switch_init1_chipData1[index][0]&0xF000)==0x2000)
                {
                    cnt = 0;
                    busyFlag = 1;
                    while (busyFlag&&cnt<5)
                    {
                        cnt++;
                        if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                            return retVal;
                    }
                    if (5 == cnt)
                        return RT_ERR_BUSYWAIT_TIMEOUT;

                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32)switch_init1_chipData1[index][1])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32)switch_init1_chipData1[index][0])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                        return retVal;
                }
                else
                {
                    if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init1_chipData1[index][0],(uint32)switch_init1_chipData1[index][1]))
                        return RT_ERR_FAILED;
                }
                index ++;
            }
            break;
        default:
            return RT_ERR_FAILED;
    }
#endif /*End of #ifdef MDC_MDIO_OPERATION*/

    return RT_ERR_OK;

}

const uint16 switch_init2_chipData0[][2] = {{0x1B24, 0x0000},{0x1B25, 0x0000},{0x1B26, 0x0000},{0x1B27, 0x0000},
                                    {0x207F, 0x0007},{0x207E, 0x000B},{0x2076, 0x1A00},{0x207E, 0x000A},
                                    {0x2078, 0x1D22},{0x207F, 0x0000},{0x205F, 0x0007},{0x205E, 0x000A},
                                    {0x2059, 0x0000},{0x205A, 0x0000},{0x205B, 0x0000},{0x205C, 0x0000},
                                    {0x205E, 0x000B},{0x2055, 0x0500},{0x2056, 0x0000},{0x2057, 0x0000},
                                    {0x2058, 0x0000},{0x205F, 0x0000},{0x1362, 0x0115},{0x1363, 0x0002},
                                    {0x1363, 0x0000},{0x133F, 0x0030},{0x133E, 0x000E},{0x221F, 0x0007},
                                    {0x221E, 0x0040},{0x2218, 0x0000},{0x221F, 0x0007},{0x221E, 0x002C},
                                    {0x2218, 0x008B},{0x221F, 0x0005},{0x2205, 0x8B6E},{0x2206, 0x0000},
                                    {0x220F, 0x0100},{0x2205, 0xFFF6},{0x2206, 0x0080},{0x2205, 0x8000},
                                    {0x2206, 0x0280},{0x2206, 0x1EF7},{0x2206, 0x00E0},{0x2206, 0xFFF7},
                                    {0x2206, 0xA080},{0x2206, 0x02AE},{0x2206, 0xF602},{0x2206, 0x8046},
                                    {0x2206, 0x0201},{0x2206, 0x5002},{0x2206, 0x0163},{0x2206, 0x0280},
                                    {0x2206, 0xCD02},{0x2206, 0x0179},{0x2206, 0xAEE7},{0x2206, 0xBF80},
                                    {0x2206, 0x61D7},{0x2206, 0x8580},{0x2206, 0xD06C},{0x2206, 0x0229},
                                    {0x2206, 0x71EE},{0x2206, 0x8B64},{0x2206, 0x00EE},{0x2206, 0x8570},
                                    {0x2206, 0x00EE},{0x2206, 0x8571},{0x2206, 0x00EE},{0x2206, 0x8AFC},
                                    {0x2206, 0x07EE},{0x2206, 0x8AFD},{0x2206, 0x73EE},{0x2206, 0xFFF6},
                                    {0x2206, 0x00EE},{0x2206, 0xFFF7},{0x2206, 0xFC04},{0x2206, 0xBF85},
                                    {0x2206, 0x80D0},{0x2206, 0x6C02},{0x2206, 0x2978},{0x2206, 0xE0E0},
                                    {0x2206, 0xE4E1},{0x2206, 0xE0E5},{0x2206, 0x5806},{0x2206, 0x68C0},
                                    {0x2206, 0xD1D2},{0x2206, 0xE4E0},{0x2206, 0xE4E5},{0x2206, 0xE0E5},
                                    {0x2206, 0x0425},{0x2206, 0x0807},{0x2206, 0x2640},{0x2206, 0x7227},
                                    {0x2206, 0x267E},{0x2206, 0x2804},{0x2206, 0xB729},{0x2206, 0x2576},
                                    {0x2206, 0x2A68},{0x2206, 0xE52B},{0x2206, 0xAD00},{0x2206, 0x2CDB},
                                    {0x2206, 0xF02D},{0x2206, 0x67BB},{0x2206, 0x2E7B},{0x2206, 0x0F2F},
                                    {0x2206, 0x7365},{0x2206, 0x31AC},{0x2206, 0xCC32},{0x2206, 0x2300},
                                    {0x2206, 0x332D},{0x2206, 0x1734},{0x2206, 0x7F52},{0x2206, 0x3510},
                                    {0x2206, 0x0036},{0x2206, 0x1000},{0x2206, 0x3710},{0x2206, 0x0038},
                                    {0x2206, 0x7FCE},{0x2206, 0x3CE5},{0x2206, 0xF73D},{0x2206, 0x3DA4},
                                    {0x2206, 0x6530},{0x2206, 0x3E67},{0x2206, 0x0053},{0x2206, 0x69D2},
                                    {0x2206, 0x0F6A},{0x2206, 0x012C},{0x2206, 0x6C2B},{0x2206, 0x136E},
                                    {0x2206, 0xE100},{0x2206, 0x6F12},{0x2206, 0xF771},{0x2206, 0x006B},
                                    {0x2206, 0x7306},{0x2206, 0xEB74},{0x2206, 0x94C7},{0x2206, 0x7698},
                                    {0x2206, 0x0A77},{0x2206, 0x5000},{0x2206, 0x788A},{0x2206, 0x1579},
                                    {0x2206, 0x7F6F},{0x2206, 0x7A06},{0x2206, 0xA6F8},{0x2206, 0xE08B},
                                    {0x2206, 0x8EAD},{0x2206, 0x2006},{0x2206, 0x0280},{0x2206, 0xDC02},
                                    {0x2206, 0x8109},{0x2206, 0xFC04},{0x2206, 0xF8F9},{0x2206, 0xE08B},
                                    {0x2206, 0x87AD},{0x2206, 0x2022},{0x2206, 0xE0E2},{0x2206, 0x00E1},
                                    {0x2206, 0xE201},{0x2206, 0xAD20},{0x2206, 0x11E2},{0x2206, 0xE022},
                                    {0x2206, 0xE3E0},{0x2206, 0x23AD},{0x2206, 0x3908},{0x2206, 0x5AC0},
                                    {0x2206, 0x9F04},{0x2206, 0xF724},{0x2206, 0xAE02},{0x2206, 0xF624},
                                    {0x2206, 0xE4E2},{0x2206, 0x00E5},{0x2206, 0xE201},{0x2206, 0xFDFC},
                                    {0x2206, 0x04F8},{0x2206, 0xF9E0},{0x2206, 0x8B85},{0x2206, 0xAD25},
                                    {0x2206, 0x48E0},{0x2206, 0x8AD2},{0x2206, 0xE18A},{0x2206, 0xD37C},
                                    {0x2206, 0x0000},{0x2206, 0x9E35},{0x2206, 0xEE8A},{0x2206, 0xD200},
                                    {0x2206, 0xEE8A},{0x2206, 0xD300},{0x2206, 0xE08A},{0x2206, 0xFCE1},
                                    {0x2206, 0x8AFD},{0x2206, 0xE285},{0x2206, 0x70E3},{0x2206, 0x8571},
                                    {0x2206, 0x0229},{0x2206, 0x3AAD},{0x2206, 0x2012},{0x2206, 0xEE8A},
                                    {0x2206, 0xD203},{0x2206, 0xEE8A},{0x2206, 0xD3B7},{0x2206, 0xEE85},
                                    {0x2206, 0x7000},{0x2206, 0xEE85},{0x2206, 0x7100},{0x2206, 0xAE11},
                                    {0x2206, 0x15E6},{0x2206, 0x8570},{0x2206, 0xE785},{0x2206, 0x71AE},
                                    {0x2206, 0x08EE},{0x2206, 0x8570},{0x2206, 0x00EE},{0x2206, 0x8571},
                                    {0x2206, 0x00FD},{0x2206, 0xFC04},{0x2206, 0xCCE2},{0x2206, 0x0000},
                                    {0x2205, 0xE142},{0x2206, 0x0701},{0x2205, 0xE140},{0x2206, 0x0405},
                                    {0x220F, 0x0000},{0x221F, 0x0000},{0x221F, 0x0005},{0x2205, 0x85E4},
                                    {0x2206, 0x8A14},{0x2205, 0x85E7},{0x2206, 0x7F6E},{0x221F, 0x0007},
                                    {0x221E, 0x002D},{0x2218, 0xF030},{0x221E, 0x0023},{0x2216, 0x0005},
                                    {0x2215, 0x005C},{0x2219, 0x0068},{0x2215, 0x0082},{0x2219, 0x000A},
                                    {0x2215, 0x00A1},{0x2219, 0x0081},{0x2215, 0x00AF},{0x2219, 0x0080},
                                    {0x2215, 0x00D4},{0x2219, 0x0000},{0x2215, 0x00E4},{0x2219, 0x0081},
                                    {0x2215, 0x00E7},{0x2219, 0x0080},{0x2215, 0x010D},{0x2219, 0x0083},
                                    {0x2215, 0x0118},{0x2219, 0x0083},{0x2215, 0x0120},{0x2219, 0x0082},
                                    {0x2215, 0x019C},{0x2219, 0x0081},{0x2215, 0x01A4},{0x2219, 0x0080},
                                    {0x2215, 0x01CD},{0x2219, 0x0000},{0x2215, 0x01DD},{0x2219, 0x0081},
                                    {0x2215, 0x01E0},{0x2219, 0x0080},{0x2215, 0x0147},{0x2219, 0x0096},
                                    {0x2216, 0x0000},{0x221E, 0x002D},{0x2218, 0xF010},{0x221F, 0x0005},
                                    {0x2205, 0x8B84},{0x2206, 0x0062},{0x221F, 0x0000},{0x220D, 0x0003},
                                    {0x220E, 0x0015},{0x220D, 0x4003},{0x220E, 0x0006},{0x133F, 0x0010},
                                    {0x133E, 0x0FFE},{0x12A4, 0x380A},{0x1303, 0x0367},{0x1304, 0x7777},
                                    {0x1203, 0xFF00},{0x1200, 0x7FC4},{0x121D, 0x7D16},{0x121E, 0x03E8},
                                    {0x121F, 0x024E},{0x1220, 0x0230},{0x1221, 0x0244},{0x1222, 0x0226},
                                    {0x1223, 0x024E},{0x1224, 0x0230},{0x1225, 0x0244},{0x1226, 0x0226},
                                    {0x1227, 0x00C0},{0x1228, 0x00B4},{0x122F, 0x00C0},{0x1230, 0x00B4},
                                    {0x0208, 0x03E8},{0x0209, 0x03E8},{0x020A, 0x03E8},{0x020B, 0x03E8},
                                    {0x020C, 0x03E8},{0x020D, 0x03E8},{0x020E, 0x03E8},{0x020F, 0x03E8},
                                    {0x0210, 0x03E8},{0x0211, 0x03E8},{0x0212, 0x03E8},{0x0213, 0x03E8},
                                    {0x0214, 0x03E8},{0x0215, 0x03E8},{0x0216, 0x03E8},{0x0217, 0x03E8},
                                    {0x0865, 0x3210},{0x087B, 0x0000},{0x087C, 0xFF00},{0x087D, 0x0000},
                                    {0x087E, 0x0000},{0x0801, 0x0100},{0x0802, 0x0100},{0x0A20, 0x2040},
                                    {0x0A21, 0x2040},{0x0A22, 0x2040},{0x0A23, 0x2040},{0x0A24, 0x2040},
                                    {0x0A28, 0x2040},{0x0A29, 0x2040},{0x20A0, 0x1940},{0x20C0, 0x1940},
                                    {0x20E0, 0x1940},{0x1B03, 0x0876},{0xFFFF, 0xABCD}};

const uint16 switch_init2_chipData1[][2] = {{0x1B24, 0x0000},{0x1B25, 0x0000},{0x1B26, 0x0000},{0x1B27, 0x0000},
                                    {0x207F, 0x0007},{0x207E, 0x000B},{0x2076, 0x1A00},{0x207E, 0x000A},
                                    {0x2078, 0x1D22},{0x207F, 0x0000},{0x205F, 0x0007},{0x205E, 0x000A},
                                    {0x2059, 0x0000},{0x205A, 0x0000},{0x205B, 0x0000},{0x205C, 0x0000},
                                    {0x205E, 0x000B},{0x2055, 0x0500},{0x2056, 0x0000},{0x2057, 0x0000},
                                    {0x2058, 0x0000},{0x205F, 0x0000},{0x1362, 0x0115},{0x1363, 0x0002},
                                    {0x1363, 0x0000},{0x133F, 0x0030},{0x133E, 0x000E},{0x221F, 0x0007},
                                    {0x221E, 0x0040},{0x2218, 0x0000},{0x221F, 0x0007},{0x221E, 0x002C},
                                    {0x2218, 0x008B},{0x221F, 0x0005},{0x2205, 0x8B6E},{0x2206, 0x0000},
                                    {0x220F, 0x0100},{0x2205, 0xFFF6},{0x2206, 0x0080},{0x2205, 0x8000},
                                    {0x2206, 0x0280},{0x2206, 0x1EF7},{0x2206, 0x00E0},{0x2206, 0xFFF7},
                                    {0x2206, 0xA080},{0x2206, 0x02AE},{0x2206, 0xF602},{0x2206, 0x8046},
                                    {0x2206, 0x0201},{0x2206, 0x5002},{0x2206, 0x0163},{0x2206, 0x0280},
                                    {0x2206, 0xCD02},{0x2206, 0x0179},{0x2206, 0xAEE7},{0x2206, 0xBF80},
                                    {0x2206, 0x61D7},{0x2206, 0x8580},{0x2206, 0xD06C},{0x2206, 0x0229},
                                    {0x2206, 0x71EE},{0x2206, 0x8B64},{0x2206, 0x00EE},{0x2206, 0x8570},
                                    {0x2206, 0x00EE},{0x2206, 0x8571},{0x2206, 0x00EE},{0x2206, 0x8AFC},
                                    {0x2206, 0x07EE},{0x2206, 0x8AFD},{0x2206, 0x73EE},{0x2206, 0xFFF6},
                                    {0x2206, 0x00EE},{0x2206, 0xFFF7},{0x2206, 0xFC04},{0x2206, 0xBF85},
                                    {0x2206, 0x80D0},{0x2206, 0x6C02},{0x2206, 0x2978},{0x2206, 0xE0E0},
                                    {0x2206, 0xE4E1},{0x2206, 0xE0E5},{0x2206, 0x5806},{0x2206, 0x68C0},
                                    {0x2206, 0xD1D2},{0x2206, 0xE4E0},{0x2206, 0xE4E5},{0x2206, 0xE0E5},
                                    {0x2206, 0x0425},{0x2206, 0x0807},{0x2206, 0x2640},{0x2206, 0x7227},
                                    {0x2206, 0x267E},{0x2206, 0x2804},{0x2206, 0xB729},{0x2206, 0x2576},
                                    {0x2206, 0x2A68},{0x2206, 0xE52B},{0x2206, 0xAD00},{0x2206, 0x2CDB},
                                    {0x2206, 0xF02D},{0x2206, 0x67BB},{0x2206, 0x2E7B},{0x2206, 0x0F2F},
                                    {0x2206, 0x7365},{0x2206, 0x31AC},{0x2206, 0xCC32},{0x2206, 0x2300},
                                    {0x2206, 0x332D},{0x2206, 0x1734},{0x2206, 0x7F52},{0x2206, 0x3510},
                                    {0x2206, 0x0036},{0x2206, 0x1000},{0x2206, 0x3710},{0x2206, 0x0038},
                                    {0x2206, 0x7FCE},{0x2206, 0x3CE5},{0x2206, 0xF73D},{0x2206, 0x3DA4},
                                    {0x2206, 0x6530},{0x2206, 0x3E67},{0x2206, 0x0053},{0x2206, 0x69D2},
                                    {0x2206, 0x0F6A},{0x2206, 0x012C},{0x2206, 0x6C2B},{0x2206, 0x136E},
                                    {0x2206, 0xE100},{0x2206, 0x6F12},{0x2206, 0xF771},{0x2206, 0x006B},
                                    {0x2206, 0x7306},{0x2206, 0xEB74},{0x2206, 0x94C7},{0x2206, 0x7698},
                                    {0x2206, 0x0A77},{0x2206, 0x5000},{0x2206, 0x788A},{0x2206, 0x1579},
                                    {0x2206, 0x7F6F},{0x2206, 0x7A06},{0x2206, 0xA6F8},{0x2206, 0xE08B},
                                    {0x2206, 0x8EAD},{0x2206, 0x2006},{0x2206, 0x0280},{0x2206, 0xDC02},
                                    {0x2206, 0x8109},{0x2206, 0xFC04},{0x2206, 0xF8F9},{0x2206, 0xE08B},
                                    {0x2206, 0x87AD},{0x2206, 0x2022},{0x2206, 0xE0E2},{0x2206, 0x00E1},
                                    {0x2206, 0xE201},{0x2206, 0xAD20},{0x2206, 0x11E2},{0x2206, 0xE022},
                                    {0x2206, 0xE3E0},{0x2206, 0x23AD},{0x2206, 0x3908},{0x2206, 0x5AC0},
                                    {0x2206, 0x9F04},{0x2206, 0xF724},{0x2206, 0xAE02},{0x2206, 0xF624},
                                    {0x2206, 0xE4E2},{0x2206, 0x00E5},{0x2206, 0xE201},{0x2206, 0xFDFC},
                                    {0x2206, 0x04F8},{0x2206, 0xF9E0},{0x2206, 0x8B85},{0x2206, 0xAD25},
                                    {0x2206, 0x48E0},{0x2206, 0x8AD2},{0x2206, 0xE18A},{0x2206, 0xD37C},
                                    {0x2206, 0x0000},{0x2206, 0x9E35},{0x2206, 0xEE8A},{0x2206, 0xD200},
                                    {0x2206, 0xEE8A},{0x2206, 0xD300},{0x2206, 0xE08A},{0x2206, 0xFCE1},
                                    {0x2206, 0x8AFD},{0x2206, 0xE285},{0x2206, 0x70E3},{0x2206, 0x8571},
                                    {0x2206, 0x0229},{0x2206, 0x3AAD},{0x2206, 0x2012},{0x2206, 0xEE8A},
                                    {0x2206, 0xD203},{0x2206, 0xEE8A},{0x2206, 0xD3B7},{0x2206, 0xEE85},
                                    {0x2206, 0x7000},{0x2206, 0xEE85},{0x2206, 0x7100},{0x2206, 0xAE11},
                                    {0x2206, 0x15E6},{0x2206, 0x8570},{0x2206, 0xE785},{0x2206, 0x71AE},
                                    {0x2206, 0x08EE},{0x2206, 0x8570},{0x2206, 0x00EE},{0x2206, 0x8571},
                                    {0x2206, 0x00FD},{0x2206, 0xFC04},{0x2206, 0xCCE2},{0x2206, 0x0000},
                                    {0x2205, 0xE142},{0x2206, 0x0701},{0x2205, 0xE140},{0x2206, 0x0405},
                                    {0x220F, 0x0000},{0x221F, 0x0000},{0x221F, 0x0005},{0x2205, 0x85E4},
                                    {0x2206, 0x8A14},{0x2205, 0x85E7},{0x2206, 0x7F6E},{0x221F, 0x0007},
                                    {0x221E, 0x002D},{0x2218, 0xF030},{0x221E, 0x0023},{0x2216, 0x0005},
                                    {0x2215, 0x005C},{0x2219, 0x0068},{0x2215, 0x0082},{0x2219, 0x000A},
                                    {0x2215, 0x00A1},{0x2219, 0x0081},{0x2215, 0x00AF},{0x2219, 0x0080},
                                    {0x2215, 0x00D4},{0x2219, 0x0000},{0x2215, 0x00E4},{0x2219, 0x0081},
                                    {0x2215, 0x00E7},{0x2219, 0x0080},{0x2215, 0x010D},{0x2219, 0x0083},
                                    {0x2215, 0x0118},{0x2219, 0x0083},{0x2215, 0x0120},{0x2219, 0x0082},
                                    {0x2215, 0x019C},{0x2219, 0x0081},{0x2215, 0x01A4},{0x2219, 0x0080},
                                    {0x2215, 0x01CD},{0x2219, 0x0000},{0x2215, 0x01DD},{0x2219, 0x0081},
                                    {0x2215, 0x01E0},{0x2219, 0x0080},{0x2215, 0x0147},{0x2219, 0x0096},
                                    {0x2216, 0x0000},{0x221E, 0x002D},{0x2218, 0xF010},{0x221F, 0x0005},
                                    {0x2205, 0x8B84},{0x2206, 0x0062},{0x221F, 0x0000},{0x220D, 0x0003},
                                    {0x220E, 0x0015},{0x220D, 0x4003},{0x220E, 0x0006},{0x133F, 0x0010},
                                    {0x133E, 0x0FFE},{0x12A4, 0x380A},{0x1303, 0x0367},{0x1304, 0x7777},
                                    {0x1203, 0xFF00},{0x1200, 0x7FC4},{0x0865, 0x3210},{0x087B, 0x0000},
                                    {0x087C, 0xFF00},{0x087D, 0x0000},{0x087E, 0x0000},{0x0801, 0x0100},
                                    {0x0802, 0x0100},{0x0A20, 0x2040},{0x0A21, 0x2040},{0x0A22, 0x2040},
                                    {0x0A23, 0x2040},{0x0A24, 0x2040},{0x0A25, 0x2040},{0x0A26, 0x2040},
                                    {0x0A27, 0x2040},{0x0A28, 0x2040},{0x0A29, 0x2040},{0x1B03, 0x0876},
                                    {0xFFFF, 0xABCD}};


static rtk_api_ret_t _rtk_switch_init2(void)
{
    rtk_api_ret_t retVal;
    uint32 index,regData;
#ifndef MDC_MDIO_OPERATION
    uint32 busyFlag,cnt;
#endif

    if ((retVal = rtl8370_setAsicReg(0x13C2,0x0249))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_getAsicRegBits(0x1302, 0x7,&regData))!=RT_ERR_OK)
        return retVal;

#ifdef MDC_MDIO_OPERATION
    index = 0;
    switch(regData)
    {
        case 0x0000:
            while (switch_init2_chipData0[index][0] != 0xFFFF && switch_init2_chipData0[index][1] != 0xABCD)
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init2_chipData0[index][0],(uint32)switch_init2_chipData0[index][1]))
                    return RT_ERR_FAILED;
                index ++;
            }
            break;
        case 0x0001:
            while (switch_init2_chipData1[index][0] != 0xFFFF && switch_init2_chipData1[index][1] != 0xABCD)
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init2_chipData1[index][0],(uint32)switch_init2_chipData1[index][1]))
                    return RT_ERR_FAILED;
                index ++;
            }
            break;
        case 0x0002:
            while (switch_init2_chipData1[index][0] != 0xFFFF && switch_init2_chipData1[index][1] != 0xABCD)
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init2_chipData1[index][0],(uint32)switch_init2_chipData1[index][1]))
                    return RT_ERR_FAILED;
                index ++;
            }
            break;
        default:
            return RT_ERR_FAILED;
    }
#else
    index = 0;
    switch(regData)
    {

        case 0x0000:
            while (switch_init2_chipData0[index][0] != 0xFFFF && switch_init2_chipData0[index][1] != 0xABCD)
            {
                if ((switch_init2_chipData0[index][0]&0xF000)==0x2000)
                {
                    cnt = 0;
                    busyFlag = 1;
                    while (busyFlag&&cnt<5)
                    {
                        cnt++;
                        if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                            return retVal;
                    }
                    if (5 == cnt)
                        return RT_ERR_BUSYWAIT_TIMEOUT;

                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32)switch_init2_chipData0[index][1])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32)switch_init2_chipData0[index][0])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                        return retVal;
                }
                else
                {
                    if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init2_chipData0[index][0],(uint32)switch_init2_chipData0[index][1]))
                        return RT_ERR_FAILED;
                }
                index ++;
            }
            break;
        case 0x0001:
            while (switch_init2_chipData1[index][0] != 0xFFFF && switch_init2_chipData1[index][1] != 0xABCD)
            {
                if ((switch_init2_chipData1[index][0]&0xF000)==0x2000)
                {
                    cnt = 0;
                    busyFlag = 1;
                    while (busyFlag&&cnt<5)
                    {
                        cnt++;
                        if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                            return retVal;
                    }
                    if (5 == cnt)
                        return RT_ERR_BUSYWAIT_TIMEOUT;

                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32)switch_init2_chipData1[index][1])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32)switch_init2_chipData1[index][0])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                        return retVal;
                }
                else
                {
                    if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init2_chipData1[index][0],(uint32)switch_init2_chipData1[index][1]))
                        return RT_ERR_FAILED;
                }
                index ++;
            }
            break;
        case 0x0002:
            while (switch_init2_chipData1[index][0] != 0xFFFF && switch_init2_chipData1[index][1] != 0xABCD)
            {
                if ((switch_init2_chipData1[index][0]&0xF000)==0x2000)
                {
                    cnt = 0;
                    busyFlag = 1;
                    while (busyFlag&&cnt<5)
                    {
                        cnt++;
                        if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                            return retVal;
                    }
                    if (5 == cnt)
                        return RT_ERR_BUSYWAIT_TIMEOUT;

                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32)switch_init2_chipData1[index][1])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32)switch_init2_chipData1[index][0])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                        return retVal;
                }
                else
                {
                    if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init2_chipData1[index][0],(uint32)switch_init2_chipData1[index][1]))
                        return RT_ERR_FAILED;
                }
                index ++;
            }
            break;
        default:
            return RT_ERR_FAILED;
    }
#endif /*End of #ifdef MDC_MDIO_OPERATION*/

    return RT_ERR_OK;
}

/* Function Name:
 *      rtk_switch_init
 * Description:
 *      Set chip to default configuration enviroment
 * Input:
 *      None
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 * Note:
 *      The API can set chip registers to default configuration for different release chip model.
 */
static rtk_api_ret_t rtk_switch_init(void)
{

    rtk_api_ret_t retVal;
    uint32 regData1,regData2;

    if ((retVal = rtl8370_setAsicReg(0x13C2,0x0249))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_getAsicRegBits(0x1301, 0xF000,&regData1))!=RT_ERR_OK)
        return retVal;


    if ((retVal = rtl8370_setAsicPHYReg(0,31,5))!=RT_ERR_OK)
        return retVal;
    if ((retVal = rtl8370_setAsicPHYReg(0,5,0x3ffe))!=RT_ERR_OK)
        return retVal;
    if ((retVal = rtl8370_getAsicPHYReg(0,6,&regData2))!=RT_ERR_OK)
        return retVal;

    if (0 == regData1)
    {
        if ((retVal = _rtk_switch_init0()) != RT_ERR_OK)
            return retVal;
    }
    else if (1 == regData1)
    {
        if (0x94eb == regData2)
        {
            if ((retVal = _rtk_switch_init1()) != RT_ERR_OK)
                return retVal;
        }
        else if (0x2104 == regData2)
        {
            if ((retVal = _rtk_switch_init2()) != RT_ERR_OK)
                return retVal;
        }
    }

    /*Enable System Based LED*/
    if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_SYS_CONFIG, RTL8370_LED_IO_DISABLE_OFFSET, 0))!=RT_ERR_OK)
        return retVal;


    return RT_ERR_OK;
}

static void test_smi_signal_and_wait(void)
{
    int i;

    for (i=0; i<100; i++)
    {
        unsigned int data;
        rtk_api_ret_t retVal;

        if((retVal = rtl8370_getAsicReg(0x1202, &data)) != RT_ERR_OK)
        {
            printf("error = %d\n", retVal);
        }

        //printf("data = %x\n", data);

        if (data == 0x88a8)
            break;

        CLK_DURATION(50000);
    }
}

/*
@func ret_t | rtl8370_setAsicLedGroupEnable | Turn on/off Led of all system ports
@parm uint32 | group | LED group id.
@parm uint32 | portmask | LED port mask. 
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@rvalue RT_ERR_PORT_ID | Invalid port number.
@rvalue RT_ERR_INPUT | Invalid input value.
@comm
    The API can turn on/off leds of dedicated port while indicated information configuration of LED group is set to force mode.
 */
ret_t rtl8370_setAsicLedGroupEnable(uint32 group, uint32 portmask)
{
    ret_t retVal;
    uint32 regAddr;
    uint32 regDataMask;

    if ( group > RTL8370_LEDGROUPMAX )
        return RT_ERR_INPUT;

    if ( portmask > 0xFF )
        return RT_ERR_INPUT;

    regAddr = RTL8370_REG_PARA_LED_IO_EN1 + group/2;

    regDataMask = 0xFF << ((group%2)*8);

    if ((retVal = rtl8370_setAsicRegBits(regAddr, regDataMask, portmask))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/*
@func ret_t | rtl8370_setAsicLedGroupMode | Turn on/off Led of dedicated port
@parm uint32 | mode | LED mode, 0b00:mode 0, 0b01:mode 1, 0b10:mode 2, 0b11:mode 3.
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@rvalue RT_ERR_PORT_ID | Invalid port number.
@rvalue RT_ERR_INPUT | Invalid input value.
@comm
    The API can turn on/off leds of dedicated port while indicated information configuration of LED group is set to force mode.
	    set  led0    led1   led2
mode 0	00   0010  0011  0100
mode 1	01   0110  0111  1000
mode 2	10   0001  0110  1001
mode 3	11   1000  0110  0111

    
 */
ret_t rtl8370_setAsicLedGroupMode(uint32 mode)
{
    ret_t retVal;
    uint32 regData;
	
    /* Invalid input parameter */
    if(mode >= LEDFORCEMODE_MAX)
        return RT_ERR_INPUT; 
	
    regData = (mode<<RTL8370_DATA_LED_OFFSET)|(1<<RTL8370_LED_CONFIG_SEL_OFFSET);

    retVal = rtl8370_setAsicReg(RTL8370_REG_LED_CONFIGURATION, regData);    

    return retVal;
}

/* Function Name:
 *      rtk_led_enable_set
 * Description:
 *      Set Led parallel mode enable congiuration
 * Input:
 *      group - LED group id.
 *      portmask - LED enable port mask.
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      The API can be used to enable LED parallel mode per port per group.
 */

static rtk_api_ret_t rtk_led_enable_set(rtk_led_group_t group, rtk_portmask_t portmask)
{
    rtk_api_ret_t retVal;

    if (group >= LED_GROUP_END)
        return RT_ERR_INPUT;

    if (portmask.bits[0] > (1<<RTK_PHY_ID_MAX))
        return RT_ERR_INPUT;

    if ((retVal = rtl8370_setAsicLedGroupEnable(group, portmask.bits[0]))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/*
@func ret_t | rtl8370_setAsicLedSerialModeConfig | Set LED serial mode
@parm uint32 | active | Active High or Low. 
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@rvalue RT_ERR_INPUT | Invalid input value.
@comm
    The API can turn on/off led serial mode and set signal to active high/low.
 */
ret_t rtl8370_setAsicLedSerialModeConfig(uint32 active, uint32 serimode)
{
    ret_t retVal;
    
    /* Invalid input parameter */
    if( active >= LEDSERACT_MAX)
        return RT_ERR_INPUT;
    if( serimode >= LEDSER_MAX)
        return RT_ERR_INPUT;

    /* Set Active High or Low */
    if((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_SYS_CONFIG,RTL8370_SERI_LED_ACT_LOW_OFFSET,active)) !=  RT_ERR_OK)
        return retVal;

    /*set to 8G mode (not 16G mode)*/
    if((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_MODE,RTL8370_RTCT_TEST_TIME_OFFSET, serimode))!=  RT_ERR_OK)
        return retVal;

    
    return RT_ERR_OK;   
}

/*
@func ret_t | rtl8370_setAsicLedSerialEnable | Turn on/off Led serial mode
@parm uint32 | enable | LED serial configuration. 
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@rvalue RT_ERR_PORT_ID | Invalid port number.
@rvalue RT_ERR_INPUT | Invalid input value.
@comm
    The API can turn on/off led of serial mode.
 */
ret_t rtl8370_setAsicLedSerialEnable(uint32 enable)
{
    ret_t retVal;

    if (enable > 1)
        return RT_ERR_FAILED;

    if (enable == 1)
    {
        /*Enable serial CLK mode*/
        if((retVal = rtl8370_setAsicRegBit(RTL8370_REG_SCAN0_LED_IO_EN,RTL8370_LED_SERI_CLK_EN_OFFSET, 1))!=  RT_ERR_OK)
		    return retVal;
        /*Enable serial DATA mode*/
        if((retVal = rtl8370_setAsicRegBit(RTL8370_REG_SCAN0_LED_IO_EN,RTL8370_LED_SERI_DATA_EN_OFFSET, 1))!=  RT_ERR_OK)
		    return retVal;
        
    }
    else
    {
        /*Disable serial CLK mode*/
        if((retVal = rtl8370_setAsicRegBit(RTL8370_REG_SCAN0_LED_IO_EN,RTL8370_LED_SERI_CLK_EN_OFFSET, 0))!=  RT_ERR_OK)
		    return retVal;
        /*Disable serial DATA mode*/
        if((retVal = rtl8370_setAsicRegBit(RTL8370_REG_SCAN0_LED_IO_EN,RTL8370_LED_SERI_DATA_EN_OFFSET, 0))!=  RT_ERR_OK)
		    return retVal;
    
    }
    
    return RT_ERR_OK;
}

/*
@func ret_t | rtl8370_setAsicLedOperationMode | Set LED operation mode
@parm uint32 | mode | LED mode. 1:scan mode 1, 2:parallel mode, 3:mdx mode (serial mode) 
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@rvalue RT_ERR_INPUT | Invalid input value.
@comm
    The API can turn on/off led serial mode and set signal to active high/low.
 */
ret_t rtl8370_setAsicLedOperationMode(uint32 mode)
{
    ret_t retVal;
    
    /* Invalid input parameter */
    if( mode >= LEDOP_MAX)
        return RT_ERR_INPUT; 

    if( mode == LEDOP_SCAN0)
        return RT_ERR_INPUT;   

    switch(mode)
    {
        case LEDOP_SCAN0:
            break;
        case LEDOP_SCAN1:
            if((retVal = rtl8370_setAsicReg(RTL8370_REG_LED_SYS_CONFIG,0x1471))!=  RT_ERR_OK)
		    return retVal;
            if((retVal = rtl8370_setAsicReg(RTL8370_REG_SCAN1_LED_IO_EN,0xFFBF))!=  RT_ERR_OK)
		        return retVal;       
            break;
        case LEDOP_PARALLEL:
            if((retVal = rtl8370_setAsicReg(RTL8370_REG_LED_SYS_CONFIG,0x1472))!=  RT_ERR_OK)
		        return retVal;
            break;
        case LEDOP_SERIAL:
            if((retVal = rtl8370_setAsicReg(RTL8370_REG_LED_SYS_CONFIG,0x14F7))!=  RT_ERR_OK)
		        return retVal;        
            break;
        default:
            break;
    }
    
    return RT_ERR_OK;
}

/*
@func ret_t | rtl8370_setAsicLedIndicateInfoConfig | Set Leds indicated information mode
@parm uint32 | ledno | LED group number. There are 1 to 1 led mapping to each port in each led group. 
@parm enum RTL8370_LEDCONF | config | Support 16 types configuration.
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@comm
    The API can set LED indicated information configuration for each LED group with 1 to 1 led mapping to each port.
    Definition        LED Statuses            Description
    0000        LED_Off                LED pin Tri-State.
    0001        Dup/Col                Collision, Full duplex Indicator. Blinking every 43ms when collision happens. Low for full duplex, and high for half duplex mode.
    0010        Link/Act               Link, Activity Indicator. Low for link established. Link/Act Blinks every 43ms when the corresponding port is transmitting or receiving.
    0011        Spd1000                1000Mb/s Speed Indicator. Low for 1000Mb/s.
    0100        Spd100                 100Mb/s Speed Indicator. Low for 100Mb/s.
    0101        Spd10                  10Mb/s Speed Indicator. Low for 10Mb/s.
    0110        Spd1000/Act            1000Mb/s Speed/Activity Indicator. Low for 1000Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
    0111        Spd100/Act             100Mb/s Speed/Activity Indicator. Low for 100Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
    1000        Spd10/Act              10Mb/s Speed/Activity Indicator. Low for 10Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
    1001        Spd100 (10)/Act        10/100Mb/s Speed/Activity Indicator. Low for 10/100Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
    1010        Fiber                  Fiber link Indicator. Low for Fiber.
    1011        Fault                  Auto-negotiation     Fault Indicator. Low for Fault.
    1100        Link/Rx                Link, Activity Indicator. Low for link established. Link/Rx Blinks every 43ms when the corresponding port is transmitting.
    1101        Link/Tx                Link, Activity Indicator. Low for link established. Link/Tx Blinks every 43ms when the corresponding port is receiving.
    1110        Master                 Link on Master Indicator. Low for link Master established.
    1111        Act                    Activity Indicator. Low for link established. 
 */
ret_t rtl8370_setAsicLedIndicateInfoConfig(uint32 ledno, enum RTL8370_LEDCONF config)
{
    ret_t retVal;
    uint32 regData;
    const uint16 bits[RTL8370_LEDGROUPMAX+1]= { RTL8370_LED0_CFG_MASK, RTL8370_LED1_CFG_MASK, RTL8370_LED2_CFG_MASK};
    const uint16 offsets[RTL8370_LEDGROUPMAX+1]= { RTL8370_LED0_CFG_OFFSET, RTL8370_LED1_CFG_OFFSET, RTL8370_LED2_CFG_OFFSET};

    if(ledno > RTL8370_LEDGROUPMAX)
        return RT_ERR_INPUT;

    if(config > LEDCONF_ACT)    
        return RT_ERR_INPUT;

    retVal = rtl8370_getAsicReg(RTL8370_REG_LED_CONFIGURATION,&regData);  
	if( retVal !=  RT_ERR_OK)
		return retVal;

    regData = regData & (~RTL8370_LED_CONFIG_SEL_MASK);
    regData = regData & (~bits[ledno]);
    regData = regData | ((config & RTL8370_LED0_CFG_MASK)<<offsets[ledno]);

    retVal = rtl8370_setAsicReg(RTL8370_REG_LED_CONFIGURATION,regData);     

    return retVal;
}

/* Function Name:
 *      rtk_led_operation_set
 * Description:
 *      Set Led operation mode
 * Input:
 *      mode - LED operation mode.
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      The API can set Led operation mode.
 *      The modes that can be set are as following:
 *      LED_OP_SCAN,
 *      LED_OP_PARALLEL,
 *      LED_OP_SERIAL,
 */
rtk_api_ret_t rtk_led_operation_set(rtk_led_operation_t mode)
{
    rtk_api_ret_t retVal;
    uint32 regData;

    if ( mode >= LED_OP_END)
      return RT_ERR_INPUT;

    switch (mode)
    {
        case LED_OP_SCAN:
            regData = 1;
            break;
         case LED_OP_PARALLEL:
            regData = 2;
            break;
        case LED_OP_SERIAL:
            regData = 3;
            if ((retVal = rtl8370_setAsicLedSerialModeConfig(0, 1))!=RT_ERR_OK)
                return retVal;
            if ((retVal = rtl8370_setAsicLedSerialEnable(ENABLED))!=RT_ERR_OK)
                return retVal;
            break;
        default:
            regData = 0;
            break;
    }

    if ((retVal = rtl8370_setAsicLedOperationMode(regData))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/* Function Name:
 *      rtk_led_mode_set
 * Description:
 *      Set Led to congiuration mode
 * Input:
 *      mode - Support LED mode.
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      There are three LED groups for each port for indicating information about dedicated port.
 *      LED groups are set to indicate different information of port in different mode.
 *
 *      Mode0
 *      LED0-Link, Activity Indicator. Low for link established. Link/Act Blinks every 43ms when the corresponding port is transmitting or receiving.
 *      LED1-1000Mb/s Speed Indicator. Low for 1000Mb/s.
 *      LED2-100Mb/s Speed Indicator. Low for 100Mb/s.
 *
 *      Mode1
 *      LED0-Link, Activity Indicator. Low for link established. Link/Act Blinks every 43ms when the corresponding port is transmitting or receiving.
 *      LED1-1000Mb/s Speed Indicator. Low for 1000Mb/s.
 *      LED2-Collision, Full duplex Indicator. Blinking every 43ms when collision happens. Low for full duplex, and high for half duplex mode.
 *
 *      Mode2
 *      LED0-Collision, Full duplex Indicator. Blinking every 43ms when collision happens. Low for full duplex, and high for half duplex mode.
 *      LED1-1000Mb/s Speed/Activity Indicator. Low for 1000Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
 *      LED2-10/100Mb/s Speed/Activity Indicator. Low for 10/100Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
 *
 *      Mode3
 *      LED0-10Mb/s Speed/Activity Indicator. Low for 10Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
 *      LED1-1000Mb/s Speed/Activity Indicator. Low for 1000Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
 *      LED2-100Mb/s Speed/Activity Indicator. Low for 100Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
 */

rtk_api_ret_t rtk_led_mode_set(rtk_led_mode_t mode)
{
    rtk_api_ret_t retVal;

    if (mode >= LED_MODE_END)
        return RT_ERR_FAILED;

    if ((retVal = rtl8370_setAsicLedGroupMode(mode))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/* Function Name:
 *      rtk_led_groupConfig_set
 * Description:
 *      Set per group Led to congiuration mode
 * Input:
 *      group - LED group.
 *      config - LED configuration
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      The API can set LED indicated information configuration for each LED group with 1 to 1 led mapping to each port.
 *      Definition  LED Statuses      Description
 *      0000        LED_Off           LED pin Tri-State.
 *      0001        Dup/Col           Collision, Full duplex Indicator.
 *      0010        Link/Act          Link, Activity Indicator.
 *      0011        Spd1000           1000Mb/s Speed Indicator.
 *      0100        Spd100            100Mb/s Speed Indicator.
 *      0101        Spd10             10Mb/s Speed Indicator.
 *      0110        Spd1000/Act       1000Mb/s Speed/Activity Indicator.
 *      0111        Spd100/Act        100Mb/s Speed/Activity Indicator.
 *      1000        Spd10/Act         10Mb/s Speed/Activity Indicator.
 *      1001        Spd100 (10)/Act   10/100Mb/s Speed/Activity Indicator.
 *      1010        Fiber             Fiber link Indicator.
 *      1011        Fault             Auto-negotiation Fault Indicator.
 *      1100        Link/Rx           Link, Activity Indicator.
 *      1101        Link/Tx           Link, Activity Indicator.
 *      1110        Master            Link on Master Indicator.
 *      1111        Act               Activity Indicator. Low for link established.
 */
rtk_api_ret_t rtk_led_groupConfig_set(rtk_led_group_t group, rtk_led_congig_t config)
{
    rtk_api_ret_t retVal;

    if ( LED_GROUP_END <= group)
        return RT_ERR_FAILED;

    if ( LED_CONFIG_END <= config)
        return RT_ERR_FAILED;

     if ((retVal = rtl8370_setAsicLedIndicateInfoConfig(group, config))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/*
@func ret_t | rtl8370_getAsicLedBlinkRate | Get led blinking rate ate mode 0 to mode 3
@parm enum RTL8370_LEDBLINKRATE* | blinkRate | Support 6 blink rates.
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@comm
    The API can set LED blink rate at 43ms, 84ms, 120ms, 170ms, 340ms and 670ms.
 */
ret_t rtl8370_getAsicLedBlinkRate(enum RTL8370_LEDBLINKRATE* blinkRate)
{
    return rtl8370_getAsicRegBits(RTL8370_REG_LED_MODE, RTL8370_SEL_LEDRATE_MASK,(uint32*)blinkRate);
}

/* Function Name:
 *      rtk_led_blinkRate_get
 * Description:
 *      Get LED blinking rate at mode 0 to mode 3
 * Input:
 *      None
 * Output:
 *      pBlinkRate - blinking rate.
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      There are  6 types of LED blinking rates at 43ms, 84ms, 120ms, 170ms, 340ms and 670ms.
 */
rtk_api_ret_t rtk_led_blinkRate_get(rtk_data_t *pBlinkRate)
{
    rtk_api_ret_t retVal;

    if ((retVal = rtl8370_getAsicLedBlinkRate(pBlinkRate))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/* for leds control  */
/* initial and enable led */
static int init_and_enable_leds(void)
{
    int retVal;
    rtl8370_port_status_t portstatus;
    rtk_portmask_t portmask;
    rtk_data_t BlinkRate;

    /* enable p0/p1 */
    portmask.bits[0] = 0x3;

    retVal = rtk_led_enable_set(LED_GROUP_0, portmask);
    //printf("rtk_led_enable_set(LED_GROUP_0...): return %d\n", retVal);
    retVal = rtk_led_enable_set(LED_GROUP_1, portmask);
    //printf("rtk_led_enable_set(LED_GROUP_1...): return %d\n", retVal);

    retVal = rtk_led_operation_set(LED_OP_PARALLEL);
    //printf("rtk_led_operation_set(): return %d\n", retVal);

    retVal = rtk_led_mode_set(LED_MODE_1);
    //printf("rtk_led_mode_set(): return %d\n", retVal);
    /*
    retVal = rtk_led_blinkRate_set(LED_BLINKRATE_256MS);
    printf("rtk_led_blinkRate_set(): return %d\n", retVal);
    */

    /* LED_CONFIG_SPD10010ACT - 1001 */
    retVal = rtk_led_groupConfig_set(LED_GROUP_0, LED_CONFIG_SPD1000);
    //printf("rtk_led_groupConfig_set(LED_GROUP_0,LED_CONFIG_SPD1000ACT): return %d\n", retVal);
    retVal = rtk_led_groupConfig_set(LED_GROUP_1, LED_CONFIG_SPD1000ACT);
    //printf("rtk_led_groupConfig_set(LED_GROUP_1,LED_CONFIG_SPD1000ACT): return %d\n", retVal);

        /* LED_CONFIG_SPD10010ACT - 1001 */
    retVal = rtk_led_groupConfig_set(LED_GROUP_0, LED_CONFIG_SPD1000);
    //printf("rtk_led_groupConfig_set(LED_GROUP_0,LED_CONFIG_LINK_ACT): return %d\n", retVal);
    retVal = rtk_led_groupConfig_set(LED_GROUP_1, LED_CONFIG_LINK_ACT);
    //printf("rtk_led_groupConfig_set(LED_GROUP_1,LED_CONFIG_LINK_ACT): return %d\n",retVal);

    rtk_led_blinkRate_get(&BlinkRate);
    //printf("current led blinkRate: %d\n", BlinkRate);

    if (bFixLed)
    {
        retVal = rtl8370_getAsicPortStatus(PORT0, &portstatus);
        if (RT_ERR_OK != retVal)
        {
            printf("%s: rtl8370_getAsicPortStatus failed! retVal=0x%x\n", __func__, retVal);
        }
        else
        {
            /* GE0未工作在1000M，强制P0黄灯为1(因为P0LED0黄灯设置为反的) */
            if (portstatus.speed != SPD_1000M)
            {
                /*
            	 * 00: normal mode(not force)
            	 * 01: cpu force led to blink
            	 * 10: cpu force led to 0
            	 * 11: cpu force led to 1
            	 */ 
                simple_phy_write(RTL8370_REG_CPU_FORCE_LED0_CFG0, 0x03);
            }
        }
    }    

    return retVal;
}

static int link_func(void *data)
{
    rtl8370_port_status_t   portstatus;
    int                     retVal = 0;
    rtk_portmask_t          portmask;
    while(!kthread_should_stop()){
        mutex_lock(&acl_cb->lock);
        retVal = rtl8370_getAsicPortStatus(PORT0, &portstatus);
        if (RT_ERR_OK == retVal)
        {
            
            if (portstatus.speed != SPD_1000M)
            {
                portmask.bits[0] = 0x02;                
            }
            else
            {
                portmask.bits[0] = 0x03;   
            }
            retVal = rtk_led_enable_set(LED_GROUP_2, portmask);        
        }
        mutex_unlock(&acl_cb->lock);
        msleep(100);
        
        //mod_timer(&link_timer, jiffies + 100);
    }
    return 0;
}

/*************************************************************************************
* Function: init_leds() (参考16.Port)
* Desc: 灯态参考MTG1000b(黄灯:SPEED/绿灯:LINK)
*       黄灯P0LED0/P1LED0设置为: 指示是否工作在1000M、绿灯P0LED1/P1LED1设置为: 指示是否linkup[亮]/有无数据收发[闪]
*       (MTG2000/MTG2500/MTG3000非常有必要指示GE1/GE0是否工作在1000M)
*       由于硬件通过P0LED0进行初始化接口设置，致GE0黄灯常亮，在此增加判断，如果GE0未工作在1000M，disable 黄灯
*       后面，周期性检查GE0是否工作在1000M，如果是，enable 黄灯、否则disable 黄灯
*
* Return: No
**************************************************************************************/
void init_leds(void)
{
    rtl8370_port_status_t   portstatus;
    rtk_portmask_t          portmask;
    int                     retVal = 0;

    retVal = rtk_led_operation_set(LED_OP_PARALLEL);
    if (RT_ERR_OK != retVal)
    {
        printk("%s: rtk_led_operation_set failed! retVal=0x%x\n", __func__, retVal);
    }    
    retVal = rtk_led_mode_set(LED_MODE_1);
    if (RT_ERR_OK != retVal)
    {
        printk("%s: rtk_led_mode_set failed! retVal=0x%x\n", __func__, retVal);
    }

    {
        retVal = rtk_led_groupConfig_set(LED_GROUP_1, LED_CONFIG_LINK_ACT);
        retVal = rtk_led_groupConfig_set(LED_GROUP_0, LED_CONFIG_SPD1000);
        if (RT_ERR_OK != retVal)
        {
            printk("%s: rtk_led_groupConfig_set failed! retVal=0x%x\n", __func__, retVal);
        }
    
        /* enalbe 绿灯+黄灯 */
        portmask.bits[0] = 0x3; //P1(GE1)+P0(GE0)
        retVal = rtk_led_enable_set(LED_GROUP_1, portmask); //LED_GROUP_1指所有绿灯
        retVal = rtk_led_enable_set(LED_GROUP_0, portmask); //LED_GROUP_0指所有黄灯

        retVal = rtk_led_groupConfig_set(LED_GROUP_2, LED_CONFIG_SPD100);
        if (RT_ERR_OK != retVal)
        {
            printk("%s: rtk_led_groupConfig_set failed! retVal=0x%x\n", __func__, retVal);
        }     
    }
    
    if (RT_ERR_OK != retVal)
    {
        printk("%s: rtk_led_enable_set failed! retVal=0x%x\n", __func__, retVal);
    }

    /*8370的port0的指示灯有问题，在上电后如果进行了复位操作，port0的网口速率指示灯不能
      正常工作，必须通过手动的方式来点*/
    if(1)
    {
        retVal = rtl8370_getAsicPortStatus(PORT0, &portstatus);
        if (RT_ERR_OK != retVal)
        {
            printk("%s: rtl8370_getAsicPortStatus failed! retVal=0x%x\n", __func__, retVal);
        }
        else
        {
            /* GE0未工作在1000M，强制P0黄灯为1(因为P0LED0黄灯设置为反的) */
            if (portstatus.speed != SPD_1000M)
            {
                portmask.bits[0] = 0x02;                
            }
            else
            {
                portmask.bits[0] = 0x03;   
            }
            retVal = rtk_led_enable_set(LED_GROUP_2, portmask);
        }

        led_run_tsk = kthread_run(link_func, NULL, "1000M_link_led"); 
	
        if(IS_ERR(led_run_tsk)){
            printk(KERN_INFO "create 1000M_link_led kthread failed!\n");  
        }  
        else 
        {  
            printk(KERN_INFO "create 1000M_link_led ktrhead ok!\n");  
        }  
        /* 开启定时器，修复GE0黄灯常亮 */
        //setup_timer(&link_timer, link_func, (unsigned long)"link!");
        //link_timer.expires = jiffies + 200;
        //add_timer(&link_timer);
    }   
}

void uninit_leds(void)
{
    if(!IS_ERR(led_run_tsk))
    {
        kthread_stop(led_run_tsk);
        led_run_tsk = NULL;
    }
}

/*
@func ret_t | rtl8370_setAsicPortExtMode | Set external interface mode configuration.
@parm uint32 | id | external interface id (0~1).
@parm uint32 |mode | external interface mode.
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@rvalue RT_ERR_FAILED | Invalid parameter.
@comm
  This API can set external interface mode properties. 
    DISABLE,
    RGMII,
    MII_MAC,
    MII_PHY, 
    TMII_MAC,
    TMII_PHY, 
    GMII,
    RGMII_33V,    
 */
ret_t rtl8370_setAsicPortExtMode(uint32 id, uint32 mode)
{
    ret_t retVal;
    
    if(id >= RTL8370_EXTNO)
        return RT_ERR_INPUT;	

    if(mode > EXT_RGMII_33V)
        return RT_ERR_INPUT;	

    if( mode == EXT_RGMII_33V || mode == EXT_RGMII )
    {
        if((retVal= rtl8370_setAsicReg(RTL8370_REG_CHIP_DEBUG0,0x0367)) !=  RT_ERR_OK)
            return retVal;
        if((retVal= rtl8370_setAsicReg(RTL8370_REG_CHIP_DEBUG1,0x7777)) !=  RT_ERR_OK)
            return retVal;
    }
    else if((mode == EXT_TMII_MAC)||(mode == EXT_TMII_PHY))
    {
        if((retVal= rtl8370_setAsicRegBit(RTL8370_REG_BYPASS_LINE_RATE,(id+1)%2,1)) !=  RT_ERR_OK)
            return retVal;
    } 
    else if( mode == EXT_GMII )
    {
        if((retVal= rtl8370_setAsicRegBit(RTL8370_REG_CHIP_DEBUG0,RTL8370_CHIP_DEBUG0_DUMMY_0_OFFSET+id,1)) !=  RT_ERR_OK)
            return retVal;
        if((retVal= rtl8370_setAsicRegBit(RTL8370_REG_EXT0_RGMXF+id,6,1)) !=  RT_ERR_OK)
            return retVal;        
    } 
    else 
    {
        if((retVal= rtl8370_setAsicRegBit(RTL8370_REG_BYPASS_LINE_RATE,(id+1)%2,0)) !=  RT_ERR_OK)
            return retVal;
        if((retVal= rtl8370_setAsicRegBit(RTL8370_REG_EXT0_RGMXF+id,6,0)) !=  RT_ERR_OK)
            return retVal;     
    }      

    return rtl8370_setAsicRegBits(RTL8370_REG_DIGITIAL_INTERFACE_SELECT, RTL8370_SELECT_RGMII_0_MASK<<(id*RTL8370_SELECT_RGMII_1_OFFSET), mode);
}

/*
@func ret_t | rtl8370_getAsicPortForceLinkExt | Get external interface force linking configuration.
@parm uint32 | id | external interface id (0~1).
@parm rtl8370_port_ability_t* | portability | port ability configuration
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@rvalue RT_ERR_FAILED | Invalid parameter.
@comm
      This API can get external interface force mode properties. 
 */
ret_t rtl8370_getAsicPortForceLinkExt(uint32 id, rtl8370_port_ability_t *portability)
{
    ret_t retVal;
    uint32 regData;
    uint16 *accessPtr;
    rtl8370_port_ability_t ability;

    /* Invalid input parameter */
    if(id >= RTL8370_EXTNO)
        return RT_ERR_PORT_ID;
    
    memset(&ability,0x00,sizeof(rtl8370_port_ability_t));


    accessPtr =  (uint16*)&ability;
 
    retVal = rtl8370_getAsicReg(RTL8370_REG_DIGITIAL_INTERFACE0_FORCE + id, &regData);
    if(retVal !=  RT_ERR_OK)
        return retVal;
    
    *accessPtr = regData;

    memcpy(portability, &ability, sizeof(rtl8370_port_ability_t));        
    
    return RT_ERR_OK;  
}

ret_t __rtl8370_getAsicPortForceLink(uint32 id, rtl8370_port_ability_t *portability)
{
    ret_t retVal;
    uint32 regData;
    uint16 *accessPtr;
    rtl8370_port_ability_t ability;

    /* Invalid input parameter */
    if(id > RTL8370_MAC7)
        return RT_ERR_PORT_ID;
    
    memset(&ability,0x00,sizeof(rtl8370_port_ability_t));


    accessPtr =  (uint16*)&ability;
 
    retVal = rtl8370_getAsicReg(RTL8370_REG_MAC0_FORCE_SELECT + id, &regData);
    if(retVal !=  RT_ERR_OK)
        return retVal;
    
    *accessPtr = regData;

    memcpy(portability, &ability, sizeof(rtl8370_port_ability_t));        
    
    return RT_ERR_OK;  
}

/*
@func ret_t | rtl8370_setAsicPortForceLinkExt | Set external interface force linking configuration.
@parm uint32 | id | external interface id (0~1).
@parm rtl8370_port_ability_t* | portability | port ability configuration
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@rvalue RT_ERR_FAILED | Invalid parameter.
@comm
      This API can set external interface force mode properties. 
 */
ret_t rtl8370_setAsicPortForceLinkExt(uint32 id, rtl8370_port_ability_t *portability)
{
    uint32 regData;
    uint16 *accessPtr;
    rtl8370_port_ability_t ability;

    /* Invalid input parameter */
    if(id >=RTL8370_EXTNO)
        return RT_ERR_PORT_ID;
    
    memset(&ability, 0x00, sizeof(rtl8370_port_ability_t));
    memcpy(&ability, portability, sizeof(rtl8370_port_ability_t));    

    accessPtr = (uint16*)&ability;
 
    regData = *accessPtr;

    return rtl8370_setAsicReg(RTL8370_REG_DIGITIAL_INTERFACE0_FORCE + id, regData);
}

ret_t __rtl8370_setAsicPortForceLink(uint32 id, rtl8370_port_ability_t *portability)
{
    uint32 regData;
    uint16 *accessPtr;
    rtl8370_port_ability_t ability;

    /* Invalid input parameter */
    if(id > RTL8370_MAC7)
        return RT_ERR_PORT_ID;
    
    memset(&ability, 0x00, sizeof(rtl8370_port_ability_t));
    memcpy(&ability, portability, sizeof(rtl8370_port_ability_t));

    accessPtr = (uint16*)&ability;
 
    regData = *accessPtr;

    return rtl8370_setAsicReg(RTL8370_REG_MAC0_FORCE_SELECT + id, regData);
}

/* Function Name:
 *      rtk_port_macForceLinkExt0_set
 * Description:
 *      Set external interface 0 force linking configuration.
 * Input:
 *      mode - external interface mode
 *      pPortability - port ability configuration
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      This API can set external interface 0 force mode properties.
 *      The external interface can be set to:
 *      MODE_EXT_DISABLE,
 *      MODE_EXT_RGMII,
 *      MODE_EXT_MII_MAC,
 *      MODE_EXT_MII_PHY,
 *      MODE_EXT_TMII_MAC,
 *      MODE_EXT_TMII_PHY,
 *      MODE_EXT_GMII,
 *      MODE_EXT_RGMII_33V,
 */
rtk_api_ret_t rtk_port_macForceLinkExt0_set(rtk_mode_ext_t mode, rtk_port_mac_ability_t *pPortability)
{
    rtk_api_ret_t retVal;
    rtl8370_port_ability_t ability;

    if (mode >=MODE_EXT_END)
        return RT_ERR_INPUT;

    if (pPortability->forcemode>1||pPortability->speed>2||pPortability->duplex>1||
       pPortability->link>1||pPortability->nway>1||pPortability->txpause>1||pPortability->rxpause>1)
        return RT_ERR_INPUT;

    if ((retVal = rtl8370_setAsicPortExtMode(RTK_EXT_0, mode))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_getAsicPortForceLinkExt(RTK_EXT_0,&ability))!=RT_ERR_OK)
        return retVal;

    ability.forcemode = pPortability->forcemode;
    ability.speed     = pPortability->speed;
    ability.duplex    = pPortability->duplex;
    ability.link      = pPortability->link;
    ability.nway      = pPortability->nway;
    ability.txpause   = pPortability->txpause;
    ability.rxpause   = pPortability->rxpause;

    if ((retVal = rtl8370_setAsicPortForceLinkExt(RTK_EXT_0,&ability))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

rtk_api_ret_t rtk_port_macForceLink_set(rtk_port_t port, rtk_port_mac_ability_t *pPortability)
{
    rtk_api_ret_t retVal;
    rtl8370_port_ability_t ability;

    if (pPortability->forcemode>1||pPortability->speed>2||pPortability->duplex>1||
       pPortability->link>1||pPortability->nway>1||pPortability->txpause>1||pPortability->rxpause>1)
        return RT_ERR_INPUT;

    if ((retVal = __rtl8370_getAsicPortForceLink(port,&ability))!=RT_ERR_OK)
        return retVal;

    ability.forcemode = pPortability->forcemode;
    ability.speed     = pPortability->speed;
    ability.duplex    = pPortability->duplex;
    ability.link      = pPortability->link;
    ability.nway      = pPortability->nway;
    ability.txpause   = pPortability->txpause;
    ability.rxpause   = pPortability->rxpause;

    if ((retVal = __rtl8370_setAsicPortForceLink(port,&ability))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/* Function Name:
 *      rtk_port_macForceLinkExt1_set
 * Description:
 *      Set external interface 1 force linking configuration.
 * Input:
 *      mode - external interface mode
 *      pPortability - port ability configuration
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      This API can set external interface 1 force mode properties.
 *      The external interface can be set to:
 *      MODE_EXT_DISABLE,
 *      MODE_EXT_RGMII,
 *      MODE_EXT_MII_MAC,
 *      MODE_EXT_MII_PHY,
 *      MODE_EXT_TMII_MAC,
 *      MODE_EXT_TMII_PHY,
 *      MODE_EXT_GMII,
 *      MODE_EXT_RGMII_33V,
 */
rtk_api_ret_t rtk_port_macForceLinkExt1_set(rtk_mode_ext_t mode, rtk_port_mac_ability_t *pPortability)
{
    rtk_api_ret_t retVal;
    rtl8370_port_ability_t ability;

    if (mode >=MODE_EXT_END)
        return RT_ERR_INPUT;

    if (pPortability->forcemode>1||pPortability->speed>2||pPortability->duplex>1||
       pPortability->link>1||pPortability->nway>1||pPortability->txpause>1||pPortability->rxpause>1)
        return RT_ERR_INPUT;

    if ((retVal = rtl8370_setAsicPortExtMode(RTK_EXT_1, mode))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_getAsicPortForceLinkExt(RTK_EXT_1,&ability))!=RT_ERR_OK)
        return retVal;

    ability.forcemode = pPortability->forcemode;
    ability.speed     = pPortability->speed;
    ability.duplex    = pPortability->duplex;
    ability.link      = pPortability->link;
    ability.nway      = pPortability->nway;
    ability.txpause   = pPortability->txpause;
    ability.rxpause   = pPortability->rxpause;

    if ((retVal = rtl8370_setAsicPortForceLinkExt(RTK_EXT_1,&ability))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

static int set_ext_mode(void)
{
    int retVal;
    rtk_port_mac_ability_t mac_cfg;
    rtk_mode_ext_t mode;

    mode = MODE_EXT_RGMII;
    mac_cfg.forcemode = MAC_FORCE;
    mac_cfg.speed = SPD_1000M;
    mac_cfg.duplex = FULL_DUPLEX;
    mac_cfg.link = PORT_LINKUP;
    mac_cfg.nway = DISABLED;
    mac_cfg.txpause = ENABLED;
    mac_cfg.rxpause = ENABLED;

    retVal = rtk_port_macForceLinkExt0_set(mode, &mac_cfg);
    //printf("rtk_port_macForceLinkExt0_set:set ext0 force 1000M speed,retVal %d\n", retVal);

    retVal = rtk_port_macForceLinkExt1_set(mode, &mac_cfg);
    //printf("rtk_port_macForceLinkExt1_set:set ext1 force 1000M speed,retVal %d\n", retVal);
    return retVal;
}

static int set_phy_mode(void)
{
    int retVal, i;
    rtk_port_mac_ability_t mac_cfg;

    mac_cfg.forcemode = MAC_FORCE;
    mac_cfg.speed = SPD_1000M;
    mac_cfg.duplex = FULL_DUPLEX;
    mac_cfg.link = PORT_LINKUP;
    mac_cfg.nway = DISABLED;
    mac_cfg.txpause = DISABLED;
    mac_cfg.rxpause = DISABLED;

    /**MTG3000和MTG3000C: port4用于主备通信
         MTG2000:   没有主备通信，除外网口外其他都是用户板
         MTG2500和sbcmain: prot5用于主备通信
    */
#if defined(PRODUCT_MTG2500MAIN)
    if((back_board_type == BOARD_MTG3000)  ||(back_board_type == BOARD_MTG3000C))
    {
        retVal = rtk_port_macForceLink_set(PORT4, &mac_cfg);
        if(RT_ERR_OK != retVal)
        {
            return retVal;
        }
        return retVal;
    }
    if(back_board_type == BOARD_MTG2000)
    {
        return 0;
    }
#endif
    for(i=2; i<=RTL8370_MAC7; i++)
    {
        retVal = rtk_port_macForceLink_set(i, &mac_cfg);
        if(RT_ERR_OK != retVal)
        {
            return retVal;
        }
    }
    return retVal;
}


/* Function Name:
 *      rtk_port_rgmiiDelayExt0_set
 * Description:
 *      Set RGMII interface 0 delay value for TX and RX.
 * Input:
 *      txDelay - TX delay value, 1 for delay 2ns and 0 for no-delay
 *      rxDelay - RX delay value, 0~7 for delay setup.
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      This API can set external interface 0 RGMII delay.
 *      In TX delay, there are 2 selection: no-delay and 2ns delay.
 *      In RX dekay, there are 8 steps for delay tunning. 0 for no-delay, and 7 for maximum delay.
 */
rtk_api_ret_t rtk_port_rgmiiDelayExt0_set(rtk_data_t txDelay, rtk_data_t rxDelay)
{
    rtk_api_ret_t retVal;
    uint32 regData;

    if ((txDelay > 1)||(rxDelay > 7))
        return RT_ERR_INPUT;

    if ((retVal = rtl8370_getAsicReg(RTL8370_REG_EXT0_RGMXF, &regData))!=RT_ERR_OK)
        return retVal;

    regData = (regData&0xFFF0) | ((txDelay<<3)&0x0008) | (rxDelay&0x007);

    if ((retVal = rtl8370_setAsicReg(RTL8370_REG_EXT0_RGMXF, regData))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/* Function Name:
 *      rtk_port_rgmiiDelayExt1_set
 * Description:
 *      Set RGMII interface 1 delay value for TX and RX.
 * Input:
 *      txDelay - TX delay value, 1 for delay 2ns and 0 for no-delay
 *      rxDelay - RX delay value, 0~7 for delay setup.
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      This API can set external interface 1 RGMII delay.
 *      In TX delay, there are 2 selection: no-delay and 2ns delay.
 *      In RX dekay, there are 8 steps for delay tunning. 0 for n0-delay, and 7 for maximum delay.
 */
rtk_api_ret_t rtk_port_rgmiiDelayExt1_set(rtk_data_t txDelay, rtk_data_t rxDelay)
{
    rtk_api_ret_t retVal;
    uint32 regData;

    if ((txDelay > 1)||(rxDelay > 7))
        return RT_ERR_INPUT;

    if ((retVal = rtl8370_getAsicReg(RTL8370_REG_EXT1_RGMXF, &regData))!=RT_ERR_OK)
        return retVal;

    regData = (regData&0xFFF0) | ((txDelay<<3)&0x0008) | (rxDelay&0x007);

    if ((retVal = rtl8370_setAsicReg(RTL8370_REG_EXT1_RGMXF, regData))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

static int init_ext_interface(void)
{
   int retVal;

   /* set external interface 0 rgmii mode*/
   retVal = rtl8370_setAsicPortExtMode(RTK_EXT_0, MODE_EXT_RGMII); //RTK_EXT_0 - PORT9
   //printf("rtl8370_setAsicPortExtMode:set ext0 RGMII mode,retVal %d\n", retVal);

   /* set external interface 0 rgmii mode*/
   retVal = rtl8370_setAsicPortExtMode(RTK_EXT_1, MODE_EXT_RGMII);   //RTK_EXT_1 - PORT8
   //printf("rtl8370_setAsicPortExtMode:set ext1 RGMII mode,retVal %d\n", retVal);

///-
#if 0
   retVal = rtk_port_rgmiiDelayExt0_set(1, 4);
   printf("rtk_port_rgmiiDelayExt0_set:set ext0 RGMII delay tx:1,rx:0,retVal %d\n", retVal);

   retVal = rtk_port_rgmiiDelayExt1_set(1, 4);
   printf("rtk_port_rgmiiDelayExt1_set:set ext1 RGMII delay tx:1,rx:0,retVal %d\n", retVal);
#else
    retVal = rtk_port_rgmiiDelayExt0_set(1, 5);
    //printf("rtk_port_rgmiiDelayExt0_set:set ext0 RGMII delay tx:1,rx:5,retVal %d\n", retVal);

    retVal = rtk_port_rgmiiDelayExt1_set(1, 5);
    //printf("rtk_port_rgmiiDelayExt1_set:set ext1 RGMII delay tx:1,rx:5,retVal %d\n", retVal);
#endif


   return retVal;
}

/*
@func ret_t | rtl8370_setAsicPortIsolationPermittedPortmask | Set permitted port isolation portmask
@parm uint32 | port | Physical port number (0~15).
@parm uint32 | permitPortmask | portmask (0~0xFFFF)
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error. 
@rvalue RT_ERR_PORT_ID | Invalid port number.
@rvalue RT_ERR_PORT_MASK | Invalid portmask.
@comm
    This API set the port mask that a port can trasmit packet to of each port
    A port can only transmit packet to ports included in permitted portmask
*/
ret_t rtl8370_setAsicPortIsolationPermittedPortmask(uint32 port, uint32 permitPortmask)
{
    if(port >= RTL8370_PORTNO)
        return RT_ERR_PORT_ID;

    if(permitPortmask > RTL8370_PORTMASK)
        return RT_ERR_PORT_MASK;
    
    return rtl8370_setAsicReg(RTL8370_PORT_ISOLATION_PORT_MASK_REG(port), permitPortmask);
}

/* Function Name:
 *      rtk_port_isolation_set
 * Description:
 *      Set permitted port isolation portmask
 * Input:
 *      port - port id.
 *      portmask - Permit port mask
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_PORT_ID - Invalid port number.
 *      RT_ERR_PORT_MASK - Invalid portmask.
 * Note:
 *      This API set the port mask that a port can trasmit packet to of each port
 *      A port can only transmit packet to ports included in permitted portmask
 */
rtk_api_ret_t rtk_port_isolation_set(rtk_port_t port, rtk_portmask_t portmask)
{
    rtk_api_ret_t retVal;

    if (port > RTK_PORT_ID_MAX)
        return RT_ERR_PORT_ID;

    if ( portmask.bits[0] > RTK_MAX_PORT_MASK)
        return RT_ERR_PORT_MASK;

    if ((retVal = rtl8370_setAsicPortIsolationPermittedPortmask(port,portmask.bits[0]))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/******************************************************************
  * Function: rtk8370_set_phy_powerdown
  * Desc: 1) uboot下8370未划分VLAN，增加对网管口、CPU1、业务口、CPU0隔离，可以避免业务口与网管口同时接入后网络故障，
  *          但uboot下业务口与网管口同时接入，影响通过串口升级(不能ping通server)，在此powerdown网管口，在8370ko中恢复
  *          (仅业务口接入可以ping通server，无需powerdown网管口)
  * Note: 
  * Input:        
  * Output: 
  * Return: 
  */
void rtk8370_set_phy_powerdown(uint32 port, uint32 bEnable)
{
    uint32              phyData;
    int                 retVal = RT_ERR_OK;
    
    if ((retVal = rtl8370_setAsicPHYReg(port,PHY_PAGE_ADDRESS,0))!=RT_ERR_OK)
    {
        printk(KERN_ERR "%s: rtl8370_setAsicPHYReg failed! port=%d retVal=0x%x\n", __func__, port, retVal);
        return;
    }

    if ((retVal = rtl8370_getAsicPHYReg(port,PHY_CONTROL_REG,&phyData))!=RT_ERR_OK)
    {
        printk(KERN_ERR "%s: rtl8370_getAsicPHYReg failed! port=%d retVal=0x%x\n", __func__, port, retVal);
        return;
    }

    if (bEnable)
    {
        phyData |= (1 << 11);
    }
    else
    {
        phyData &= (~(1 << 11));
    }
    if ((retVal = rtl8370_setAsicPHYReg(port,PHY_CONTROL_REG,phyData))!=RT_ERR_OK)
    {
        printk(KERN_ERR "%s: rtl8370_setAsicPHYReg failed! port=%d phyData=0x%x retVal=0x%x\n", __func__, port, phyData, retVal);
    }
    else
    {
        printk(KERN_ERR "%s: rtl8370_setAsicPHYReg succ! port=%d phyData=0x%x\n", __func__, port, phyData);
    }
}

/******************************************************************
  * Function: rtk8370_mirror_add2cpu
  * Desc:添加镜像功能
  * Note:    
  *       rtk_mirror_portBased_set(rtk_port_t mirroring_port, rtk_portmask_t *pMirrored_rx_portmask, rtk_portmask_t *pMirrored_tx_portmask)
             函数参数(功能)说明:
          1) mirroring_port为desire port，即期望接收到报文端口
          2) pMirrored_rx_portmask为8370端口收到报文方向，如报文从业务板侧到8370对应端口
          3) pMirrored_tx_portmask为8370端口发送报文方向，如报文从8370对应端口到各业务板侧
  * Input: 
  *         
  * Output: 
  *
  * Return: 
  */
int rtk8370_mirror_add2cpu(rtk_mirror_port_t *user_mirrorport)
{
///-
#if 1
    rtk_port_t          rtkport;
    rtk_portmask_t      rx_portmask;
    rtk_portmask_t      tx_portmask;
    int                 retVal = RT_ERR_OK;
    int src_port = user_mirrorport->mirror_src_port;
    printk(KERN_ERR "%s  dst =%d src=%d\n",
                        __FUNCTION__, user_mirrorport->mirror_dst_port, user_mirrorport->mirror_src_port);
    if(src_port > RTK_MAX_PROT)
    {
        printk(KERN_ERR "%s invalid src_port %d\n", __FUNCTION__, src_port);
        return RT_ERR_FAILED;
    }

    retVal = rtk_mirror_portBased_get(&rtkport, &rx_portmask, &tx_portmask);
    if( retVal != RT_ERR_OK )
	{
		printk("  %s: rtk_mirror_portBased_set failed! src_port=%d retVal=0x%x\n", __func__, src_port, retVal);
        goto err;
	}
    else
    {
        printk("  %s: src_port:%d rtkport:%u rx_portmask:%u tx_portmask:%u\n", __func__, src_port, rtkport, rx_portmask.bits[0], tx_portmask.bits[0]);    
    }
    printk("  %s: mirror_direct:%d n", __func__, user_mirrorport->mirror_direct);
    
    if(user_mirrorport->mirror_direct ==MIRROR_DIREXT_RX)
    {
        rx_portmask.bits[0] = ((uint32)1 << src_port);
        tx_portmask.bits[0] = 0;
    }
    else if(user_mirrorport->mirror_direct==MIRROR_DIREXT_TX)
    {
        tx_portmask.bits[0] = ((uint32)1 << src_port);
        rx_portmask.bits[0] = 0;    
    }
    else if(user_mirrorport->mirror_direct==MIRROR_DIREXT_BOTH)
    {
        rx_portmask.bits[0] = ((uint32)1 << src_port);
        tx_portmask.bits[0] = ((uint32)1 << src_port);
    }
   /* The mirror port can only be set to one port */   
    retVal = rtk_mirror_portBased_set(user_mirrorport->mirror_dst_port, &rx_portmask, &tx_portmask);
    if( retVal != RT_ERR_OK )
	{
		printk("  %s: rtk_mirror_portBased_set failed! src_port=%d retVal=0x%x rx_portmask:0x%x tx_portmask:0x%x\n", __func__, 
            src_port, retVal, rx_portmask.bits[0], tx_portmask.bits[0]);
        goto err;
	}

    printk("  %s: src_port:%d mirror add succ!\n", __func__, src_port);
    return RT_ERR_OK;

 err:
    return retVal;
#else
    return RT_ERR_OK;
#endif
}

int rtk8370_mirror_del2cpu(rtk_mirror_port_t *user_mirrorport)
{
///-
#if 1
    rtk_port_t          rtkport ;
    rtk_portmask_t      rx_portmask;
    rtk_portmask_t      tx_portmask;
    int                 retVal = RT_ERR_OK;
    int src_port = user_mirrorport->mirror_src_port;
    
    if(src_port >= RTK_MAX_PROT)
    {
        printk(KERN_ERR "%s invalid src_port %d\n", __FUNCTION__, src_port);
        return RT_ERR_FAILED;
    }

    retVal = rtk_mirror_portBased_get(&rtkport, &rx_portmask, &tx_portmask);
    if( retVal != RT_ERR_OK )
    {
    	printk("  %s: rtk_mirror_portBased_set failed! src_port=%d retVal=0x%x\n", __func__, src_port, retVal);
        goto err;
    }
    else
    {
        printk("  %s: src_port:%d rtkport:%u rx_portmask:%u tx_portmask:%u\n", __func__, src_port, rtkport, rx_portmask.bits[0], tx_portmask.bits[0]);    
    }

    rx_portmask.bits[0] = 0x0;
    tx_portmask.bits[0] = 0x0;
    retVal = rtk_mirror_portBased_set(user_mirrorport->mirror_dst_port, &rx_portmask, &tx_portmask);
    if( retVal != RT_ERR_OK )
	{
		printk("  %s: rtk_mirror_portBased_set failed! src_port=%d retVal=0x%x rx_portmask:0x%x tx_portmask:0x%x\n", __func__, 
            src_port, retVal, rx_portmask.bits[0], tx_portmask.bits[0]);
        goto err;
	}

    printk("  %s: src_port:%d mirror del succ!\n", __func__, src_port);
    return RT_ERR_OK;

 err:
    return retVal;
#else
    return RT_ERR_OK;
#endif
}

/******************************************************************
  * Function: rtk8370_isolation_cfg(参考4.15 Port Isolation)
  * Desc: 1) dtu2业务板初始化完成后，此时eth0 mac未知，只能以广播报文形式上报槽位号，为避免广播报文发送到设备外，
  *          在uboot中做了限制(接口板对应网口发出的所有报文，只允许转发到CPU0对应网口)，等8370ko中acl配置完成后，
  *          必须打开此限制(rtk8370_acl_broadcast_from_dtu可以仅限制来自接口板广播报文到达eth0)，否则来自业务板的rtp报文也不能送到外网
  *       2) uboot下8370未划分VLAN，避免业务口与网管口同时接入，增加对网管口、CPU1、业务口、CPU0隔离 
  * Note: 
  * Input:        
  * Output: 
  * Return: 
  */
int rtk8370_isolation_cfg(void)
{
    rtk_portmask_t      portmask;
    int                 i;
    int                 retVal = RT_ERR_OK;
    uint32              error = 0;

    {
        /* 1) 隔离网管口、CPU1、业务口、CPU0 */
        /* a) 隔离网管口收到的报文 */
        portmask.bits[0] = 0x00;
        retVal = rtk_port_isolation_set(PORT0, portmask);
        if( retVal != RT_ERR_OK )
        {
            printf("%s: rtk_port_isolation_set failed! port=%d retVal=0x%x\n", __func__, PORT0, retVal);
        }
        /* 0) 网管口powerdown */
        rtk8370_set_phy_powerdown(PORT0, TRUE);        
        /* b) 隔离CPU1网口发出的报文 */
        portmask.bits[0] = 0x00;
        retVal = rtk_port_isolation_set(PORT9, portmask);
        if( retVal != RT_ERR_OK )
        {
            printf("%s: rtk_port_isolation_set failed! port=%d retVal=0x%x\n", __func__, PORT9, retVal);
        }
       
        /* c) 业务口只允许到达CPU1 */
        portmask.bits[0] = PORT8_MASK;
        retVal = rtk_port_isolation_set(PORT1, portmask);
        if( retVal != RT_ERR_OK )
        {
            printf("%s: rtk_port_isolation_set failed! port=%d retVal=0x%x\n", __func__, PORT1, retVal);
        }
        /* d) CPU0只允许到达业务口 */
        portmask.bits[0] = PORT1_MASK;
        retVal = rtk_port_isolation_set(PORT8, portmask);
        if( retVal != RT_ERR_OK )
        {
            printf("%s: rtk_port_isolation_set failed! port=%d retVal=0x%x\n", __func__, PORT8, retVal);
        }
    }
    
    /* e) 与接口板对接的6个网口都隔离 */
    portmask.bits[0] = 0;
    for (i = 0; i < ulMaxDtuNum; i++)
    {
        /* 2) 隔离从接口板出来的报文 */
        retVal = rtk_port_isolation_set(slot_port[i], portmask);
        if( retVal != RT_ERR_OK )
        {
            printf("%s: rtk_port_isolation_set failed! slot=%d retVal=0x%x\n", __func__, i, retVal);
            error = 1;
        }
        rtk8370_set_phy_powerdown(slot_port[i],TRUE);
    }

    if (error)
    {
        printf("rtk8370_isolation_cfg failed!\n");
    }
    else
    {
        printf("rtk8370_isolation_cfg succ!\n");
    }

    return retVal;
}

/*
@func ret_t | rtl8370_getAsicPortIsolationPermittedPortmask | Get permitted port isolation portmask
@parm uint32 | port | Physical port number (0~15).
@parm uint32* | permitPortmask | portmask (0~0xFFFF)
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error. 
@rvalue RT_ERR_PORT_ID | Invalid port number.
@comm
    This API get the port mask that a port can trasmit packet to of each port
    A port can only transmit packet to ports included in permitted portmask
*/
ret_t rtl8370_getAsicPortIsolationPermittedPortmask(uint32 port, uint32 *permitPortmask)
{
    if(port >= RTL8370_PORTNO)
        return RT_ERR_PORT_ID;
    
    return rtl8370_getAsicReg(RTL8370_PORT_ISOLATION_PORT_MASK_REG(port), permitPortmask);
}

/* Function Name:
 *      rtk_port_isolation_get
 * Description:
 *      Get permitted port isolation portmask
 * Input:
 *      port - Port id.
 * Output:
 *      pPortmask - Permit port mask
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_PORT_ID - Invalid port number.
 * Note:
 *      This API get the port mask that a port can trasmit packet to of each port
 *      A port can only transmit packet to ports included in permitted portmask
 */
rtk_api_ret_t rtk_port_isolation_get(rtk_port_t port, rtk_portmask_t *pPortmask)
{
    rtk_api_ret_t retVal;

    if (port > RTK_PORT_ID_MAX)
        return RT_ERR_PORT_ID;

    if ((retVal = rtl8370_getAsicPortIsolationPermittedPortmask(port,&pPortmask->bits[0]))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

static int rtk8370_print_isolation_cfg(void)
{
    rtk_portmask_t      portmask;
    int                 i;
    int                 retVal = RT_ERR_OK;

    for (i = PORT0; i <= PORT9; i++)
    {
        retVal = rtk_port_isolation_get(i, &portmask);
        if( retVal != RT_ERR_OK )
        {
            printf("%s: rtk_port_isolation_get failed! port=%d retVal=0x%x\n", __func__, i, retVal);
        }
        else
        {
            printf("  rtk_port_isolation_get:  port=%u portmask=0x%x\n", i,  portmask.bits[0]);
        }
    }
    return retVal;
}

static int gpio_test_open(struct inode *ino, struct file *filp)
{
    return 0;
}

static int gpio_test_close(struct inode *ino, struct file *filp)
{
    return 0;
}

static ssize_t gpio_test_write(struct file *filp, const char __user *buf, size_t count, loff_t *off)
{
	char c;
	int rc;

	rc = get_user(c, buf);
	if (rc)
		return rc;
	if (c == '1')
    {
        int val = 0;
        while(1)
        {
            if(val)
            {
                _rtl865x_setGpioDataBit(smi_SCK, 1);
                val = 0;
            }
            else
            {
                val = 1;
                _rtl865x_setGpioDataBit(smi_SCK, 0);
            }
        }
    }

	return count;

}

static struct file_operations gpio_test_fops =
{
    .open = gpio_test_open,
    .release = gpio_test_close,
    .write = gpio_test_write,
};

static int rtl_reset_open(struct inode *ino, struct file *filp)
{
    return 0;
}

static int rtl_reset_close(struct inode *ino, struct file *filp)
{
    return 0;
}

static ssize_t rtl_reset_write(struct file *filp, const char __user *buf, size_t count, loff_t *off)
{
	char c[128];
	int rc;

    memset(c, 0, sizeof(c));
	rc = copy_from_user(c, buf, sizeof(c) > count ? count : sizeof(c));
	if (rc)
		return rc;
	if (0 == strncmp("hr", c, 2))
    {
        mii_phy_reset(1);
    }
    else if(0 == strncmp("sr", c, 2))
    {
        mii_phy_reset(0);
    }

	return count;
}

static struct file_operations rtl_reset_fops =
{
    .open = rtl_reset_open,
    .release = rtl_reset_close,
    .write = rtl_reset_write,
};

static int rtl_reg_save_open(struct inode *ino, struct file *filp)
{
    return 0;
}

static int rtl_reg_save_close(struct inode *ino, struct file *filp)
{
    return 0;
}

static ssize_t rtl_reg_save_write(struct file *filp, const char __user *buf, size_t count, loff_t *off)
{
	char c[128];
	int rc, i;
    uint32 val; 

    memset(c, 0, sizeof(c));
	rc = copy_from_user(c, buf, sizeof(c) > count ? count : sizeof(c));
	if (rc)
		return rc;
	if (0 == strncmp("d", c, 1))
    {
        changable = 0;
    }
    else if(0 == strncmp("cmp", c, 3))
    {
        for(i=0; i<(sizeof(reg_save)/sizeof(reg_save[0])); i++)
        {
            if(0xffff != reg_save[i].reg)
            {
                acl_lock();
                if(RT_ERR_OK != simple_phy_read(reg_save[i].reg, &val))
                {
                    acl_unlock();
                    printk(KERN_ERR "read reg 0x%x error\n", reg_save[i].reg);
                    continue;
                }
                acl_unlock();
                if((val & 0xffff) != reg_save[i].val)
                {
                    printk(KERN_ERR "reg 0x%04x last write val 0x%04x, reg val 0x%04x\n",
                        reg_save[i].reg, reg_save[i].val, val & 0xffff);
                }
            }
        }
    }

	return count;
}

static struct file_operations rtl_reg_save_fops =
{
    .open = rtl_reg_save_open,
    .release = rtl_reg_save_close,
    .write = rtl_reg_save_write,
};

static void reset_rtl8370(void)
{
    u32 reg_val;

    reg_val = readl(SUNXI_PIO_BASE + 0x94);
    reg_val &= ~(0xf << 4);
    reg_val |= (0x1 << 4);
    writel(reg_val, SUNXI_PIO_BASE + 0x94);
    reg_val = readl(SUNXI_PIO_BASE + 0xac);
    reg_val &= ~(0x3 << 18);
    reg_val |= (0x1 << 18);
    writel(reg_val, SUNXI_PIO_BASE + 0xac);
    
    reg_val = readl(SUNXI_PIO_BASE + 0xa0);
    reg_val &= ~(1 << 9);
    writel(reg_val, SUNXI_PIO_BASE + 0xa0);

    /*延时至少10ms*/
    mdelay(20);
    
    reg_val = readl(SUNXI_PIO_BASE + 0xa0);
    reg_val |= (1 << 9);
    writel(reg_val, SUNXI_PIO_BASE + 0xa0);

    /*复位信号拉高后，要延迟至少78ms*/
    mdelay(100);
}

static void mii_phy_reset(int hard_reset)
{
    unsigned int data = 0;
    unsigned int retVal;
    u16 phy_val;
    int i;

    uninit_leds();
    rtk_acl_exit();

    if(hard_reset)
    {
        reset_rtl8370();
    }

    /*关闭板间通信的phy口*/
    for(i=2; i<=7; i++)
    {
        rtk8370_set_phy_powerdown(i, 1);
    }
    
    rtl8370_setAsicPortEnableAll(DISABLED);
    rtl8370_setAsicPortEnableAll(DISABLED);
    rtl8370_getAsicPortEnableAll(&data);
    //printf("disable getAsicPortEnableAll:0x%x\n", data);    
    
    /*after reset, switch need to delay 1 ms
        if not, SMI may send out unknown data
    */
    udelay(1000);
    
    retVal = rtk_switch_init();
    if (retVal  != RT_ERR_OK)
    {
         return;
    }
    
    /* 1) 隔离接口板与外网 */
    //rtk8370_isolation_cfg();
    //rtk8370_print_isolation_cfg();
    
    test_smi_signal_and_wait();
    
    /* tom: for test */
    //smi_write(0x13a0, 0x123);
    data = geth_phy_read(0, 0x2022);
    //printf("debug,reg PHY ID value=0x%x\n", data);
    
    /* led enable */
    init_and_enable_leds();
    
    /* force cpu 1000M mode */
    // bit13 要为0 6282 page 579 
    //MV_REG_WRITE(0x7243C, 0x00a4060f);//rnii0 ge1 1000m
    
    /* force 8370M 1000M node */
    set_ext_mode();
    
    init_ext_interface();
    
///-
    /* 将板间通信的接口固定设置为1000M全双工，禁止流控*/
    set_phy_mode();
    retVal =  rtk_qos_cfg();
    if( retVal != RT_ERR_OK )
    {
        printk(KERN_ERR"rtk_qos_cfg failed !!! .\n");
    }	

#if defined(PRODUCT_MTG2500MAIN)
    if((back_board_type == BOARD_MTG3000) || (back_board_type == BOARD_MTG2000) ||(back_board_type == BOARD_MTG3000C))
    {  
        rtk8370_hardware_init();
        //rtk8370_isolation_cfg();
        rtk8370_isolation_cfg_normal();
        rtk8370_print_isolation_cfg(); 
        
        retVal = rtk8370_auto_learning_cfg();
        if( retVal != RT_ERR_OK )
        {   
            printk(KERN_ERR "RTK8370M config auto learning failed.\n");
        }

        /* 设置设置业务口与网管口: 为1000M/100M全双工/自协商能力 */
        rtk8370_set_ge_autoneg();                  
    }     
#endif

#if defined(PRODUCT_SBCMAIN) || defined(PRODUCT_MTG2500MAIN)
    rtk_cpu_enable_set(ENABLED);
    rtk_cpu_tagPort_set(8, CPU_INSERT_TO_ALL);
#endif
#if defined(PRODUCT_UC200)
    {
        rtk_portmask_t mbrmsk, untagmask;
        rtk_vlan_init();

        mbrmsk.bits[0] = 0x101;
        untagmask.bits[0] = 0x1;
        if(RT_ERR_OK != rtk_vlan_set(1, mbrmsk, untagmask, 0))
        {
            printk(KERN_ERR "%s %d rtk_vlan_set error\n", __FUNCTION__, __LINE__);
        }
        mbrmsk.bits[0] = 0x17e;
        untagmask.bits[0] = 0x7e;
        if(RT_ERR_OK != rtk_vlan_set(2, mbrmsk, untagmask, 0))
        {
            printk(KERN_ERR "%s %d rtk_vlan_set error\n", __FUNCTION__, __LINE__);
        }

        rtk_vlan_portPvid_set(0, 1, 0);
        rtk_vlan_portPvid_set(1, 2, 0);

        //rtk_vlan_portAcceptFrameType_set(0, ACCEPT_FRAME_TYPE_UNTAG_ONLY);
        //rtk_vlan_portAcceptFrameType_set(1, ACCEPT_FRAME_TYPE_UNTAG_ONLY);
        //rtk_vlan_portAcceptFrameType_set(8, ACCEPT_FRAME_TYPE_TAG_ONLY);

        //rtk_vlan_tagMode_set(8, VLAN_TAG_MODE_KEEP_FORMAT);
        
        /*禁止RMII口的mac地址学习功能。如果开启了rmii口的学习功能，当不同的vlan
          接口设置成桥模式时，一个vlan中的广播从rmii发送出来后，会被linux的桥
          又发回去，这时rmii口会学习到不正确的源mac，如果再次向改来源主机发送
          报文，会因为端口记录的源mac和报文的目的相同产生冲突，导致报文丢弃*/
        rtl8370_setAsicReg(RTL8370_REG_LUT_PORT8_LEARN_LIMITNO, 0);
    }
#endif
    
    // 使能所有网口 前面被powerdowm的不会工作
    rtl8370_setAsicPortEnableAll(ENABLED);
    rtl8370_setAsicPortEnableAll(ENABLED);
    rtl8370_getAsicPortEnableAll(&data);
    printk(KERN_ERR "Enable getAsicPortEnableAll:0x%x\n", data);

    /* ACL配置为8370核心功能 */
    retVal = rtk8370_acl_cfg();
    if( retVal != RT_ERR_OK )
    {	
    	printk(KERN_ERR "RTK8370M config acl failed !!! .\n");
    }
    /* 设置GE1/GE0 LED工作模式，同时修复GE0黄灯常亮 */
    init_leds();
}

#if defined(PRODUCT_MTG2500MAIN)
void rtk8370_set_ge_autoneg(void)
{
    rtk_port_ability_conf_t stPortConf;
    int retVal = 0;
    int i;

    stPortConf.phyability.AutoNegotiation = 1;
    stPortConf.phyability.Half_10 = 0;
    stPortConf.phyability.Full_10 = 0;
    stPortConf.phyability.Half_100 = 0;
    stPortConf.phyability.Full_100 = 1;
    stPortConf.phyability.Full_1000 = 1;
    stPortConf.phyability.FC = 0;    
    stPortConf.phyability.AsyFC = 0; //取缺省值

    for( i=PORT0; i<=PORT1; i++)
    {
        stPortConf.port = i;
        retVal = rtk_port_phyAutoNegoAbility_set(stPortConf.port, &stPortConf.phyability);
    	if(retVal != RT_ERR_OK)
    	{
    		printk(KERN_ERR "%s: rtk_port:%d phyAutoNegoAbility_set error:0x%x\n", __func__, i, retVal);
    	}		

    }

}

void  rtk8370_set_phyport_work_mode(int phyport)
{
    rtk_port_ability_conf_t stPortConf;
    int retVal = 0;

    stPortConf.phyability.AutoNegotiation = 0;
    stPortConf.phyability.Half_10 = 0;
    stPortConf.phyability.Full_10 = 0;
    stPortConf.phyability.Half_100 = 0;
    stPortConf.phyability.Full_100 = 1;
    stPortConf.phyability.Full_1000 = 0;
    stPortConf.phyability.FC = 0;    
    stPortConf.phyability.AsyFC = 0; //取缺省值

    if((phyport  > 1) && (phyport < 8))
    {
        if(((back_board_type == BOARD_MTG3000)&&(phyport !=4)) ||
            ((back_board_type == BOARD_MTG3000C)&&(phyport !=4)) ||
                (back_board_type == BOARD_MTG2000))        
        {
            stPortConf.port = phyport;
            retVal = rtk_port_phyForceModeAbility_set(stPortConf.port, &stPortConf.phyability);
            if(retVal != RT_ERR_OK)
            {
                printk(KERN_ERR "%s: rtk_port:%d phyAutoNegoAbility_set fail:0x%x\n", __func__, stPortConf.port, retVal);
            }      		 
        }
    }            
}

/**************************************************************************************
* Function: rtk8370_auto_learning_cfg()
* Desc: 禁用8370M 接口板接口的学习功能，CPU口与GE口不禁用，并配置静态的MAC look-up table
*       原因: 通常媒体流转发路径为从接口板到GE1 或者从GE1到接口板，不经CPU口(除非需要抓包)
*       如果不禁用接口板学习，每个接口板发到外部的rtp报文，(源mac都为eth0)会造成接口板对应接口的学习频繁切换，导致交换网混乱
*
* Return: RT_ERR_OK, success/otherwise
***************************************************************************************/
int rtk8370_auto_learning_cfg( void )
{
    u32 i;
    int retVal = 0;

    /* 禁用接口板的学习功能 */
    //... mtg 3000 port4 是主备板通讯用，不禁用自动学习????
    for( i=PORT2; i<=PORT7; i++)
    {
        //don't learning
        if(((back_board_type == BOARD_MTG3000)&&(i == PORT4)) ||
            ((back_board_type == BOARD_MTG3000C)&&(i == PORT4)))
        {
			continue;
        }
        retVal = rtk_l2_limitLearningCnt_set(i, 0);
    	if(retVal != RT_ERR_OK)
    	{
    		printk("rtk_l2_limitLearningCnt_set failed:%d\n", i);
			return retVal;
    	}	
    	printk("port:%u rtk_l2_limitLearningCnt_set sucess \n", i);
    }
    return  retVal;
	
}




//网口在非bonding模式下，
// 1、支持双网口收发rtp， 
// 2、设备内时序(dsp内、业务板内dsp之间和业务板间的dsp之间)也能转发rtp
// 3、主控侧rtk8370要转发业务板间的dsp之间的时序的rtp
// PORT0网管口 PORT1业务口 
// PORT9 rgmii0 linux内核eth1收发网管口报文  可以包含sip 
// PORT8 rgmii1 linux内核eth0收发业务口报文 主要是sip 
// PORT2-PORT7 连接dtu2/8 sdh板 监控板
/*
 8370共10个端口，2个RGMII，8个PHY口，按如下分配使用:
    port8 - (H8的 RGMII) 
    port9 - NC
    port0 - GE0(RJ1) 接网管口
    port1 - GE1(RJ2) 接业务口(与串口相邻位置)

    FRAME_MTG2000端口与槽位对应如下:
    每个slot 有1个stm32 单片机和2个dsp 3个静态mac条目
    port6 - slot0 
    port3 - slot1 
    port2 - slot2
    port5 - slot3
    port4 - slot4
    port7 - NC

    FRAME_MTG3000端口与槽位对应如下:
    每个slot 有1个stm32 单片机和8个dsp 9个静态mac条目
    port3 - slot0 
    port6 - slot1 
    port2 - slot2
    port7 - slot3
    port5 - slot4 sdh 板 
    port4 -  主备主控板之间通讯网口
*/
int rtk8370_isolation_cfg_normal(void)
{
    rtk_portmask_t      slot_mask;
    rtk_portmask_t      portmask;
    int                 retVal = RT_ERR_OK;
    int slot;
    slot_mask.bits[0] = ( ((uint32)1<<slot_port[0]) | ((uint32)1<<slot_port[1]) | ((uint32)1<<slot_port[2])
                        | ((uint32)1<<slot_port[3]) | ((uint32)1<<slot_port[4]) | ((uint32)1<<slot_port[5]) );

    /* d) PORT8发出的报文可以到业务口、网管口、接口板(0x889b和0x8607收发) 主备主控板通讯网口 */
    portmask.bits[0] = PORT0_MASK|PORT1_MASK | slot_mask.bits[0];
    retVal = rtk_port_isolation_set(PORT8, portmask);
    if( retVal != RT_ERR_OK )
    {
        printk("%s: rtk_port_isolation_set failed! port=%d retVal=0x%x\n", __func__, PORT8, retVal);
    }

    /* c)port9 rgmii 没接 不收发报文 */
    portmask.bits[0] = 0;
    retVal = rtk_port_isolation_set(PORT9, portmask);
    if( retVal != RT_ERR_OK )
    {
        printk("%s: rtk_port_isolation_set failed! port=%d retVal=0x%x\n", __func__, PORT9, retVal);
    }
    
    if((back_board_type == BOARD_MTG3000) || (back_board_type == BOARD_MTG3000C))
    {
        slot_mask.bits[0] = ( ((uint32)1<<slot_port[0]) | ((uint32)1<<slot_port[1]) | ((uint32)1<<slot_port[2])
                            | ((uint32)1<<slot_port[3])  );
                            
        /* a) GE0 网管口收到的报文可到达PORT8和接口板 */
        portmask.bits[0] = PORT8_MASK | slot_mask.bits[0];
        //portmask.bits[0] = (uint32)1<<1;
        retVal = rtk_port_isolation_set(PORT0, portmask);
        if( retVal != RT_ERR_OK )
        {
            printk("%s: rtk_port_isolation_set failed! port=%d retVal=0x%x\n", __func__, PORT0, retVal);
        }

        /* b) GE1 业务口收到的报文到达PORT8，同时也允许送达接口板 */
        portmask.bits[0] = PORT8_MASK | slot_mask.bits[0];
        //portmask.bits[0] = (uint32)1;
        retVal = rtk_port_isolation_set(PORT1, portmask);
        if( retVal != RT_ERR_OK )
        {
            printk("%s: rtk_port_isolation_set failed! port=%d retVal=0x%x\n", __func__, PORT1, retVal);
        }
        
        /* e) 每个业务口 DTU8 0-3 来的报文限制转发到业务网口、网管口 PORT8 和接口板之间 */
        for(slot = 0;slot<ulMaxDtuNum;slot++)
        {
            portmask.bits[0] = (PORT0_MASK|PORT1_MASK | slot_mask.bits[0]|PORT8_MASK);
            portmask.bits[0] &= ~(0x0001<<slot_port[slot]);
            retVal = rtk_port_isolation_set(slot_port[slot], portmask);
        }

        // sdh 板对接网口的报文只转发到port8 cpu
        portmask.bits[0] = PORT8_MASK ;
        retVal = rtk_port_isolation_set(PORT5, portmask);
        if( retVal != RT_ERR_OK )
        {
            printk("%s: rtk_port_isolation_set failed! port=%d retVal=0x%x\n", __func__, PORT5, retVal);
        }	


        // 主备主控板通讯网口 的报文只访问port8 cpu
        portmask.bits[0] = PORT8_MASK ;
        retVal = rtk_port_isolation_set(PORT4, portmask);
        if( retVal != RT_ERR_OK )
        {
            printk("%s: rtk_port_isolation_set failed! port=%d retVal=0x%x\n", __func__, PORT4, retVal);
        }
        
    }
    else
    {
        // mtg2000  5 个slot dtu2 
        slot_mask.bits[0] = ( ((uint32)1<<slot_port[0]) | ((uint32)1<<slot_port[1]) | ((uint32)1<<slot_port[2])
                            | ((uint32)1<<slot_port[3]) |  ((uint32)1<<slot_port[4]));
                            
        /* a) GE0  网管口收到的报文可到达PORT8和接口板 */
        portmask.bits[0] = PORT8_MASK | slot_mask.bits[0];
        retVal = rtk_port_isolation_set(PORT0, portmask);
        if( retVal != RT_ERR_OK )
        {
            printk("%s: rtk_port_isolation_set failed! port=%d retVal=0x%x\n", __func__, PORT0, retVal);
        }

        /* b) GE1 业务口收到的报文到达PORT8，同时也允许送达接口板 */
        portmask.bits[0] = PORT8_MASK | slot_mask.bits[0];
        retVal = rtk_port_isolation_set(PORT1, portmask);
        if( retVal != RT_ERR_OK )
        {
            printk("%s: rtk_port_isolation_set failed! port=%d retVal=0x%x\n", __func__, PORT1, retVal);
        }

        /* e) 每个业务口来的报文限制转发到业务网口、网管口 PORT8 和接口板之间 */
        for(slot = 0;slot<ulMaxDtuNum;slot++)
        {
            portmask.bits[0] = (PORT0_MASK|PORT1_MASK | slot_mask.bits[0]|PORT8_MASK);
            portmask.bits[0] &= ~(0x0001<<slot_port[slot]);
            retVal = rtk_port_isolation_set(slot_port[slot], portmask);
        }

        /* c)port7 nc  没接 不收发报文 */
        portmask.bits[0] = 0;
        retVal = rtk_port_isolation_set(PORT7, portmask);
        if( retVal != RT_ERR_OK )
        {
            printk("%s: rtk_port_isolation_set failed! port=%d retVal=0x%x\n", __func__, PORT7, retVal);
        }	    
    }
    return retVal;
}
int rtk8370m_soft_reset(void)
{
    unsigned int retVal;
    u16 phy_val;
    rtk_portmask_t      portmask;
    rtk_trunk_hashVal2Port_t Algo_bitmask;
    
    phy_val = geth_phy_read(4, 0x130f) & 0xffff;
    printf(KERN_WARNING "phy 8370 reg 0x%x val 0x%x\n", 0x130f, phy_val);
    
	/* 根据配置决定是否启用VLAN，缺省启用 */
    printk(KERN_WARNING "!!! RTK8370M ulEthPortApplyMode:0x%x\n", ulEthPortApplyMode);

    if(ulEthPortApplyMode == DEV_ETHNET_PORT_TRUNKING)
    {
        portmask.bits[0] = PORT0_MASK|PORT1_MASK;
        retVal = rtk_trunk_port_set(TRUNK_GROUP0,portmask);
        portmask.bits[0] = 0;
        rtk_trunk_port_get(TRUNK_GROUP0,&portmask);
        printk("\r\n !!! rtk_trunk_port_get portmask:0x%x\r\n", portmask.bits[0]);
        //Algo_bitmask.value[0] = 0x03;
        //rtk_trunk_distributionAlgorithm_set(RTK_WHOLE_SYSTEM,Algo_bitmask);
        Algo_bitmask.value[0] = 0;
        rtk_trunk_distributionAlgorithm_get(RTK_WHOLE_SYSTEM,&Algo_bitmask);
        printk("\r\n !!! trunk_distributionAlgorithm_get:0x%x\r\n", Algo_bitmask.value[0]);
    }  
    
    return 0;
}

/******************************************************************
  * Function: rtk8370m_set_slotport_workmode
  * Desc: 8370端口与业务板8236端口之间必须保证为100M全双工，否则协商为10M，可能满呼叫时丢包严重，
  *       之前设置8236侧为固定100M全双工非协商，8370为默认支持协商，结果出现协商结果为100M半双工
  *       因此，8236侧使用默认值支持协商，8370端口全部为固定100M全双工协商
  * Note: 
  * Input:       
  * Output: 
  * Return: 
  */
int rtk8370m_set_slotport_workmode(rtk_port_phy_ability_t *pstPhyAbility)
{
    int retVal = 0;
    int port;

    /* MTG3000 slot4/slot5(MON+SDH)也通过8236与8370对接，都配置为100M Full */
    for(port=PORT2; port<=PORT7; port++)
    {
        rtk8370_set_phy_powerdown(port, FALSE);
    }

    for(port=PORT2; port<=PORT7; port++)
    {
        if(((back_board_type == BOARD_MTG3000)&&(port == PORT4)) ||
            ((back_board_type == BOARD_MTG3000C)&&(port == PORT4)))
        {
			continue;
        }
        
        if (pstPhyAbility->AutoNegotiation)
        {
            retVal = rtk_port_phyAutoNegoAbility_set(port, pstPhyAbility);
        }
        else
        {
            retVal = rtk_port_phyForceModeAbility_set(port, pstPhyAbility);
        }
    	if(retVal != RT_ERR_OK)
    	{
    		printk(KERN_ERR "%s: rtk_port:%d Negotiation:%d phyAbility_set error:0x%x\n", __func__, port, pstPhyAbility->AutoNegotiation, retVal);
    	}		
    }
    return retVal;
}

/* Function Name:
 *      mtg_filter_igrAcl_init 
 * Description:
 *      ACL initialization function, only for external port0/por1
 * Input:
 *      None
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_NULL_POINTER    - Pointer pFilter_field or pFilter_cfg point to NULL.
 * Note:
 *      This function enable and intialize ACL function
 */

void rtk8370_hardware_init( void )
{
    switch(back_board_type)
    {
    case BOARD_MTG3000:
    case BOARD_MTG3000C:
        ulMaxDtuNum  = 4;
        //rtpport_unit = 0x800;  /* 每个slot需要分配2048个rtp/rtcp端口 */
        break;

    case BOARD_MTG2000:
        ulMaxDtuNum  = 5;
        //rtpport_unit = 0x200;  /* 每个slot需要分配512个rtp/rtcp端口 */
        slot_port[0] = PORT6;
        slot_port[1] = PORT3;
        slot_port[2] = PORT2;
        slot_port[3] = PORT5;
        slot_port[4] = PORT4;
        slot_port[5] = PORT7;
        break;
    default:
        ulMaxDtuNum  = 5;
        //rtpport_unit = 0x200;  /* 每个slot需要分配512个rtp/rtcp端口 */
        break; 
    }

}


/*************************************************************************************
* Function: rtk8370m_open()
* Desc: driver device ioctl interface
*
* Return: No
**************************************************************************************/
int rtk8370m_open(struct inode *inode, struct file *file)
{
    /* do nothing */
	return 0;
}

/*************************************************************************************
* Function: rtk8370m_release()
* Desc: driver device release interface
*
* Return: No
**************************************************************************************/
int rtk8370m_release(struct inode *inode, struct file *file)
{
    /* do nothing */
	return 0;
}

static long rtk8370_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{

    rtk_api_ret_t           retVal = RT_ERR_OK;
    int              port;
    rtk_stat_port_cntr_t    pPort_cntrs;
    rtk_port_linkStatus_t   pLinkStatus = 0;
    rtk_data_t              pSpeed = 0;
    rtk_port_ability_conf_t stPortConf;
    rtk_port_phy_ability_t  stPhyAbility;
    rtk_port_mib_t          stPortMib;
    struct reg_param_s      param;

    void __user             *argp = (void __user*)arg;

    switch(cmd) {

        case RTK_SOFT_RESET:
            if (copy_from_user(&port, (int __user *)arg, sizeof(int)))
            {
            	return -EFAULT;
            }
            /* 1) 如果启用网管口支持媒体流转发(默认网管口不支持) 2)硬件版本为0，app中如果有复位8370，必须重新初始化，RGMII口需要配置  */
            if (port > 0)
            {

                printk("rtk8370m_ioctl RTK_SOFT_RESET,port:%u\n", port);
                // port 0:单网口转发rtp流 1: 双网口转发rtp流(transcode 时用到) 2:porttrunking ge0和ge1相互备份
                
                if(port <= DEV_ETHNET_PORT_TRUNKING)
                {
            		ulEthPortApplyMode = port;
                }
                else
                {
            		ulEthPortApplyMode = DEV_ETHNET_PORT_NORMAL;
                }
                //ulEthPortApplyMode = DEV_ETHNET_PORT_NORMAL;//DEV_ETHNET_PORT_TRANSCODERUNKING;
                mutex_lock(&acl_cb->lock);
                retVal = rtk8370m_soft_reset();
             mutex_unlock(&acl_cb->lock);
            }
            break;    
            
        case RTK_PORT_PHY_STAT_GET:

            if (copy_from_user(&port, (int __user *)arg, sizeof(int)))
            {
                return -EFAULT;
            }

            /* check */
            if(port > RTK_PORT_ID_MAX)
            {
                return -EINVAL;
            }
            mutex_lock(&acl_cb->lock);
            retVal = rtk8370m_link_status_get(port, &pLinkStatus);
            mutex_unlock(&acl_cb->lock);
            put_user(pLinkStatus, (unsigned int __user *)arg);
            break;
            
        case RTK_PORT_ALL_STAT_GET:

            if (copy_from_user(&port, (int __user *)arg, sizeof(int)))
            {
                return -EFAULT;
            }
            mutex_lock(&acl_cb->lock);
            retVal = rtk_stat_port_getAll(port, &pPort_cntrs);
            if (retVal == RT_ERR_OK)
            {
                printk("ifInOctets:%lld \ndot3StatsFCSErrors:%d \ndot3StatsSymbolErrors:%d \n"\
                	   "dot3InPauseFrames:%d \ndot3ControlInUnknownOpcodes:%d \netherStatsFragments:%d \n"\
                	   "etherStatsJabbers:%d \nifInUcastPkts:%d \netherStatsDropEvents:%d \netherStatsOctets:%lld \n"\
                	   "etherStatsUndersizePkts:%d \netherStatsOversizePkts:%d \netherStatsPkts64Octets:%d \n"\
                	   "etherStatsPkts65to127Octets:%d \netherStatsPkts128to255Octets:%d \netherStatsPkts256to511Octets:%d \n"\
                	   "etherStatsPkts512to1023Octets:%d \netherStatsPkts1024toMaxOctets:%d \n"\
                	   "etherStatsMcastPkts:%d \netherStatsBcastPkts:%d \nifOutOctets:%lld \ndot3StatsSingleCollisionFrames:%d \n"\
                	   "dot3StatsMultipleCollisionFrames:%d \ndot3StatsDeferredTransmissions:%d \n"\
                	   "dot3StatsLateCollisions:%d \netherStatsCollisions:%d \ndot3StatsExcessiveCollisions:%d \n"\
                	   "dot3OutPauseFrames:%d \ndot1dBasePortDelayExceededDiscards:%d \ndot1dTpPortInDiscards:%d \n"\
                	   "ifOutUcastPkts:%d \nifOutMulticastPkts:%d \nifOutBrocastPkts:%d \noutOampduPkts:%d \n"\
                	   "inOampduPkts:%d \npktgenPkts:%d\n\n",
                	   pPort_cntrs.ifInOctets, pPort_cntrs.dot3StatsFCSErrors,
                	   pPort_cntrs.dot3StatsSymbolErrors, pPort_cntrs.dot3InPauseFrames,
                	   pPort_cntrs.dot3ControlInUnknownOpcodes, pPort_cntrs.etherStatsFragments,
                	   pPort_cntrs.etherStatsJabbers, pPort_cntrs.ifInUcastPkts,
                	   pPort_cntrs.etherStatsDropEvents, pPort_cntrs.etherStatsOctets,
                       pPort_cntrs.etherStatsUndersizePkts, pPort_cntrs.etherStatsOversizePkts,
                	   pPort_cntrs.etherStatsPkts64Octets, pPort_cntrs.etherStatsPkts65to127Octets,
                	   pPort_cntrs.etherStatsPkts128to255Octets, pPort_cntrs.etherStatsPkts256to511Octets,
                	   pPort_cntrs.etherStatsPkts512to1023Octets, pPort_cntrs.etherStatsPkts1024toMaxOctets,
                	   pPort_cntrs.etherStatsMcastPkts, pPort_cntrs.etherStatsBcastPkts,	
                       pPort_cntrs.ifOutOctets, pPort_cntrs.dot3StatsSingleCollisionFrames,
                	   pPort_cntrs.dot3StatsMultipleCollisionFrames, pPort_cntrs.dot3StatsDeferredTransmissions,
                	   pPort_cntrs.dot3StatsLateCollisions, pPort_cntrs.etherStatsCollisions,
                	   pPort_cntrs.dot3StatsExcessiveCollisions, pPort_cntrs.dot3OutPauseFrames,
                	   pPort_cntrs.dot1dBasePortDelayExceededDiscards, pPort_cntrs.dot1dTpPortInDiscards,
                	   pPort_cntrs.ifOutUcastPkts, pPort_cntrs.ifOutMulticastPkts,
                	   pPort_cntrs.ifOutBrocastPkts, pPort_cntrs.outOampduPkts,
                	   pPort_cntrs.inOampduPkts, pPort_cntrs.pktgenPkts);
			/* 清零mib统计 */	   
                retVal = rtk_stat_port_reset(port);
                mutex_unlock(&acl_cb->lock);
            }
            else
            {
                printk("rtk port %d all stat get return %d\n", port, retVal);
            }
            break;
            
        case RTK_PORT_SPEED_STATUS_GET:

            if (copy_from_user(&port, (int __user *)arg, sizeof(int)))
            {
                return -EFAULT;
            }

            /* rtk_port_phyStatus_get只能查询8个phy口，rtl8370_getAsicPortStatus可以查询8个phy口+2个RGMII */
            //retVal = rtk_port_phy_status_get(port, &pLinkStatus, &pSpeed, &pDuplex);
            mutex_lock(&acl_cb->lock);
            retVal = rtl8370_getAsicPortStatus(port, (rtl8370_port_status_t *)&pSpeed);
            mutex_unlock(&acl_cb->lock);
            put_user(pSpeed, (unsigned int __user *)arg);
            break;
            
        case RTK_PORT_SPEED_ABILITY_SET:
            if (copy_from_user(&stPortConf, (rtk_port_ability_conf_t *)arg, sizeof(rtk_port_ability_conf_t)))
            {
                return -EFAULT;
            }
            mutex_lock(&acl_cb->lock);
            /* 设置1000M全双工必须开启协商，否则返回:RT_ERR_INPUT */
            if (1 == stPortConf.phyability.AutoNegotiation)
            {
                retVal = rtk_port_phyAutoNegoAbility_set(stPortConf.port, &stPortConf.phyability);
            }
            else
            {
                retVal = rtk_port_phyForceModeAbility_set(stPortConf.port, &stPortConf.phyability);
            }
            mutex_unlock(&acl_cb->lock);
            break;
            
        case RTK_SET_WORK_MODE:

            if (copy_from_user(&stPhyAbility, (rtk_port_phy_ability_t *)arg, sizeof(rtk_port_phy_ability_t)))
            {
                return -EFAULT;
            }
            mutex_lock(&acl_cb->lock);
            retVal = rtk8370m_set_slotport_workmode(&stPhyAbility);
            mutex_unlock(&acl_cb->lock);
            break;
            
    case RTK_PORT_GET_MIB:
            if ( copy_from_user(&stPortMib, (rtk_port_mib_t *)arg, sizeof(rtk_port_mib_t)) )
            {
                printk("%s: line:%d retVal:0x%x port:%d sizeof:%d\n", __func__, __LINE__, retVal, stPortMib.port, sizeof(rtk_port_mib_t) );
                return -EFAULT;
            }

            //retVal = rtk_stat_port_getAll(stPortMib.port, &pPort_cntrs);
            mutex_lock(&acl_cb->lock);
            retVal = rtk_stat_port_get(stPortMib.port,STAT_IfInOctets,&pPort_cntrs.ifInOctets);
            if (RT_ERR_OK == retVal)
            {
                retVal = rtk_stat_port_get(stPortMib.port,STAT_IfOutOctets,&pPort_cntrs.ifOutOctets);
            } 
            //除收发报文统计 还要读取主要mib信息
            if ((stPortMib.mib_reset&0x02) != 0)
            {
                if (RT_ERR_OK == retVal)
                {
                    retVal = rtk_stat_port_get(stPortMib.port,STAT_Dot3StatsFCSErrors,&pPort_cntrs.dot3StatsFCSErrors);
                }
                
                if (RT_ERR_OK == retVal)
                {
                    retVal = rtk_stat_port_get(stPortMib.port,STAT_Dot3StatsSymbolErrors,&pPort_cntrs.dot3StatsSymbolErrors);
                }  

                if (RT_ERR_OK == retVal)
                {
                    retVal = rtk_stat_port_get(stPortMib.port,STAT_Dot3InPauseFrames,&pPort_cntrs.dot3InPauseFrames);
                }         

                if (RT_ERR_OK == retVal)
                {
                    retVal = rtk_stat_port_get(stPortMib.port,STAT_Dot3OutPauseFrames,&pPort_cntrs.dot3OutPauseFrames);
                } 
            }
            //是否清零mib
            if (stPortMib.mib_reset&0x01)
            {
                rtk_stat_port_reset(stPortMib.port);
            }
        
            if (RT_ERR_OK == retVal)
            {
                stPortMib.portcntr.ifInOctets            = (uint32)pPort_cntrs.ifInOctets;
                stPortMib.portcntr.ifOutOctets           = (uint32)pPort_cntrs.ifOutOctets;
                if ((stPortMib.mib_reset&0x02) != 0)
                {
                    stPortMib.portcntr.dot3StatsFCSErrors    = pPort_cntrs.dot3StatsFCSErrors;
                    stPortMib.portcntr.dot3StatsSymbolErrors = pPort_cntrs.dot3StatsSymbolErrors;
                    stPortMib.portcntr.dot3InPauseFrames     = pPort_cntrs.dot3InPauseFrames;            
                    stPortMib.portcntr.dot3OutPauseFrames    = pPort_cntrs.dot3OutPauseFrames;
                }
                else
                {
                    stPortMib.portcntr.dot3StatsFCSErrors    = 0;
                    stPortMib.portcntr.dot3StatsSymbolErrors = 0;
                    stPortMib.portcntr.dot3InPauseFrames     = 0;            
                    stPortMib.portcntr.dot3OutPauseFrames    = 0;
                }
                
                if ( copy_to_user(argp, (void *)&stPortMib, sizeof(rtk_port_mib_t)) )
                {
                    printk("%s: line:%d retVal:0x%x port:%d\n", __func__, __LINE__, retVal, stPortMib.port);
                }
            }
            mutex_unlock(&acl_cb->lock);
            break;

        case RTK_READ_REGISTER:
		/* copy  data from user */
            if( copy_from_user(&param, (struct reg_param_s __user *)arg, 
                           sizeof(struct reg_param_s)) )
            {
                printk(KERN_ERR "%s: copy param from user failed.\n", __func__);
                return -EFAULT;
            }
            mutex_lock(&acl_cb->lock);
            /* read register */
            simple_phy_read(param.reg, &param.value);
            mutex_unlock(&acl_cb->lock);
        /*copy data to user */
            if( copy_to_user((struct reg_param_s __user *)arg, &param, 
            	              sizeof(struct reg_param_s)))
            {
                printk(KERN_ERR "%s: copy param to user failed.\n", __func__);
                return -EFAULT;
            }
            break;
            
        case RTK_WRITE_REGISTER:
		/* copy  data from user */
            if( copy_from_user(&param, (struct reg_param_s __user *)arg, 
            	               sizeof(struct reg_param_s)) )
            {
                   printk(KERN_ERR "%s: copy param from user failed.\n", __func__);
                return -EFAULT;
            }

            /* write register */
            mutex_lock(&acl_cb->lock);
            simple_phy_write(param.reg, param.value);
            mutex_unlock(&acl_cb->lock);		
            break; 
            
        default:
            return -ENOIOCTLCMD;
	}

        if (retVal != RT_ERR_OK)
        {
            printk(KERN_ERR "%s: failed:0x%x req:0x%x\n", __func__, retVal, cmd);
        }

        return retVal;
}


struct file_operations rtk8370m_fops =
{
	owner:		THIS_MODULE,
	unlocked_ioctl:		rtk8370_ioctl,
	open:		rtk8370m_open,
	release:	rtk8370m_release,
};
#endif

static int __init mii_phy_init(void)
{
    unsigned int data = 0;
    unsigned int retVal;
    u16 phy_val;
    int i;
    
#if defined(PRODUCT_MTG2500MAIN)
    int r = 0,res;
    back_board_type = back_board_id;
#endif
    gpiobase = SUNXI_PIO_BASE;
    memset(reg_save, 0xff, sizeof(reg_save));
    
    phy_val = geth_phy_read(4, 0x130f) & 0xffff;
    printf(KERN_WARNING "phy 8370 reg 0x%x val 0x%x\n", 0x130f, phy_val);

    /*关闭板间通信的phy口*/
    for(i=0; i<=7; i++)
    {
        rtk8370_set_phy_powerdown(i, 1);
    }
    
    rtl8370_setAsicPortEnableAll(DISABLED);
    rtl8370_setAsicPortEnableAll(DISABLED);
    rtl8370_getAsicPortEnableAll(&data);
    //printf("disable getAsicPortEnableAll:0x%x\n", data);    
    
    /*after reset, switch need to delay 1 ms
        if not, SMI may send out unknown data
    */
    udelay(1000);
    
    retVal = rtk_switch_init();
    if (retVal  != RT_ERR_OK)
    {
         return retVal;
    }
    
    /* 1) 隔离接口板与外网 */
    //rtk8370_isolation_cfg();
    //rtk8370_print_isolation_cfg();
    
    test_smi_signal_and_wait();
    
    /* tom: for test */
    //smi_write(0x13a0, 0x123);
    data = geth_phy_read(0, 0x2022);
    //printf("debug,reg PHY ID value=0x%x\n", data);
    
    /* led enable */
   // init_and_enable_leds();
    
    /* force cpu 1000M mode */
    // bit13 要为0 6282 page 579 
    //MV_REG_WRITE(0x7243C, 0x00a4060f);//rnii0 ge1 1000m
    
    /* force 8370M 1000M node */
    set_ext_mode();
    
    init_ext_interface();

    ///-
    /* 将板间通信的接口固定设置为1000M全双工，禁止流控*/
    set_phy_mode();
    retVal =  rtk_qos_cfg();
    if( retVal != RT_ERR_OK )
    {
        printk(KERN_ERR"rtk_qos_cfg failed !!! .\n");
    }	
    
#if defined(PRODUCT_MTG2500MAIN)
    if((back_board_type == BOARD_MTG3000) || (back_board_type == BOARD_MTG2000) ||(back_board_type == BOARD_MTG3000C))
    {  
        rtk8370_hardware_init();
        //rtk8370_isolation_cfg();
        rtk8370_isolation_cfg_normal();
        rtk8370_print_isolation_cfg(); 
        
        retVal = rtk8370_auto_learning_cfg();
        if( retVal != RT_ERR_OK )
        {	
        	printk(KERN_ERR "RTK8370M config auto learning failed.\n");
        }

        /* 设置设置业务口与网管口: 为1000M/100M全双工/自协商能力 */
        rtk8370_set_ge_autoneg();                  
    }     
#endif

#if defined(PRODUCT_SBCMAIN) || defined(PRODUCT_MTG2500MAIN)
    rtk_cpu_enable_set(ENABLED);
    rtk_cpu_tagPort_set(8, CPU_INSERT_TO_ALL);
#endif
#if defined(PRODUCT_UC200)
    {
        rtk_portmask_t mbrmsk, untagmask;
        rtk_vlan_init();

        mbrmsk.bits[0] = 0x101;
        untagmask.bits[0] = 0x1;
        if(RT_ERR_OK != rtk_vlan_set(1, mbrmsk, untagmask, 0))
        {
            printk(KERN_ERR "%s %d\n", __FUNCTION__, __LINE__);
        }
        mbrmsk.bits[0] = 0x17e;
        untagmask.bits[0] = 0x7e;
        if(RT_ERR_OK != rtk_vlan_set(2, mbrmsk, untagmask, 0))
        {
            printk(KERN_ERR "%s %d\n", __FUNCTION__, __LINE__);
        }

        rtk_vlan_portPvid_set(0, 1, 0);
        rtk_vlan_portPvid_set(1, 2, 0);

        //rtk_vlan_portAcceptFrameType_set(0, ACCEPT_FRAME_TYPE_UNTAG_ONLY);
        //rtk_vlan_portAcceptFrameType_set(1, ACCEPT_FRAME_TYPE_UNTAG_ONLY);
        //rtk_vlan_portAcceptFrameType_set(8, ACCEPT_FRAME_TYPE_TAG_ONLY);

        //rtk_vlan_tagMode_set(8, VLAN_TAG_MODE_KEEP_FORMAT);
        
        /*禁止RMII口的mac地址学习功能。如果开启了rmii口的学习功能，当不同的vlan
          接口设置成桥模式时，一个vlan中的广播从rmii发送出来后，会被linux的桥
          又发回去，这时rmii口会学习到不正确的源mac，如果再次向改来源主机发送
          报文，会因为端口记录的源mac和报文的目的相同产生冲突，导致报文丢弃*/
        rtl8370_setAsicReg(RTL8370_REG_LUT_PORT8_LEARN_LIMITNO, 0);
    }
#endif

    // 使能所有网口 前面被powerdowm的不会工作
    rtl8370_setAsicPortEnableAll(ENABLED);
    rtl8370_setAsicPortEnableAll(ENABLED);
    rtl8370_getAsicPortEnableAll(&data);
    printk(KERN_ERR "Enable getAsicPortEnableAll:0x%x\n", data);

    /* ACL配置为8370核心功能 */
    retVal = rtk8370_acl_cfg();
    if( retVal != RT_ERR_OK )
    {	
    	printk(KERN_ERR "RTK8370M config acl failed !!! .\n");
    }

#if defined(PRODUCT_UC200)
    /*uc200固定开启板间通信的phy口*/
    for(i=0; i<=7; i++)
    {
        rtk8370_set_phy_powerdown(i, 0);
    }
#endif
    
    /* 设置GE1/GE0 LED工作模式，同时修复GE0黄灯常亮 */
    init_leds();
    proc_create("gpio_test", 0, NULL, &gpio_test_fops);
    proc_create("rtl_reset", 0, NULL, &rtl_reset_fops);
    proc_create("rtl_reg_save", 0, NULL, &rtl_reg_save_fops);

#if defined(PRODUCT_MTG2500MAIN)
    r = register_chrdev(rtk8370m_major, RTL8370M_DEVNAME,
		&rtk8370m_fops);
    if (r < 0) {
        printk(KERN_ERR NAME ": unable to register character device\n");
        return r;
    }
    
        /* 创建节点 */
    rtk_dev_class = class_create(THIS_MODULE, "rtk8370");
    
    if (IS_ERR(rtk_dev_class))
    {
        printk("ERROR: Create Dev Class Fail.\r\n");
        return -1;
    }
    rtk_device = device_create(rtk_dev_class, NULL, MKDEV(rtk8370m_major, 0), NULL, "rtk8370");
    if(IS_ERR(rtk_device))
    {
        printk("ERROR: Create Device Fail.\r\n");
        return -1;
    }
#endif

    return 0;
}

static void __exit mii_phy_exit(void)
{

}

module_init(mii_phy_init);
module_exit(mii_phy_exit);
MODULE_LICENSE("GPL");

