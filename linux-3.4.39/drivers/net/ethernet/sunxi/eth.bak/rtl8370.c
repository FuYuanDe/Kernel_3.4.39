#include <linux/clk.h>
#include <linux/mii.h>
#include <linux/gpio.h>
#include <linux/crc32.h>
#include <linux/skbuff.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/interrupt.h>
#include <linux/dma-mapping.h>
#include <linux/platform_device.h>
#include <linux/pinctrl/consumer.h>
#include <linux/pinctrl/pinctrl.h>
#include <linux/crypto.h>
#include <linux/err.h>
#include <linux/netdevice.h>
#include <linux/proc_fs.h>

#include "rtk_types.h"
#include "rtk_error.h"
#include "rtl8370.h"
#include "rtl8370_reg.h"
#include "rtl8370_asicdrv.h"
#include "rtl8370_asicdrv_phy.h"
#include "rtl8370_asicdrv_port.h"

#include "smi.h"

#define RTL8370_REGBITLENGTH               16
#define RTL8370_REGDATAMAX                 0xFFFF

#define RTL8370_VIDMAX                     0xFFF
#define RTL8370_EVIDMAX                    0x1FFF
#define RTL8370_CVLANMCNO                  32
#define RTL8370_CVIDXMAX                   (RTL8370_CVLANMCNO-1)

#define RTL8370_PRIMAX                     7

#define RTL8370_PRIDECMAX                  0xFF

#define RTL8370_PORTNO                     16   
#define RTL8370_PORTIDMAX                  (RTL8370_PORTNO-1)
#define RTL8370_PMSKMAX                    ((1<<(RTL8370_PORTNO))-1) 
#define RTL8370_PORTMASK                   0xFFFF

#define RTL8370_SVIDXNO                    64
#define RTL8370_SVIDXMAX                   (RTL8370_SVIDXNO-1)
#define RTL8370_MSTIMAX                    15  

#define RTL8370_METERNO                    64
#define RTL8370_METERMAX                   (RTL8370_METERNO-1)

#define RTL8370_QUEUENO                    8
#define RTL8370_QIDMAX                     (RTL8370_QUEUENO-1)       


#define RTL8370_PHY_BUSY_CHECK_COUNTER     1000    
#define RTL8370_PHYNO                      8 
#define RTL8370_PHYIDMAX                  (RTL8370_PHYNO-1)

#define RTL8370_QOS_GRANULARTY_MAX         0x1FFFF
#define RTL8370_QOS_GRANULARTY_LSB_MASK    0xFFFF
#define RTL8370_QOS_GRANULARTY_LSB_OFFSET  0
#define RTL8370_QOS_GRANULARTY_MSB_MASK    0x10000
#define RTL8370_QOS_GRANULARTY_MSB_OFFSET  16

#define RTL8370_QOS_GRANULARTY_UNIT_KBPS   8

#define RTL8370_QOS_RATE_INPUT_MAX         (0x1FFFF * 8)
#define RTL8370_QOS_RATE_INPUT_MIN         8

#define RTL8370_QUEUE_MASK                 0xFF

#define RTL8370_EFIDMAX                    0x7
#define RTL8370_FIDMAX                     0xFFF

/* the above macro is generated by genDotH */
#define RTL8370_VALID_REG_NO               3236

#define RTL8370_PHY_INTERNALNOMAX	    0x7
#define RTL8370_PHY_REGNOMAX		    0x1F
#define RTL8370_PHY_EXTERNALMAX	    0x7

#define	RTL8370_PHY_BASE   	        0x2000
#define	RTL8370_PHY_EXT_BASE   	    0xA000

#define	RTL8370_PHY_OFFSET	            5
#define	RTL8370_PHY_EXT_OFFSET  	    9
#define RTL8370_PHY_EXTLED_OFFSET  	8

#define RTK_INDRECT_ACCESS_CRTL                     0x1f00
#define RTK_INDRECT_ACCESS_STATUS                   0x1f01
#define RTK_INDRECT_ACCESS_ADDRESS                  0x1f02
#define RTK_INDRECT_ACCESS_WRITE_DATA               0x1f03
#define RTK_INDRECT_ACCESS_READ_DATA                0x1f04
#define RTK_INDRECT_ACCESS_DELAY                    0x1f80
#define RTK_INDRECT_ACCESS_BURST                    0x1f81
#define RTK_RW_MASK                                 0x2
#define RTK_CMD_MASK                                0x1
#define RTK_PHY_BUSY_OFFSET                         2
#define RTK_PHY_ID_MAX                             (RTK_MAX_NUM_OF_PORT-3)
#define RTK_PORT_ID_MAX                             (RTK_MAX_NUM_OF_PORT-1)
#define RTK_MAX_PORT_MASK                           0x3FF

#define RTK_MAX_NUM_OF_PORT                         10

#define RTK_MAX_NUM_OF_LEARN_LIMIT                  0x2040

#define RTL8370_LUT_LEARNLIMITMAX   0x2040

#define    RTL8370_LUT_PORT_LEARN_LIMITNO_BASE    RTL8370_REG_LUT_PORT0_LEARN_LIMITNO
#define    RTL8370_LUT_PORT_LEARN_LIMITNO_REG(port)    (RTL8370_LUT_PORT_LEARN_LIMITNO_BASE + port)

#define RTK_TOTAL_NUM_OF_WORD_FOR_1BIT_PORT_LIST    1

#define RTL8370_LEDGROUPMAX					2	
#define RTL8370_LEDGROUPMASK               0x7
#define RTL8370_LED_FORCE_MODE_BASE        RTL8370_REG_CPU_FORCE_LED0_CFG0
#define RTL8370_LED_FORCE_CTRL             RTL8370_REG_CPU_FORCE_LED_CFG
#define RTL8370_LEDPORTMAX				   8

/* port num */
#define PORT0                                       0
#define PORT1                                       1
#define PORT2                                       2
#define PORT3                                       3
#define PORT4                                       4
#define PORT5                                       5
#define PORT6                                       6
#define PORT7                                       7
#define PORT8                                       8
#define PORT9                                       9

#define RTK_EXT_0                                   0
#define RTK_EXT_1                                   1

#define    RTL8370_EXTNO       2

#define RTL8370_MIB_PORT_OFFSET    0x50
#define RTL8370_MIB_LEARNENTRYDISCARD_OFFSET    0x500

#define    RTL8370_MIB_CTRL_REG    RTL8370_REG_MIB_CTRL0
#define    RTL8370_MIB_COUNTER_BASE_REG    RTL8370_REG_MIB_COUNTER0

#define    RTL8370_PORT_ISOLATION_PORT_MASK_BASE    RTL8370_REG_PORT_ISOLATION_PORT0_MASK
#define    RTL8370_PORT_ISOLATION_PORT_MASK_REG(port)    (RTL8370_PORT_ISOLATION_PORT_MASK_BASE + port)

#define PHY_CONTROL_REG                             0
#define PHY_STATUS_REG                              1
#define PHY_AN_ADVERTISEMENT_REG                    4
#define PHY_AN_LINKPARTNER_REG                      5
#define PHY_1000_BASET_CONTROL_REG                  9
#define PHY_1000_BASET_STATUS_REG                   10
#define PHY_RESOLVED_REG                            17
#define PHY_POWERSAVING_REG                         21
#define PHY_POWERSAVING_OFFSET                      12
#define PHY_POWERSAVING_MASK                        0x1000
#define PHY_PAGE_ADDRESS                            31

typedef int32_t                   rtk_api_ret_t;
typedef int32_t                   ret_t;
typedef uint32_t  rtk_port_t;        /* port is type */

typedef enum rtk_enable_e
{
    DISABLED = 0,
    ENABLED,
    RTK_ENABLE_END
} rtk_enable_t;

typedef struct rtk_portmask_s
{
    uint32  bits[RTK_TOTAL_NUM_OF_WORD_FOR_1BIT_PORT_LIST];
} rtk_portmask_t;

typedef struct  rtk_port_mac_ability_s
{
    uint32 forcemode;
    uint32 speed;
    uint32 duplex;
    uint32 link;
    uint32 nway;
    uint32 txpause;
    uint32 rxpause;
    uint32 lpi100;
    uint32 lpi1000;
}rtk_port_mac_ability_t;

typedef uint32  rtk_data_t;

typedef enum rtk_led_group_e
{
    LED_GROUP_0 = 0,
    LED_GROUP_1,
    LED_GROUP_2,
    LED_GROUP_END
}rtk_led_group_t;

typedef enum rtk_led_operation_e
{
    LED_OP_SCAN=0,
    LED_OP_PARALLEL,
    LED_OP_SERIAL,
    LED_OP_END,
}rtk_led_operation_t;

enum RTL8370_LEDSERACT{

    LEDSERACT_HIGH=0,         
    LEDSERACT_LOW,        
    LEDSERACT_MAX,
};

enum RTL8370_LEDSER{

    LEDSER_16G=0,         
    LEDSER_8G,        
    LEDSER_MAX,
};

enum RTL8370_LEDOP{

    LEDOP_SCAN0=0,         
    LEDOP_SCAN1,        
    LEDOP_PARALLEL,        
    LEDOP_SERIAL, 
    LEDOP_MAX,
};

typedef enum rtk_led_mode_e
{
    LED_MODE_0 = 0,
    LED_MODE_1,
    LED_MODE_2,
    LED_MODE_3,
    LED_MODE_END
}rtk_led_mode_t;

enum RTL8370_LEDFORCEMODE{

    LEDFORCEMODE_NORMAL=0,
    LEDFORCEMODE_BLINK,
    LEDFORCEMODE_OFF,
    LEDFORCEMODE_ON,
    LEDFORCEMODE_MAX,
};

typedef enum rtk_led_config_e
{
    LED_CONFIG_LEDOFF=0,
    LED_CONFIG_DUPCOL,
    LED_CONFIG_LINK_ACT,
    LED_CONFIG_SPD1000,
    LED_CONFIG_SPD100,
    LED_CONFIG_SPD10,
    LED_CONFIG_SPD1000ACT,
    LED_CONFIG_SPD100ACT,
    LED_CONFIG_SPD10ACT,
    LED_CONFIG_SPD10010ACT,
    LED_CONFIG_LOOPDETECT,
    LED_CONFIG_EEE,
    LED_CONFIG_LINKRX,
    LED_CONFIG_LINKTX,
    LED_CONFIG_MASTER,
    LED_CONFIG_ACT,
    LED_CONFIG_END,
}rtk_led_congig_t;

enum RTL8370_LEDCONF{

    LEDCONF_LEDOFF=0,         
    LEDCONF_DUPCOL,        
    LEDCONF_LINK_ACT,        
    LEDCONF_SPD1000,        
    LEDCONF_SPD100,        
    LEDCONF_SPD10,            
    LEDCONF_SPD1000ACT,    
    LEDCONF_SPD100ACT,    
    LEDCONF_SPD10ACT,        
    LEDCONF_SPD10010ACT,  
    LEDCONF_LOOPDETECT,            
    LEDCONF_EEE,            
    LEDCONF_LINKRX,        
    LEDCONF_LINKTX,        
    LEDCONF_MASTER,        
    LEDCONF_ACT,    
};

enum RTL8370_LEDBLINKRATE{

    LEDBLINKRATE_32MS=0,        
    LEDBLINKRATE_64MS,      
    LEDBLINKRATE_128MS,
    LEDBLINKRATE_256MS,
    LEDBLINKRATE_512MS,
    LEDBLINKRATE_1024MS,
    LEDBLINKRATE_48MS,
    LEDBLINKRATE_96MS,
    LEDBLINKRATE_MAX,

};

typedef enum rtk_mode_ext_e
{
    MODE_EXT_DISABLE = 0,
    MODE_EXT_RGMII,
    MODE_EXT_MII_MAC,
    MODE_EXT_MII_PHY,
    MODE_EXT_TMII_MAC,
    MODE_EXT_TMII_PHY,
    MODE_EXT_GMII,
    MODE_EXT_RGMII_33V,
    MODE_EXT_END
} rtk_mode_ext_t;

typedef enum rtk_port_linkStatus_e
{
    PORT_LINKDOWN = 0,
    PORT_LINKUP,
    PORT_LINKSTATUS_END
} rtk_port_linkStatus_t;

enum RTL8370_MIBCOUNTER{

	IfInOctets = 0,
	Dot3StatsFCSErrors = 1,
	Dot3StatsSymbolErrors = 2,
	Dot3InPauseFrames = 3,
	Dot3ControlInUnknownOpcodes = 4,		
	EtherStatsFragments = 5,
	EtherStatsJabbers = 6,
	IfInUcastPkts = 7,
	EtherStatsDropEvents = 8,
	EtherStatsOctets = 9,

	EtherStatsUnderSizePkts = 10,
	EtherOversizeStats = 11,
	EtherStatsPkts64Octets = 12,
	EtherStatsPkts65to127Octets = 13,
	EtherStatsPkts128to255Octets = 14,
	EtherStatsPkts256to511Octets = 15,
	EtherStatsPkts512to1023Octets = 16,
	EtherStatsPkts1024to1518Octets = 17,
	EtherStatsMulticastPkts = 18,
	EtherStatsBroadcastPkts = 19,
	
	IfOutOctets = 20,

	Dot3StatsSingleCollisionFrames = 21,
	Dot3StatMultipleCollisionFrames = 22,
	Dot3sDeferredTransmissions = 23,
	Dot3StatsLateCollisions = 24,
	EtherStatsCollisions = 25,
	Dot3StatsExcessiveCollisions = 26,
	Dot3OutPauseFrames = 27,
	Dot1dBasePortDelayExceededDiscards = 28,
	Dot1dTpPortInDiscards = 29,
	IfOutUcastPkts = 30,
	IfOutMulticastPkts = 31,
	IfOutBroadcastPkts = 32,
	OutOampduPkts = 33,
	InOampduPkts = 34,
	PktgenPkts = 35,
	/*Device only */	
    Dot1dTpLearnEntryDiscard = 36,
	RTL8370_MIBS_NUMBER,
	
};	

#define printf      printk

static uint32 bFixLed = 0;  /* 是否需要修复GE0黄灯常亮 */
static uint32 ulMaxDtuNum = 6; /* MTG2500最多有6块DTU2业务板 */
static uint32 slot_port[6] = { PORT6, PORT3, PORT2, PORT5, PORT4, PORT7 };
static void __iomem *gpiobase;

///-
static int test_flag = 0;

extern int rtk8370_acl_cfg(void);
extern void _rtl865x_gpio_set_direction(int pin, int dir);
extern void _rtl865x_setGpioDataBit(int pin, uint32 val);
extern void _rtl865x_getGpioDataBit(int pin, uint32 *ret);

/*
@func ret_t | rtl8370_setAsicLutLearnLimitNo | Set per-Port auto learning limit number
@parm uint32 | port | The port number
@parm uint32 | number | ASIC auto learning entries limit number
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@rvalue RT_ERR_PORT_ID | Invalid port number.
@rvalue RT_ERR_LIMITED_L2ENTRY_NUM | Invalid auto learning limit number
@common
    The API can set per-port ASIC auto learning limit number
*/
ret_t rtl8370_setAsicLutLearnLimitNo(uint32 port,uint32 number)
{
    if(port > RTL8370_PORTIDMAX)
        return RT_ERR_PORT_ID;

    if(number > RTL8370_LUT_LEARNLIMITMAX)
        return RT_ERR_LIMITED_L2ENTRY_NUM;

    return rtl8370_setAsicReg(RTL8370_LUT_PORT_LEARN_LIMITNO_REG(port), number);
}

const uint16 switch_init0_chipData0[][2] = {{0x133f,0x0030},{0x133e,0x000e},{0x221f,0x0000},{0x2215,0x1006},
                                     {0x221f,0x0005},{0x2200,0x00c6},{0x221f,0x0007},{0x221e,0x0048},
                                     {0x2215,0x6412},{0x2216,0x6412},{0x2217,0x6412},{0x2218,0x6412},
                                     {0x2219,0x6412},{0x221A,0x6412},{0x221f,0x0001},{0x220c,0xdbf0},
                                     {0x2209,0x2576},{0x2207,0x287E},{0x220A,0x68E5},{0x221D,0x3DA4},
                                     {0x221C,0xE7F7},{0x2214,0x7F52},{0x2218,0x7FCE},{0x2208,0x04B7},
                                     {0x2206,0x4072},{0x2210,0xF05E},{0x221B,0xB414},{0x221F,0x0003},
                                     {0x221A,0x06A6},{0x2210,0xF05E},{0x2213,0x06EB},{0x2212,0xF4D2},
                                     {0x220E,0xE120},{0x2200,0x7C00},{0x2202,0x5FD0},{0x220D,0x0207},
                                     {0x221f,0x0002},{0x2205,0x0978},{0x2202,0x8C01},{0x2207,0x3620},
                                     {0x221C,0x0001},{0x2203,0x0420},{0x2204,0x80C8},{0x133e,0x0ede},
                                     {0x221f,0x0002},{0x220c,0x0073},{0x220d,0xEB65},{0x220e,0x51d1},
                                     {0x220f,0x5dcb},{0x2210,0x3044},{0x2211,0x1800},{0x2212,0x7E00},
                                     {0x2213,0x0000},{0x133f,0x0010},{0x133e,0x0ffe},{0x207f,0x0002},
                                     {0x2074,0x3D22},{0x2075,0x2000},{0x2076,0x6040},{0x2077,0x0000},
                                     {0x2078,0x0f0a},{0x2079,0x50AB},{0x207a,0x0000},{0x207b,0x0f0f},
                                     {0x205f,0x0002},{0x2054,0xFF00},{0x2055,0x000A},{0x2056,0x000A},
                                     {0x2057,0x0005},{0x2058,0x0005},{0x2059,0x0000},{0x205A,0x0005},
                                     {0x205B,0x0005},{0x205C,0x0005},{0x209f,0x0002},{0x2094,0x00AA},
                                     {0x2095,0x00AA},{0x2096,0x00AA},{0x2097,0x00AA},{0x2098,0x0055},
                                     {0x2099,0x00AA},{0x209A,0x00AA},{0x209B,0x00AA},{0x1363,0x8354},
                                     {0x1270,0x3333},{0x1271,0x3333},{0x1272,0x3333},{0x1330,0x00DB},
                                     {0x1203,0xff00},{0x1200,0x7fc4},{0x121d,0x1006},{0x121e,0x03e8},
                                     {0x121f,0x02b3},{0x1220,0x028f},{0x1221,0x029b},{0x1222,0x0277},
                                     {0x1223,0x02b3},{0x1224,0x028f},{0x1225,0x029b},{0x1226,0x0277},
                                     {0x1227,0x00c0},{0x1228,0x00b4},{0x122f,0x00c0},{0x1230,0x00b4},
                                     {0x1229,0x0020},{0x122a,0x000c},{0x1231,0x0030},{0x1232,0x0024},
                                     {0x0219,0x0032},{0x0200,0x03e8},{0x0201,0x03e8},{0x0202,0x03e8},
                                     {0x0203,0x03e8},{0x0204,0x03e8},{0x0205,0x03e8},{0x0206,0x03e8},
                                     {0x0207,0x03e8},{0x0218,0x0032},{0x0208,0x029b},{0x0209,0x029b},
                                     {0x020a,0x029b},{0x020b,0x029b},{0x020c,0x029b},{0x020d,0x029b},
                                     {0x020e,0x029b},{0x020f,0x029b},{0x0210,0x029b},{0x0211,0x029b},
                                     {0x0212,0x029b},{0x0213,0x029b},{0x0214,0x029b},{0x0215,0x029b},
                                     {0x0216,0x029b},{0x0217,0x029b},{0x0900,0x0000},{0x0901,0x0000},
                                     {0x0902,0x0000},{0x0903,0x0000},{0x0865,0x3210},{0x087b,0x0000},
                                     {0x087c,0xff00},{0x087d,0x0000},{0x087e,0x0000},{0x0801,0x0100},
                                     {0x0802,0x0100},{0x1700,0x014C},{0x0301,0x00FF},{0x12AA,0x0096},
                                     {0x133f,0x0030},{0x133e,0x000e},{0x221f,0x0005},{0x2200,0x00C4},
                                     {0x221f,0x0000},{0x2210,0x05EF},{0x2204,0x05E1},{0x2200,0x1340},
                                     {0x133f,0x0010},{0x20A0,0x1940},{0x20C0,0x1940},{0x20E0,0x1940},
                                     {0xFFFF, 0xABCD}};

const uint16 switch_init0_chipData1[][2] = {{0x133f,0x0030},{0x133e,0x000e},{0x221f,0x0000},{0x2215,0x1006},
                                     {0x221f,0x0005},{0x2200,0x00c6},{0x221f,0x0007},{0x221e,0x0048},
                                     {0x2215,0x6412},{0x2216,0x6412},{0x2217,0x6412},{0x2218,0x6412},
                                     {0x2219,0x6412},{0x221A,0x6412},{0x221f,0x0001},{0x220c,0xdbf0},
                                     {0x2209,0x2576},{0x2207,0x287E},{0x220A,0x68E5},{0x221D,0x3DA4},
                                     {0x221C,0xE7F7},{0x2214,0x7F52},{0x2218,0x7FCE},{0x2208,0x04B7},
                                     {0x2206,0x4072},{0x2210,0xF05E},{0x221B,0xB414},{0x221F,0x0003},
                                     {0x221A,0x06A6},{0x2210,0xF05E},{0x2213,0x06EB},{0x2212,0xF4D2},
                                     {0x220E,0xE120},{0x2200,0x7C00},{0x2202,0x5FD0},{0x220D,0x0207},
                                     {0x221f,0x0002},{0x2205,0x0978},{0x2202,0x8C01},{0x2207,0x3620},
                                     {0x221C,0x0001},{0x2203,0x0420},{0x2204,0x80C8},{0x133e,0x0ede},
                                     {0x221f,0x0002},{0x220c,0x0073},{0x220d,0xEB65},{0x220e,0x51d1},
                                     {0x220f,0x5dcb},{0x2210,0x3044},{0x2211,0x1800},{0x2212,0x7E00},
                                     {0x2213,0x0000},{0x133f,0x0010},{0x133e,0x0ffe},{0x207f,0x0002},
                                     {0x2074,0x3D22},{0x2075,0x2000},{0x2076,0x6040},{0x2077,0x0000},
                                     {0x2078,0x0f0a},{0x2079,0x50AB},{0x207a,0x0000},{0x207b,0x0f0f},
                                     {0x205f,0x0002},{0x2054,0xFF00},{0x2055,0x000A},{0x2056,0x000A},
                                     {0x2057,0x0005},{0x2058,0x0005},{0x2059,0x0000},{0x205A,0x0005},
                                     {0x205B,0x0005},{0x205C,0x0005},{0x209f,0x0002},{0x2094,0x00AA},
                                     {0x2095,0x00AA},{0x2096,0x00AA},{0x2097,0x00AA},{0x2098,0x0055},
                                     {0x2099,0x00AA},{0x209A,0x00AA},{0x209B,0x00AA},{0x1363,0x8354},
                                     {0x1270,0x3333},{0x1271,0x3333},{0x1272,0x3333},{0x1330,0x00DB},
                                     {0x1203,0xff00},{0x1200,0x7fc4},{0x121d,0x1b06},{0x121e,0x07f0},
                                     {0x121f,0x0438},{0x1220,0x040f},{0x1221,0x040f},{0x1222,0x03eb},
                                     {0x1223,0x0438},{0x1224,0x040f},{0x1225,0x040f},{0x1226,0x03eb},
                                     {0x1227,0x0144},{0x1228,0x0138},{0x122f,0x0144},{0x1230,0x0138},
                                     {0x1229,0x0020},{0x122a,0x000c},{0x1231,0x0030},{0x1232,0x0024},
                                     {0x0219,0x0032},{0x0200,0x07d0},{0x0201,0x07d0},{0x0202,0x07d0},
                                     {0x0203,0x07d0},{0x0204,0x07d0},{0x0205,0x07d0},{0x0206,0x07d0},
                                     {0x0207,0x07d0},{0x0218,0x0032},{0x0208,0x0190},{0x0209,0x0190},
                                     {0x020a,0x0190},{0x020b,0x0190},{0x020c,0x0190},{0x020d,0x0190},
                                     {0x020e,0x0190},{0x020f,0x0190},{0x0210,0x0190},{0x0211,0x0190},
                                     {0x0212,0x0190},{0x0213,0x0190},{0x0214,0x0190},{0x0215,0x0190},
                                     {0x0216,0x0190},{0x0217,0x0190},{0x0900,0x0000},{0x0901,0x0000},
                                     {0x0902,0x0000},{0x0903,0x0000},{0x0865,0x3210},{0x087b,0x0000},
                                     {0x087c,0xff00},{0x087d,0x0000},{0x087e,0x0000},{0x0801,0x0100},
                                     {0x0802,0x0100},{0x1700,0x0125},{0x0301,0x00FF},{0x12AA,0x0096},
                                     {0x133f,0x0030},{0x133e,0x000e},{0x221f,0x0005},{0x2200,0x00C4},
                                     {0x221f,0x0000},{0x2210,0x05EF},{0x2204,0x05E1},{0x2200,0x1340},
                                     {0x133f,0x0010},{0xFFFF, 0xABCD}};


static rtk_api_ret_t _rtk_switch_init0(void)
{
    rtk_api_ret_t retVal;
    uint32 index,regData;
    uint32 busyFlag,cnt;

    if ((retVal = rtl8370_setAsicReg(0x13C2,0x0249))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_getAsicRegBits(0x1302, 0x7,&regData))!=RT_ERR_OK)
        return retVal;

    index = 0;
    switch(regData)
    {
    case 0x0000:
        while (switch_init0_chipData0[index][0] != 0xFFFF && switch_init0_chipData0[index][1] != 0xABCD)
        {
            if ((switch_init0_chipData0[index][0]&0xF000)==0x2000)
            {
                cnt = 0;
                busyFlag = 1;
                while (busyFlag&&cnt<5)
                {
                    cnt++;
                    if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                        return retVal;
                }
                if (5 == cnt)
                    return RT_ERR_BUSYWAIT_TIMEOUT;

                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32)switch_init0_chipData0[index][1])) !=  RT_ERR_OK)
                    return retVal;
                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32)switch_init0_chipData0[index][0])) !=  RT_ERR_OK)
                    return retVal;
                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                    return retVal;
            }
            else
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32) switch_init0_chipData0[index][0],(uint32) switch_init0_chipData0[index][1]))
                    return RT_ERR_FAILED;
            }
            index ++;
        }
    case 0x0001:
        while (switch_init0_chipData1[index][0] != 0xFFFF && switch_init0_chipData1[index][1] != 0xABCD)
        {
            if ((switch_init0_chipData1[index][0]&0xF000)==0x2000)
            {
                cnt = 0;
                busyFlag = 1;
                while (busyFlag&&cnt<5)
                {
                    cnt++;
                    if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                        return retVal;
                }
                if (5 == cnt)
                    return RT_ERR_BUSYWAIT_TIMEOUT;

                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32) switch_init0_chipData1[index][1])) !=  RT_ERR_OK)
                    return retVal;
                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32) switch_init0_chipData1[index][0])) !=  RT_ERR_OK)
                    return retVal;
                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                    return retVal;
            }
            else
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32) switch_init0_chipData1[index][0],(uint32) switch_init0_chipData1[index][1]))
                    return RT_ERR_FAILED;
            }
            index ++;
        }

        if (RT_ERR_OK != rtl8370_setAsicReg(0x1700,0x135))
            return RT_ERR_FAILED;
        break;
    case 0x0002:
        while (switch_init0_chipData1[index][0] != 0xFFFF && switch_init0_chipData1[index][1] != 0xABCD)
        {
            if ((switch_init0_chipData1[index][0]&0xF000)==0x2000)
            {
                cnt = 0;
                busyFlag = 1;
                while (busyFlag&&cnt<5)
                {
                    cnt++;
                    if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                        return retVal;
                }
                if (5 == cnt)
                    return RT_ERR_BUSYWAIT_TIMEOUT;

                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32) switch_init0_chipData1[index][1])) !=  RT_ERR_OK)
                    return retVal;
                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32) switch_init0_chipData1[index][0])) !=  RT_ERR_OK)
                    return retVal;
                if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                    return retVal;
            }
            else
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32) switch_init0_chipData1[index][0],(uint32) switch_init0_chipData1[index][1]))
                    return RT_ERR_FAILED;
            }
            index ++;
        }

        if (RT_ERR_OK != rtl8370_setAsicReg(0x1700,0x135))
            return RT_ERR_FAILED;
        break;
    default:
        return RT_ERR_FAILED;
    }

    if ((retVal = rtl8370_setAsicReg(RTL8370_REG_LED_ACTIVE_LOW_CFG0, 0x6677))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_setAsicReg(RTL8370_REG_LED_ACTIVE_LOW_CFG1, 0x7406))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_getAsicReg(RTL8370_REG_MISCELLANEOUS_CONFIGURE0,&regData))!=RT_ERR_OK)
        return retVal;

    if (regData & RTL8370_EFUSE_EN_MASK)
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT3_LED_ACTIVE_LOW_OFFSET+2, 0))!=RT_ERR_OK)
            return retVal;
    }
    else
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT3_LED_ACTIVE_LOW_OFFSET+2, 1))!=RT_ERR_OK)
            return retVal;
    }

    if (regData & RTL8370_AUTOLOAD_EN_MASK)
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT2_LED_ACTIVE_LOW_OFFSET, 0))!=RT_ERR_OK)
            return retVal;
    }
    else
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT2_LED_ACTIVE_LOW_OFFSET, 1))!=RT_ERR_OK)
            return retVal;
    }

    if (regData & RTL8370_DW8051_EN_MASK)
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT2_LED_ACTIVE_LOW_OFFSET+2, 0))!=RT_ERR_OK)
            return retVal;
    }
    else
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT2_LED_ACTIVE_LOW_OFFSET+2, 1))!=RT_ERR_OK)
            return retVal;
    }

    if ((retVal = rtl8370_getAsicReg(RTL8370_REG_MISCELLANEOUS_CONFIGURE1,&regData))!=RT_ERR_OK)
        return retVal;

    if (regData & RTL8370_EEPROM_ADDRESS_16B_MASK)
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG1, RTL8370_PORT4_LED_ACTIVE_LOW_OFFSET, 1))!=RT_ERR_OK)
            return retVal;
    }
    else
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG1, RTL8370_PORT4_LED_ACTIVE_LOW_OFFSET, 0))!=RT_ERR_OK)
            return retVal;
    }

    if (regData & 0x1000)
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT3_LED_ACTIVE_LOW_OFFSET, 1))!=RT_ERR_OK)
            return retVal;
    }
    else
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT3_LED_ACTIVE_LOW_OFFSET, 0))!=RT_ERR_OK)
            return retVal;
    }

    if ((retVal = rtl8370_getAsicReg(RTL8370_REG_DW8051_RDY,&regData))!=RT_ERR_OK)
        return retVal;

    if (regData & 0x10)
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG1, RTL8370_PORT5_LED_ACTIVE_LOW_OFFSET, 1))!=RT_ERR_OK)
            return retVal;
    }
    else
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG1, RTL8370_PORT5_LED_ACTIVE_LOW_OFFSET, 0))!=RT_ERR_OK)
            return retVal;
    }

    if (regData & 0x20)
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT1_LED_ACTIVE_LOW_OFFSET+2, 1))!=RT_ERR_OK)
            return retVal;
    }
    else
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT1_LED_ACTIVE_LOW_OFFSET+2, 0))!=RT_ERR_OK)
            return retVal;
    }

    if (regData & 0x40)
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT1_LED_ACTIVE_LOW_OFFSET, 1))!=RT_ERR_OK)
            return retVal;
    }
    else
    {
        if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_ACTIVE_LOW_CFG0, RTL8370_PORT1_LED_ACTIVE_LOW_OFFSET, 0))!=RT_ERR_OK)
            return retVal;
    }

    if ((retVal = rtl8370_setAsicReg(RTL8370_REG_PARA_LED_IO_EN1,0))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_setAsicReg(RTL8370_REG_PARA_LED_IO_EN2,0))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_setAsicReg(RTL8370_REG_SCAN0_LED_IO_EN,0))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_setAsicReg(RTL8370_REG_SCAN1_LED_IO_EN,0))!=RT_ERR_OK)
        return retVal;

    /*Set learn limit to 8256*/
    for (index= 0; index <= RTK_MAX_NUM_OF_PORT; index++)
    {
        if ((retVal = rtl8370_setAsicLutLearnLimitNo(index,RTK_MAX_NUM_OF_LEARN_LIMIT))!=RT_ERR_OK)
            return retVal;
    }



    return RT_ERR_OK;
}

const uint16 switch_init1_chipData0[][2] = {{0x1B24, 0x0000},{0x1B25, 0x0000},{0x1B26, 0x0000},{0x1B27, 0x0000},
                                    {0x207F, 0x0007},{0x207E, 0x000B},{0x2076, 0x1A00},{0x207F, 0x0000},
                                    {0x205F, 0x0007},{0x205E, 0x000A},{0x2059, 0x0000},{0x205A, 0x0000},
                                    {0x205B, 0x0000},{0x205C, 0x0000},{0x205E, 0x000B},{0x2055, 0x0500},
                                    {0x2056, 0x0000},{0x2057, 0x0000},{0x2058, 0x0000},{0x205F, 0x0000},
                                    {0x133F, 0x0030},{0x133E, 0x000E},{0x221F, 0x0005},{0x2201, 0x0700},
                                    {0x2205, 0x8B82},{0x2206, 0x05CB},{0x221F, 0x0007},{0x221E, 0x0008},
                                    {0x2219, 0x80C2},{0x221A, 0x0938},{0x221F, 0x0000},{0x221F, 0x0003},
                                    {0x2212, 0xC4D2},{0x220D, 0x0207},{0x221F, 0x0001},{0x2207, 0x267E},
                                    {0x221C, 0xE5F7},{0x221B, 0x0424},{0x221F, 0x0007},{0x221E, 0x0040},
                                    {0x2218, 0x0000},{0x221F, 0x0007},{0x221E, 0x002C},{0x2218, 0x008B},
                                    {0x221F, 0x0005},{0x2205, 0xFFF6},{0x2206, 0x0080},{0x2205, 0x8000},
                                    {0x2206, 0xF8E0},{0x2206, 0xE000},{0x2206, 0xE1E0},{0x2206, 0x01AC},
                                    {0x2206, 0x2408},{0x2206, 0xE08B},{0x2206, 0x84F7},{0x2206, 0x20E4},
                                    {0x2206, 0x8B84},{0x2206, 0xFC05},{0x2206, 0xF8FA},{0x2206, 0xEF69},
                                    {0x2206, 0xE08B},{0x2206, 0x86AC},{0x2206, 0x201A},{0x2206, 0xBF80},
                                    {0x2206, 0x59D0},{0x2206, 0x2402},{0x2206, 0x803D},{0x2206, 0xE0E0},
                                    {0x2206, 0xE4E1},{0x2206, 0xE0E5},{0x2206, 0x5806},{0x2206, 0x68C0},
                                    {0x2206, 0xD1D2},{0x2206, 0xE4E0},{0x2206, 0xE4E5},{0x2206, 0xE0E5},
                                    {0x2206, 0xEF96},{0x2206, 0xFEFC},{0x2206, 0x05FB},{0x2206, 0x0BFB},
                                    {0x2206, 0x58FF},{0x2206, 0x9E11},{0x2206, 0x06F0},{0x2206, 0x0C81},
                                    {0x2206, 0x8AE0},{0x2206, 0x0019},{0x2206, 0x1B89},{0x2206, 0xCFEB},
                                    {0x2206, 0x19EB},{0x2206, 0x19B0},{0x2206, 0xEFFF},{0x2206, 0x0BFF},
                                    {0x2206, 0x0425},{0x2206, 0x0807},{0x2206, 0x2640},{0x2206, 0x7227},
                                    {0x2206, 0x267E},{0x2206, 0x2804},{0x2206, 0xB729},{0x2206, 0x2576},
                                    {0x2206, 0x2A68},{0x2206, 0xE52B},{0x2206, 0xAD00},{0x2206, 0x2CDB},
                                    {0x2206, 0xF02D},{0x2206, 0x67BB},{0x2206, 0x2E7B},{0x2206, 0x0F2F},
                                    {0x2206, 0x7365},{0x2206, 0x31AC},{0x2206, 0xCC32},{0x2206, 0x2300},
                                    {0x2206, 0x332D},{0x2206, 0x1734},{0x2206, 0x7F52},{0x2206, 0x3510},
                                    {0x2206, 0x0036},{0x2206, 0x1000},{0x2206, 0x3710},{0x2206, 0x0038},
                                    {0x2206, 0x7FCE},{0x2206, 0x3CE5},{0x2206, 0xF73D},{0x2206, 0x3DA4},
                                    {0x2206, 0x6530},{0x2206, 0x3E67},{0x2206, 0x0053},{0x2206, 0x69D2},
                                    {0x2206, 0x0F6A},{0x2206, 0x012C},{0x2206, 0x6C2B},{0x2206, 0x136E},
                                    {0x2206, 0xE100},{0x2206, 0x6F12},{0x2206, 0xF771},{0x2206, 0x006B},
                                    {0x2206, 0x7306},{0x2206, 0xEB74},{0x2206, 0x94C7},{0x2206, 0x7698},
                                    {0x2206, 0x0A77},{0x2206, 0x5000},{0x2206, 0x788A},{0x2206, 0x1579},
                                    {0x2206, 0x7F6F},{0x2206, 0x7A06},{0x2206, 0xA600},{0x2205, 0x8B90},
                                    {0x2206, 0x8000},{0x2205, 0x8B92},{0x2206, 0x8000},{0x2205, 0x8B94},
                                    {0x2206, 0x8014},{0x2208, 0xFFFA},{0x2202, 0x3C65},{0x2205, 0xFFF6},
                                    {0x2206, 0x00F7},{0x221F, 0x0000},{0x221F, 0x0007},{0x221E, 0x0042},
                                    {0x2218, 0x0000},{0x221E, 0x002D},{0x2218, 0xF010},{0x221E, 0x0020},
                                    {0x2215, 0x0000},{0x221E, 0x0023},{0x2216, 0x8000},{0x221F, 0x0000},
                                    {0x133F, 0x0010},{0x133E, 0x0FFE},{0x1362, 0x0115},{0x1363, 0x0002},
                                    {0x1363, 0x0000},{0x1306, 0x000C},{0x1307, 0x000C},{0x1303, 0x0367},
                                    {0x1304, 0x7777},{0x1203, 0xFF00},{0x1200, 0x7FC4},{0x121D, 0x7D16},
                                    {0x121E, 0x03E8},{0x121F, 0x024E},{0x1220, 0x0230},{0x1221, 0x0244},
                                    {0x1222, 0x0226},{0x1223, 0x024E},{0x1224, 0x0230},{0x1225, 0x0244},
                                    {0x1226, 0x0226},{0x1227, 0x00C0},{0x1228, 0x00B4},{0x122F, 0x00C0},
                                    {0x1230, 0x00B4},{0x0208, 0x03E8},{0x0209, 0x03E8},{0x020A, 0x03E8},
                                    {0x020B, 0x03E8},{0x020C, 0x03E8},{0x020D, 0x03E8},{0x020E, 0x03E8},
                                    {0x020F, 0x03E8},{0x0210, 0x03E8},{0x0211, 0x03E8},{0x0212, 0x03E8},
                                    {0x0213, 0x03E8},{0x0214, 0x03E8},{0x0215, 0x03E8},{0x0216, 0x03E8},
                                    {0x0217, 0x03E8},{0x0865, 0x3210},{0x087B, 0x0000},{0x087C, 0xFF00},
                                    {0x087D, 0x0000},{0x087E, 0x0000},{0x0801, 0x0100},{0x0802, 0x0100},
                                    {0x0A20, 0x2040},{0x0A21, 0x2040},{0x0A22, 0x2040},{0x0A23, 0x2040},
                                    {0x0A24, 0x2040},{0x0A28, 0x2040},{0x0A29, 0x2040},{0x20A0, 0x1940},
                                    {0x20C0, 0x1940},{0x20E0, 0x1940},{0x130C, 0x0050},{0x1B03, 0x0876},
                                    {0xFFFF, 0xABCD}};

const uint16 switch_init1_chipData1[][2] = {{0x1B24, 0x0000},{0x1B25, 0x0000},{0x1B26, 0x0000},{0x1B27, 0x0000},
                                    {0x207F, 0x0007},{0x207E, 0x000B},{0x2076, 0x1A00},{0x207F, 0x0000},
                                    {0x205F, 0x0007},{0x205E, 0x000A},{0x2059, 0x0000},{0x205A, 0x0000},
                                    {0x205B, 0x0000},{0x205C, 0x0000},{0x205E, 0x000B},{0x2055, 0x0500},
                                    {0x2056, 0x0000},{0x2057, 0x0000},{0x2058, 0x0000},{0x205F, 0x0000},
                                    {0x133F, 0x0030},{0x133E, 0x000E},{0x221F, 0x0005},{0x2201, 0x0700},
                                    {0x2205, 0x8B82},{0x2206, 0x05CB},{0x221F, 0x0007},{0x221E, 0x0008},
                                    {0x2219, 0x80C2},{0x221A, 0x0938},{0x221F, 0x0000},{0x221F, 0x0003},
                                    {0x2212, 0xC4D2},{0x220D, 0x0207},{0x221F, 0x0001},{0x2207, 0x267E},
                                    {0x221C, 0xE5F7},{0x221B, 0x0424},{0x221F, 0x0007},{0x221E, 0x0040},
                                    {0x2218, 0x0000},{0x221F, 0x0007},{0x221E, 0x002C},{0x2218, 0x008B},
                                    {0x221F, 0x0005},{0x2205, 0xFFF6},{0x2206, 0x0080},{0x2205, 0x8000},
                                    {0x2206, 0xF8E0},{0x2206, 0xE000},{0x2206, 0xE1E0},{0x2206, 0x01AC},
                                    {0x2206, 0x2408},{0x2206, 0xE08B},{0x2206, 0x84F7},{0x2206, 0x20E4},
                                    {0x2206, 0x8B84},{0x2206, 0xFC05},{0x2206, 0xF8FA},{0x2206, 0xEF69},
                                    {0x2206, 0xE08B},{0x2206, 0x86AC},{0x2206, 0x201A},{0x2206, 0xBF80},
                                    {0x2206, 0x59D0},{0x2206, 0x2402},{0x2206, 0x803D},{0x2206, 0xE0E0},
                                    {0x2206, 0xE4E1},{0x2206, 0xE0E5},{0x2206, 0x5806},{0x2206, 0x68C0},
                                    {0x2206, 0xD1D2},{0x2206, 0xE4E0},{0x2206, 0xE4E5},{0x2206, 0xE0E5},
                                    {0x2206, 0xEF96},{0x2206, 0xFEFC},{0x2206, 0x05FB},{0x2206, 0x0BFB},
                                    {0x2206, 0x58FF},{0x2206, 0x9E11},{0x2206, 0x06F0},{0x2206, 0x0C81},
                                    {0x2206, 0x8AE0},{0x2206, 0x0019},{0x2206, 0x1B89},{0x2206, 0xCFEB},
                                    {0x2206, 0x19EB},{0x2206, 0x19B0},{0x2206, 0xEFFF},{0x2206, 0x0BFF},
                                    {0x2206, 0x0425},{0x2206, 0x0807},{0x2206, 0x2640},{0x2206, 0x7227},
                                    {0x2206, 0x267E},{0x2206, 0x2804},{0x2206, 0xB729},{0x2206, 0x2576},
                                    {0x2206, 0x2A68},{0x2206, 0xE52B},{0x2206, 0xAD00},{0x2206, 0x2CDB},
                                    {0x2206, 0xF02D},{0x2206, 0x67BB},{0x2206, 0x2E7B},{0x2206, 0x0F2F},
                                    {0x2206, 0x7365},{0x2206, 0x31AC},{0x2206, 0xCC32},{0x2206, 0x2300},
                                    {0x2206, 0x332D},{0x2206, 0x1734},{0x2206, 0x7F52},{0x2206, 0x3510},
                                    {0x2206, 0x0036},{0x2206, 0x1000},{0x2206, 0x3710},{0x2206, 0x0038},
                                    {0x2206, 0x7FCE},{0x2206, 0x3CE5},{0x2206, 0xF73D},{0x2206, 0x3DA4},
                                    {0x2206, 0x6530},{0x2206, 0x3E67},{0x2206, 0x0053},{0x2206, 0x69D2},
                                    {0x2206, 0x0F6A},{0x2206, 0x012C},{0x2206, 0x6C2B},{0x2206, 0x136E},
                                    {0x2206, 0xE100},{0x2206, 0x6F12},{0x2206, 0xF771},{0x2206, 0x006B},
                                    {0x2206, 0x7306},{0x2206, 0xEB74},{0x2206, 0x94C7},{0x2206, 0x7698},
                                    {0x2206, 0x0A77},{0x2206, 0x5000},{0x2206, 0x788A},{0x2206, 0x1579},
                                    {0x2206, 0x7F6F},{0x2206, 0x7A06},{0x2206, 0xA600},{0x2205, 0x8B90},
                                    {0x2206, 0x8000},{0x2205, 0x8B92},{0x2206, 0x8000},{0x2205, 0x8B94},
                                    {0x2206, 0x8014},{0x2208, 0xFFFA},{0x2202, 0x3C65},{0x2205, 0xFFF6},
                                    {0x2206, 0x00F7},{0x221F, 0x0000},{0x221F, 0x0007},{0x221E, 0x0042},
                                    {0x2218, 0x0000},{0x221E, 0x002D},{0x2218, 0xF010},{0x221E, 0x0020},
                                    {0x2215, 0x0000},{0x221E, 0x0023},{0x2216, 0x8000},{0x221F, 0x0000},
                                    {0x133F, 0x0010},{0x133E, 0x0FFE},{0x1362, 0x0115},{0x1363, 0x0002},
                                    {0x1363, 0x0000},{0x1306, 0x000C},{0x1307, 0x000C},{0x1303, 0x0367},
                                    {0x1304, 0x7777},{0x1203, 0xFF00},{0x1200, 0x7FC4},{0x0865, 0x3210},
                                    {0x087B, 0x0000},{0x087C, 0xFF00},{0x087D, 0x0000},{0x087E, 0x0000},
                                    {0x0801, 0x0100},{0x0802, 0x0100},{0x0A20, 0x2040},{0x0A21, 0x2040},
                                    {0x0A22, 0x2040},{0x0A23, 0x2040},{0x0A24, 0x2040},{0x0A25, 0x2040},
                                    {0x0A26, 0x2040},{0x0A27, 0x2040},{0x0A28, 0x2040},{0x0A29, 0x2040},
                                    {0x130C, 0x0050},{0x1B03, 0x0876},{0xFFFF, 0xABCD}};


static rtk_api_ret_t _rtk_switch_init1(void)
{
    rtk_api_ret_t retVal;
    uint32 index,regData;
#ifndef MDC_MDIO_OPERATION
    uint32 busyFlag,cnt;
#endif

    if ((retVal = rtl8370_setAsicReg(0x13C2,0x0249))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_getAsicRegBits(0x1302, 0x7,&regData))!=RT_ERR_OK)
        return retVal;

#ifdef MDC_MDIO_OPERATION
    index = 0;
    switch(regData)
    {
        case 0x0000:
            while (switch_init1_chipData0[index][0] != 0xFFFF && switch_init1_chipData0[index][1] != 0xABCD)
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init1_chipData0[index][0],(uint32)switch_init1_chipData0[index][1]))
                    return RT_ERR_FAILED;
                index ++;
            }
            break;
        case 0x0001:
            while (switch_init1_chipData1[index][0] != 0xFFFF && switch_init1_chipData1[index][1] != 0xABCD)
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init1_chipData1[index][0],(uint32)switch_init1_chipData1[index][1]))
                    return RT_ERR_FAILED;
                index ++;
            }
            break;
        case 0x0002:
            while (switch_init1_chipData1[index][0] != 0xFFFF && switch_init1_chipData1[index][1] != 0xABCD)
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init1_chipData1[index][0],(uint32)switch_init1_chipData1[index][1]))
                    return RT_ERR_FAILED;
                index ++;
            }
            break;
        default:
            return RT_ERR_FAILED;
    }
#else
    index = 0;
    switch(regData)
    {

        case 0x0000:
            while (switch_init1_chipData0[index][0] != 0xFFFF && switch_init1_chipData0[index][1] != 0xABCD)
            {
                if ((switch_init1_chipData0[index][0]&0xF000)==0x2000)
                {
                    cnt = 0;
                    busyFlag = 1;
                    while (busyFlag&&cnt<5)
                    {
                        cnt++;
                        if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                            return retVal;
                    }
                    if (5 == cnt)
                        return RT_ERR_BUSYWAIT_TIMEOUT;

                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32)switch_init1_chipData0[index][1])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32)switch_init1_chipData0[index][0])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                        return retVal;
                }
                else
                {
                    if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init1_chipData0[index][0],(uint32)switch_init1_chipData0[index][1]))
                        return RT_ERR_FAILED;
                }
                index ++;
            }
            break;
        case 0x0001:
            while (switch_init1_chipData1[index][0] != 0xFFFF && switch_init1_chipData1[index][1] != 0xABCD)
            {
                if ((switch_init1_chipData1[index][0]&0xF000)==0x2000)
                {
                    cnt = 0;
                    busyFlag = 1;
                    while (busyFlag&&cnt<5)
                    {
                        cnt++;
                        if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                            return retVal;
                    }
                    if (5 == cnt)
                        return RT_ERR_BUSYWAIT_TIMEOUT;

                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32)switch_init1_chipData1[index][1])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32)switch_init1_chipData1[index][0])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                        return retVal;
                }
                else
                {
                    if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init1_chipData1[index][0],(uint32)switch_init1_chipData1[index][1]))
                        return RT_ERR_FAILED;
                }
                index ++;
            }
            break;
        case 0x0002:
            while (switch_init1_chipData1[index][0] != 0xFFFF && switch_init1_chipData1[index][1] != 0xABCD)
            {
                if ((switch_init1_chipData1[index][0]&0xF000)==0x2000)
                {
                    cnt = 0;
                    busyFlag = 1;
                    while (busyFlag&&cnt<5)
                    {
                        cnt++;
                        if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                            return retVal;
                    }
                    if (5 == cnt)
                        return RT_ERR_BUSYWAIT_TIMEOUT;

                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32)switch_init1_chipData1[index][1])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32)switch_init1_chipData1[index][0])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                        return retVal;
                }
                else
                {
                    if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init1_chipData1[index][0],(uint32)switch_init1_chipData1[index][1]))
                        return RT_ERR_FAILED;
                }
                index ++;
            }
            break;
        default:
            return RT_ERR_FAILED;
    }
#endif /*End of #ifdef MDC_MDIO_OPERATION*/

    return RT_ERR_OK;

}

const uint16 switch_init2_chipData0[][2] = {{0x1B24, 0x0000},{0x1B25, 0x0000},{0x1B26, 0x0000},{0x1B27, 0x0000},
                                    {0x207F, 0x0007},{0x207E, 0x000B},{0x2076, 0x1A00},{0x207E, 0x000A},
                                    {0x2078, 0x1D22},{0x207F, 0x0000},{0x205F, 0x0007},{0x205E, 0x000A},
                                    {0x2059, 0x0000},{0x205A, 0x0000},{0x205B, 0x0000},{0x205C, 0x0000},
                                    {0x205E, 0x000B},{0x2055, 0x0500},{0x2056, 0x0000},{0x2057, 0x0000},
                                    {0x2058, 0x0000},{0x205F, 0x0000},{0x1362, 0x0115},{0x1363, 0x0002},
                                    {0x1363, 0x0000},{0x133F, 0x0030},{0x133E, 0x000E},{0x221F, 0x0007},
                                    {0x221E, 0x0040},{0x2218, 0x0000},{0x221F, 0x0007},{0x221E, 0x002C},
                                    {0x2218, 0x008B},{0x221F, 0x0005},{0x2205, 0x8B6E},{0x2206, 0x0000},
                                    {0x220F, 0x0100},{0x2205, 0xFFF6},{0x2206, 0x0080},{0x2205, 0x8000},
                                    {0x2206, 0x0280},{0x2206, 0x1EF7},{0x2206, 0x00E0},{0x2206, 0xFFF7},
                                    {0x2206, 0xA080},{0x2206, 0x02AE},{0x2206, 0xF602},{0x2206, 0x8046},
                                    {0x2206, 0x0201},{0x2206, 0x5002},{0x2206, 0x0163},{0x2206, 0x0280},
                                    {0x2206, 0xCD02},{0x2206, 0x0179},{0x2206, 0xAEE7},{0x2206, 0xBF80},
                                    {0x2206, 0x61D7},{0x2206, 0x8580},{0x2206, 0xD06C},{0x2206, 0x0229},
                                    {0x2206, 0x71EE},{0x2206, 0x8B64},{0x2206, 0x00EE},{0x2206, 0x8570},
                                    {0x2206, 0x00EE},{0x2206, 0x8571},{0x2206, 0x00EE},{0x2206, 0x8AFC},
                                    {0x2206, 0x07EE},{0x2206, 0x8AFD},{0x2206, 0x73EE},{0x2206, 0xFFF6},
                                    {0x2206, 0x00EE},{0x2206, 0xFFF7},{0x2206, 0xFC04},{0x2206, 0xBF85},
                                    {0x2206, 0x80D0},{0x2206, 0x6C02},{0x2206, 0x2978},{0x2206, 0xE0E0},
                                    {0x2206, 0xE4E1},{0x2206, 0xE0E5},{0x2206, 0x5806},{0x2206, 0x68C0},
                                    {0x2206, 0xD1D2},{0x2206, 0xE4E0},{0x2206, 0xE4E5},{0x2206, 0xE0E5},
                                    {0x2206, 0x0425},{0x2206, 0x0807},{0x2206, 0x2640},{0x2206, 0x7227},
                                    {0x2206, 0x267E},{0x2206, 0x2804},{0x2206, 0xB729},{0x2206, 0x2576},
                                    {0x2206, 0x2A68},{0x2206, 0xE52B},{0x2206, 0xAD00},{0x2206, 0x2CDB},
                                    {0x2206, 0xF02D},{0x2206, 0x67BB},{0x2206, 0x2E7B},{0x2206, 0x0F2F},
                                    {0x2206, 0x7365},{0x2206, 0x31AC},{0x2206, 0xCC32},{0x2206, 0x2300},
                                    {0x2206, 0x332D},{0x2206, 0x1734},{0x2206, 0x7F52},{0x2206, 0x3510},
                                    {0x2206, 0x0036},{0x2206, 0x1000},{0x2206, 0x3710},{0x2206, 0x0038},
                                    {0x2206, 0x7FCE},{0x2206, 0x3CE5},{0x2206, 0xF73D},{0x2206, 0x3DA4},
                                    {0x2206, 0x6530},{0x2206, 0x3E67},{0x2206, 0x0053},{0x2206, 0x69D2},
                                    {0x2206, 0x0F6A},{0x2206, 0x012C},{0x2206, 0x6C2B},{0x2206, 0x136E},
                                    {0x2206, 0xE100},{0x2206, 0x6F12},{0x2206, 0xF771},{0x2206, 0x006B},
                                    {0x2206, 0x7306},{0x2206, 0xEB74},{0x2206, 0x94C7},{0x2206, 0x7698},
                                    {0x2206, 0x0A77},{0x2206, 0x5000},{0x2206, 0x788A},{0x2206, 0x1579},
                                    {0x2206, 0x7F6F},{0x2206, 0x7A06},{0x2206, 0xA6F8},{0x2206, 0xE08B},
                                    {0x2206, 0x8EAD},{0x2206, 0x2006},{0x2206, 0x0280},{0x2206, 0xDC02},
                                    {0x2206, 0x8109},{0x2206, 0xFC04},{0x2206, 0xF8F9},{0x2206, 0xE08B},
                                    {0x2206, 0x87AD},{0x2206, 0x2022},{0x2206, 0xE0E2},{0x2206, 0x00E1},
                                    {0x2206, 0xE201},{0x2206, 0xAD20},{0x2206, 0x11E2},{0x2206, 0xE022},
                                    {0x2206, 0xE3E0},{0x2206, 0x23AD},{0x2206, 0x3908},{0x2206, 0x5AC0},
                                    {0x2206, 0x9F04},{0x2206, 0xF724},{0x2206, 0xAE02},{0x2206, 0xF624},
                                    {0x2206, 0xE4E2},{0x2206, 0x00E5},{0x2206, 0xE201},{0x2206, 0xFDFC},
                                    {0x2206, 0x04F8},{0x2206, 0xF9E0},{0x2206, 0x8B85},{0x2206, 0xAD25},
                                    {0x2206, 0x48E0},{0x2206, 0x8AD2},{0x2206, 0xE18A},{0x2206, 0xD37C},
                                    {0x2206, 0x0000},{0x2206, 0x9E35},{0x2206, 0xEE8A},{0x2206, 0xD200},
                                    {0x2206, 0xEE8A},{0x2206, 0xD300},{0x2206, 0xE08A},{0x2206, 0xFCE1},
                                    {0x2206, 0x8AFD},{0x2206, 0xE285},{0x2206, 0x70E3},{0x2206, 0x8571},
                                    {0x2206, 0x0229},{0x2206, 0x3AAD},{0x2206, 0x2012},{0x2206, 0xEE8A},
                                    {0x2206, 0xD203},{0x2206, 0xEE8A},{0x2206, 0xD3B7},{0x2206, 0xEE85},
                                    {0x2206, 0x7000},{0x2206, 0xEE85},{0x2206, 0x7100},{0x2206, 0xAE11},
                                    {0x2206, 0x15E6},{0x2206, 0x8570},{0x2206, 0xE785},{0x2206, 0x71AE},
                                    {0x2206, 0x08EE},{0x2206, 0x8570},{0x2206, 0x00EE},{0x2206, 0x8571},
                                    {0x2206, 0x00FD},{0x2206, 0xFC04},{0x2206, 0xCCE2},{0x2206, 0x0000},
                                    {0x2205, 0xE142},{0x2206, 0x0701},{0x2205, 0xE140},{0x2206, 0x0405},
                                    {0x220F, 0x0000},{0x221F, 0x0000},{0x221F, 0x0005},{0x2205, 0x85E4},
                                    {0x2206, 0x8A14},{0x2205, 0x85E7},{0x2206, 0x7F6E},{0x221F, 0x0007},
                                    {0x221E, 0x002D},{0x2218, 0xF030},{0x221E, 0x0023},{0x2216, 0x0005},
                                    {0x2215, 0x005C},{0x2219, 0x0068},{0x2215, 0x0082},{0x2219, 0x000A},
                                    {0x2215, 0x00A1},{0x2219, 0x0081},{0x2215, 0x00AF},{0x2219, 0x0080},
                                    {0x2215, 0x00D4},{0x2219, 0x0000},{0x2215, 0x00E4},{0x2219, 0x0081},
                                    {0x2215, 0x00E7},{0x2219, 0x0080},{0x2215, 0x010D},{0x2219, 0x0083},
                                    {0x2215, 0x0118},{0x2219, 0x0083},{0x2215, 0x0120},{0x2219, 0x0082},
                                    {0x2215, 0x019C},{0x2219, 0x0081},{0x2215, 0x01A4},{0x2219, 0x0080},
                                    {0x2215, 0x01CD},{0x2219, 0x0000},{0x2215, 0x01DD},{0x2219, 0x0081},
                                    {0x2215, 0x01E0},{0x2219, 0x0080},{0x2215, 0x0147},{0x2219, 0x0096},
                                    {0x2216, 0x0000},{0x221E, 0x002D},{0x2218, 0xF010},{0x221F, 0x0005},
                                    {0x2205, 0x8B84},{0x2206, 0x0062},{0x221F, 0x0000},{0x220D, 0x0003},
                                    {0x220E, 0x0015},{0x220D, 0x4003},{0x220E, 0x0006},{0x133F, 0x0010},
                                    {0x133E, 0x0FFE},{0x12A4, 0x380A},{0x1303, 0x0367},{0x1304, 0x7777},
                                    {0x1203, 0xFF00},{0x1200, 0x7FC4},{0x121D, 0x7D16},{0x121E, 0x03E8},
                                    {0x121F, 0x024E},{0x1220, 0x0230},{0x1221, 0x0244},{0x1222, 0x0226},
                                    {0x1223, 0x024E},{0x1224, 0x0230},{0x1225, 0x0244},{0x1226, 0x0226},
                                    {0x1227, 0x00C0},{0x1228, 0x00B4},{0x122F, 0x00C0},{0x1230, 0x00B4},
                                    {0x0208, 0x03E8},{0x0209, 0x03E8},{0x020A, 0x03E8},{0x020B, 0x03E8},
                                    {0x020C, 0x03E8},{0x020D, 0x03E8},{0x020E, 0x03E8},{0x020F, 0x03E8},
                                    {0x0210, 0x03E8},{0x0211, 0x03E8},{0x0212, 0x03E8},{0x0213, 0x03E8},
                                    {0x0214, 0x03E8},{0x0215, 0x03E8},{0x0216, 0x03E8},{0x0217, 0x03E8},
                                    {0x0865, 0x3210},{0x087B, 0x0000},{0x087C, 0xFF00},{0x087D, 0x0000},
                                    {0x087E, 0x0000},{0x0801, 0x0100},{0x0802, 0x0100},{0x0A20, 0x2040},
                                    {0x0A21, 0x2040},{0x0A22, 0x2040},{0x0A23, 0x2040},{0x0A24, 0x2040},
                                    {0x0A28, 0x2040},{0x0A29, 0x2040},{0x20A0, 0x1940},{0x20C0, 0x1940},
                                    {0x20E0, 0x1940},{0x1B03, 0x0876},{0xFFFF, 0xABCD}};

const uint16 switch_init2_chipData1[][2] = {{0x1B24, 0x0000},{0x1B25, 0x0000},{0x1B26, 0x0000},{0x1B27, 0x0000},
                                    {0x207F, 0x0007},{0x207E, 0x000B},{0x2076, 0x1A00},{0x207E, 0x000A},
                                    {0x2078, 0x1D22},{0x207F, 0x0000},{0x205F, 0x0007},{0x205E, 0x000A},
                                    {0x2059, 0x0000},{0x205A, 0x0000},{0x205B, 0x0000},{0x205C, 0x0000},
                                    {0x205E, 0x000B},{0x2055, 0x0500},{0x2056, 0x0000},{0x2057, 0x0000},
                                    {0x2058, 0x0000},{0x205F, 0x0000},{0x1362, 0x0115},{0x1363, 0x0002},
                                    {0x1363, 0x0000},{0x133F, 0x0030},{0x133E, 0x000E},{0x221F, 0x0007},
                                    {0x221E, 0x0040},{0x2218, 0x0000},{0x221F, 0x0007},{0x221E, 0x002C},
                                    {0x2218, 0x008B},{0x221F, 0x0005},{0x2205, 0x8B6E},{0x2206, 0x0000},
                                    {0x220F, 0x0100},{0x2205, 0xFFF6},{0x2206, 0x0080},{0x2205, 0x8000},
                                    {0x2206, 0x0280},{0x2206, 0x1EF7},{0x2206, 0x00E0},{0x2206, 0xFFF7},
                                    {0x2206, 0xA080},{0x2206, 0x02AE},{0x2206, 0xF602},{0x2206, 0x8046},
                                    {0x2206, 0x0201},{0x2206, 0x5002},{0x2206, 0x0163},{0x2206, 0x0280},
                                    {0x2206, 0xCD02},{0x2206, 0x0179},{0x2206, 0xAEE7},{0x2206, 0xBF80},
                                    {0x2206, 0x61D7},{0x2206, 0x8580},{0x2206, 0xD06C},{0x2206, 0x0229},
                                    {0x2206, 0x71EE},{0x2206, 0x8B64},{0x2206, 0x00EE},{0x2206, 0x8570},
                                    {0x2206, 0x00EE},{0x2206, 0x8571},{0x2206, 0x00EE},{0x2206, 0x8AFC},
                                    {0x2206, 0x07EE},{0x2206, 0x8AFD},{0x2206, 0x73EE},{0x2206, 0xFFF6},
                                    {0x2206, 0x00EE},{0x2206, 0xFFF7},{0x2206, 0xFC04},{0x2206, 0xBF85},
                                    {0x2206, 0x80D0},{0x2206, 0x6C02},{0x2206, 0x2978},{0x2206, 0xE0E0},
                                    {0x2206, 0xE4E1},{0x2206, 0xE0E5},{0x2206, 0x5806},{0x2206, 0x68C0},
                                    {0x2206, 0xD1D2},{0x2206, 0xE4E0},{0x2206, 0xE4E5},{0x2206, 0xE0E5},
                                    {0x2206, 0x0425},{0x2206, 0x0807},{0x2206, 0x2640},{0x2206, 0x7227},
                                    {0x2206, 0x267E},{0x2206, 0x2804},{0x2206, 0xB729},{0x2206, 0x2576},
                                    {0x2206, 0x2A68},{0x2206, 0xE52B},{0x2206, 0xAD00},{0x2206, 0x2CDB},
                                    {0x2206, 0xF02D},{0x2206, 0x67BB},{0x2206, 0x2E7B},{0x2206, 0x0F2F},
                                    {0x2206, 0x7365},{0x2206, 0x31AC},{0x2206, 0xCC32},{0x2206, 0x2300},
                                    {0x2206, 0x332D},{0x2206, 0x1734},{0x2206, 0x7F52},{0x2206, 0x3510},
                                    {0x2206, 0x0036},{0x2206, 0x1000},{0x2206, 0x3710},{0x2206, 0x0038},
                                    {0x2206, 0x7FCE},{0x2206, 0x3CE5},{0x2206, 0xF73D},{0x2206, 0x3DA4},
                                    {0x2206, 0x6530},{0x2206, 0x3E67},{0x2206, 0x0053},{0x2206, 0x69D2},
                                    {0x2206, 0x0F6A},{0x2206, 0x012C},{0x2206, 0x6C2B},{0x2206, 0x136E},
                                    {0x2206, 0xE100},{0x2206, 0x6F12},{0x2206, 0xF771},{0x2206, 0x006B},
                                    {0x2206, 0x7306},{0x2206, 0xEB74},{0x2206, 0x94C7},{0x2206, 0x7698},
                                    {0x2206, 0x0A77},{0x2206, 0x5000},{0x2206, 0x788A},{0x2206, 0x1579},
                                    {0x2206, 0x7F6F},{0x2206, 0x7A06},{0x2206, 0xA6F8},{0x2206, 0xE08B},
                                    {0x2206, 0x8EAD},{0x2206, 0x2006},{0x2206, 0x0280},{0x2206, 0xDC02},
                                    {0x2206, 0x8109},{0x2206, 0xFC04},{0x2206, 0xF8F9},{0x2206, 0xE08B},
                                    {0x2206, 0x87AD},{0x2206, 0x2022},{0x2206, 0xE0E2},{0x2206, 0x00E1},
                                    {0x2206, 0xE201},{0x2206, 0xAD20},{0x2206, 0x11E2},{0x2206, 0xE022},
                                    {0x2206, 0xE3E0},{0x2206, 0x23AD},{0x2206, 0x3908},{0x2206, 0x5AC0},
                                    {0x2206, 0x9F04},{0x2206, 0xF724},{0x2206, 0xAE02},{0x2206, 0xF624},
                                    {0x2206, 0xE4E2},{0x2206, 0x00E5},{0x2206, 0xE201},{0x2206, 0xFDFC},
                                    {0x2206, 0x04F8},{0x2206, 0xF9E0},{0x2206, 0x8B85},{0x2206, 0xAD25},
                                    {0x2206, 0x48E0},{0x2206, 0x8AD2},{0x2206, 0xE18A},{0x2206, 0xD37C},
                                    {0x2206, 0x0000},{0x2206, 0x9E35},{0x2206, 0xEE8A},{0x2206, 0xD200},
                                    {0x2206, 0xEE8A},{0x2206, 0xD300},{0x2206, 0xE08A},{0x2206, 0xFCE1},
                                    {0x2206, 0x8AFD},{0x2206, 0xE285},{0x2206, 0x70E3},{0x2206, 0x8571},
                                    {0x2206, 0x0229},{0x2206, 0x3AAD},{0x2206, 0x2012},{0x2206, 0xEE8A},
                                    {0x2206, 0xD203},{0x2206, 0xEE8A},{0x2206, 0xD3B7},{0x2206, 0xEE85},
                                    {0x2206, 0x7000},{0x2206, 0xEE85},{0x2206, 0x7100},{0x2206, 0xAE11},
                                    {0x2206, 0x15E6},{0x2206, 0x8570},{0x2206, 0xE785},{0x2206, 0x71AE},
                                    {0x2206, 0x08EE},{0x2206, 0x8570},{0x2206, 0x00EE},{0x2206, 0x8571},
                                    {0x2206, 0x00FD},{0x2206, 0xFC04},{0x2206, 0xCCE2},{0x2206, 0x0000},
                                    {0x2205, 0xE142},{0x2206, 0x0701},{0x2205, 0xE140},{0x2206, 0x0405},
                                    {0x220F, 0x0000},{0x221F, 0x0000},{0x221F, 0x0005},{0x2205, 0x85E4},
                                    {0x2206, 0x8A14},{0x2205, 0x85E7},{0x2206, 0x7F6E},{0x221F, 0x0007},
                                    {0x221E, 0x002D},{0x2218, 0xF030},{0x221E, 0x0023},{0x2216, 0x0005},
                                    {0x2215, 0x005C},{0x2219, 0x0068},{0x2215, 0x0082},{0x2219, 0x000A},
                                    {0x2215, 0x00A1},{0x2219, 0x0081},{0x2215, 0x00AF},{0x2219, 0x0080},
                                    {0x2215, 0x00D4},{0x2219, 0x0000},{0x2215, 0x00E4},{0x2219, 0x0081},
                                    {0x2215, 0x00E7},{0x2219, 0x0080},{0x2215, 0x010D},{0x2219, 0x0083},
                                    {0x2215, 0x0118},{0x2219, 0x0083},{0x2215, 0x0120},{0x2219, 0x0082},
                                    {0x2215, 0x019C},{0x2219, 0x0081},{0x2215, 0x01A4},{0x2219, 0x0080},
                                    {0x2215, 0x01CD},{0x2219, 0x0000},{0x2215, 0x01DD},{0x2219, 0x0081},
                                    {0x2215, 0x01E0},{0x2219, 0x0080},{0x2215, 0x0147},{0x2219, 0x0096},
                                    {0x2216, 0x0000},{0x221E, 0x002D},{0x2218, 0xF010},{0x221F, 0x0005},
                                    {0x2205, 0x8B84},{0x2206, 0x0062},{0x221F, 0x0000},{0x220D, 0x0003},
                                    {0x220E, 0x0015},{0x220D, 0x4003},{0x220E, 0x0006},{0x133F, 0x0010},
                                    {0x133E, 0x0FFE},{0x12A4, 0x380A},{0x1303, 0x0367},{0x1304, 0x7777},
                                    {0x1203, 0xFF00},{0x1200, 0x7FC4},{0x0865, 0x3210},{0x087B, 0x0000},
                                    {0x087C, 0xFF00},{0x087D, 0x0000},{0x087E, 0x0000},{0x0801, 0x0100},
                                    {0x0802, 0x0100},{0x0A20, 0x2040},{0x0A21, 0x2040},{0x0A22, 0x2040},
                                    {0x0A23, 0x2040},{0x0A24, 0x2040},{0x0A25, 0x2040},{0x0A26, 0x2040},
                                    {0x0A27, 0x2040},{0x0A28, 0x2040},{0x0A29, 0x2040},{0x1B03, 0x0876},
                                    {0xFFFF, 0xABCD}};


static rtk_api_ret_t _rtk_switch_init2(void)
{
    rtk_api_ret_t retVal;
    uint32 index,regData;
#ifndef MDC_MDIO_OPERATION
    uint32 busyFlag,cnt;
#endif

    if ((retVal = rtl8370_setAsicReg(0x13C2,0x0249))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_getAsicRegBits(0x1302, 0x7,&regData))!=RT_ERR_OK)
        return retVal;

#ifdef MDC_MDIO_OPERATION
    index = 0;
    switch(regData)
    {
        case 0x0000:
            while (switch_init2_chipData0[index][0] != 0xFFFF && switch_init2_chipData0[index][1] != 0xABCD)
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init2_chipData0[index][0],(uint32)switch_init2_chipData0[index][1]))
                    return RT_ERR_FAILED;
                index ++;
            }
            break;
        case 0x0001:
            while (switch_init2_chipData1[index][0] != 0xFFFF && switch_init2_chipData1[index][1] != 0xABCD)
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init2_chipData1[index][0],(uint32)switch_init2_chipData1[index][1]))
                    return RT_ERR_FAILED;
                index ++;
            }
            break;
        case 0x0002:
            while (switch_init2_chipData1[index][0] != 0xFFFF && switch_init2_chipData1[index][1] != 0xABCD)
            {
                if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init2_chipData1[index][0],(uint32)switch_init2_chipData1[index][1]))
                    return RT_ERR_FAILED;
                index ++;
            }
            break;
        default:
            return RT_ERR_FAILED;
    }
#else
    index = 0;
    switch(regData)
    {

        case 0x0000:
            while (switch_init2_chipData0[index][0] != 0xFFFF && switch_init2_chipData0[index][1] != 0xABCD)
            {
                if ((switch_init2_chipData0[index][0]&0xF000)==0x2000)
                {
                    cnt = 0;
                    busyFlag = 1;
                    while (busyFlag&&cnt<5)
                    {
                        cnt++;
                        if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                            return retVal;
                    }
                    if (5 == cnt)
                        return RT_ERR_BUSYWAIT_TIMEOUT;

                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32)switch_init2_chipData0[index][1])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32)switch_init2_chipData0[index][0])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                        return retVal;
                }
                else
                {
                    if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init2_chipData0[index][0],(uint32)switch_init2_chipData0[index][1]))
                        return RT_ERR_FAILED;
                }
                index ++;
            }
            break;
        case 0x0001:
            while (switch_init2_chipData1[index][0] != 0xFFFF && switch_init2_chipData1[index][1] != 0xABCD)
            {
                if ((switch_init2_chipData1[index][0]&0xF000)==0x2000)
                {
                    cnt = 0;
                    busyFlag = 1;
                    while (busyFlag&&cnt<5)
                    {
                        cnt++;
                        if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                            return retVal;
                    }
                    if (5 == cnt)
                        return RT_ERR_BUSYWAIT_TIMEOUT;

                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32)switch_init2_chipData1[index][1])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32)switch_init2_chipData1[index][0])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                        return retVal;
                }
                else
                {
                    if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init2_chipData1[index][0],(uint32)switch_init2_chipData1[index][1]))
                        return RT_ERR_FAILED;
                }
                index ++;
            }
            break;
        case 0x0002:
            while (switch_init2_chipData1[index][0] != 0xFFFF && switch_init2_chipData1[index][1] != 0xABCD)
            {
                if ((switch_init2_chipData1[index][0]&0xF000)==0x2000)
                {
                    cnt = 0;
                    busyFlag = 1;
                    while (busyFlag&&cnt<5)
                    {
                        cnt++;
                        if ((retVal = rtl8370_getAsicRegBit(RTK_INDRECT_ACCESS_STATUS, RTK_PHY_BUSY_OFFSET,&busyFlag)) !=  RT_ERR_OK)
                            return retVal;
                    }
                    if (5 == cnt)
                        return RT_ERR_BUSYWAIT_TIMEOUT;

                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_WRITE_DATA, (uint32)switch_init2_chipData1[index][1])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_ADDRESS, (uint32)switch_init2_chipData1[index][0])) !=  RT_ERR_OK)
                        return retVal;
                    if ((retVal = rtl8370_setAsicReg(RTK_INDRECT_ACCESS_CRTL, RTK_CMD_MASK | RTK_RW_MASK)) !=  RT_ERR_OK)
                        return retVal;
                }
                else
                {
                    if (RT_ERR_OK != rtl8370_setAsicReg((uint32)switch_init2_chipData1[index][0],(uint32)switch_init2_chipData1[index][1]))
                        return RT_ERR_FAILED;
                }
                index ++;
            }
            break;
        default:
            return RT_ERR_FAILED;
    }
#endif /*End of #ifdef MDC_MDIO_OPERATION*/

    return RT_ERR_OK;
}

/* Function Name:
 *      rtk_switch_init
 * Description:
 *      Set chip to default configuration enviroment
 * Input:
 *      None
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 * Note:
 *      The API can set chip registers to default configuration for different release chip model.
 */
static rtk_api_ret_t rtk_switch_init(void)
{

    rtk_api_ret_t retVal;
    uint32 regData1,regData2;

    if ((retVal = rtl8370_setAsicReg(0x13C2,0x0249))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_getAsicRegBits(0x1301, 0xF000,&regData1))!=RT_ERR_OK)
        return retVal;


    if ((retVal = rtl8370_setAsicPHYReg(0,31,5))!=RT_ERR_OK)
        return retVal;
    if ((retVal = rtl8370_setAsicPHYReg(0,5,0x3ffe))!=RT_ERR_OK)
        return retVal;
    if ((retVal = rtl8370_getAsicPHYReg(0,6,&regData2))!=RT_ERR_OK)
        return retVal;

    if (0 == regData1)
    {
        if ((retVal = _rtk_switch_init0()) != RT_ERR_OK)
            return retVal;
    }
    else if (1 == regData1)
    {
        if (0x94eb == regData2)
        {
            if ((retVal = _rtk_switch_init1()) != RT_ERR_OK)
                return retVal;
        }
        else if (0x2104 == regData2)
        {
            if ((retVal = _rtk_switch_init2()) != RT_ERR_OK)
                return retVal;
        }
    }

    /*Enable System Based LED*/
    if ((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_SYS_CONFIG, RTL8370_LED_IO_DISABLE_OFFSET, 0))!=RT_ERR_OK)
        return retVal;


    return RT_ERR_OK;
}

static void test_smi_signal_and_wait(void)
{
    int i;

    for (i=0; i<100; i++)
    {
        unsigned int data;
        rtk_api_ret_t retVal;

        if((retVal = rtl8370_getAsicReg(0x1202, &data)) != RT_ERR_OK)
        {
            printf("error = %d\n", retVal);
        }

        //printf("data = %x\n", data);

        if (data == 0x88a8)
            break;

        CLK_DURATION(50000);
    }
}

/*
@func ret_t | rtl8370_setAsicLedGroupEnable | Turn on/off Led of all system ports
@parm uint32 | group | LED group id.
@parm uint32 | portmask | LED port mask. 
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@rvalue RT_ERR_PORT_ID | Invalid port number.
@rvalue RT_ERR_INPUT | Invalid input value.
@comm
    The API can turn on/off leds of dedicated port while indicated information configuration of LED group is set to force mode.
 */
ret_t rtl8370_setAsicLedGroupEnable(uint32 group, uint32 portmask)
{
    ret_t retVal;
    uint32 regAddr;
    uint32 regDataMask;

    if ( group > RTL8370_LEDGROUPMAX )
        return RT_ERR_INPUT;

    if ( portmask > 0xFF )
        return RT_ERR_INPUT;

    regAddr = RTL8370_REG_PARA_LED_IO_EN1 + group/2;

    regDataMask = 0xFF << ((group%2)*8);

    if ((retVal = rtl8370_setAsicRegBits(regAddr, regDataMask, portmask))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/*
@func ret_t | rtl8370_setAsicLedGroupMode | Turn on/off Led of dedicated port
@parm uint32 | mode | LED mode, 0b00:mode 0, 0b01:mode 1, 0b10:mode 2, 0b11:mode 3.
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@rvalue RT_ERR_PORT_ID | Invalid port number.
@rvalue RT_ERR_INPUT | Invalid input value.
@comm
    The API can turn on/off leds of dedicated port while indicated information configuration of LED group is set to force mode.
	    set  led0    led1   led2
mode 0	00   0010  0011  0100
mode 1	01   0110  0111  1000
mode 2	10   0001  0110  1001
mode 3	11   1000  0110  0111

    
 */
ret_t rtl8370_setAsicLedGroupMode(uint32 mode)
{
    ret_t retVal;
    uint32 regData;
	
    /* Invalid input parameter */
    if(mode >= LEDFORCEMODE_MAX)
        return RT_ERR_INPUT; 
	
    regData = (mode<<RTL8370_DATA_LED_OFFSET)|(1<<RTL8370_LED_CONFIG_SEL_OFFSET);

    retVal = rtl8370_setAsicReg(RTL8370_REG_LED_CONFIGURATION, regData);    

    return retVal;
}

/* Function Name:
 *      rtk_led_enable_set
 * Description:
 *      Set Led parallel mode enable congiuration
 * Input:
 *      group - LED group id.
 *      portmask - LED enable port mask.
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      The API can be used to enable LED parallel mode per port per group.
 */

static rtk_api_ret_t rtk_led_enable_set(rtk_led_group_t group, rtk_portmask_t portmask)
{
    rtk_api_ret_t retVal;

    if (group >= LED_GROUP_END)
        return RT_ERR_INPUT;

    if (portmask.bits[0] > (1<<RTK_PHY_ID_MAX))
        return RT_ERR_INPUT;

    if ((retVal = rtl8370_setAsicLedGroupEnable(group, portmask.bits[0]))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/*
@func ret_t | rtl8370_setAsicLedSerialModeConfig | Set LED serial mode
@parm uint32 | active | Active High or Low. 
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@rvalue RT_ERR_INPUT | Invalid input value.
@comm
    The API can turn on/off led serial mode and set signal to active high/low.
 */
ret_t rtl8370_setAsicLedSerialModeConfig(uint32 active, uint32 serimode)
{
    ret_t retVal;
    
    /* Invalid input parameter */
    if( active >= LEDSERACT_MAX)
        return RT_ERR_INPUT;
    if( serimode >= LEDSER_MAX)
        return RT_ERR_INPUT;

    /* Set Active High or Low */
    if((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_SYS_CONFIG,RTL8370_SERI_LED_ACT_LOW_OFFSET,active)) !=  RT_ERR_OK)
        return retVal;

    /*set to 8G mode (not 16G mode)*/
    if((retVal = rtl8370_setAsicRegBit(RTL8370_REG_LED_MODE,RTL8370_RTCT_TEST_TIME_OFFSET, serimode))!=  RT_ERR_OK)
        return retVal;

    
    return RT_ERR_OK;   
}

/*
@func ret_t | rtl8370_setAsicLedSerialEnable | Turn on/off Led serial mode
@parm uint32 | enable | LED serial configuration. 
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@rvalue RT_ERR_PORT_ID | Invalid port number.
@rvalue RT_ERR_INPUT | Invalid input value.
@comm
    The API can turn on/off led of serial mode.
 */
ret_t rtl8370_setAsicLedSerialEnable(uint32 enable)
{
    ret_t retVal;

    if (enable > 1)
        return RT_ERR_FAILED;

    if (enable == 1)
    {
        /*Enable serial CLK mode*/
        if((retVal = rtl8370_setAsicRegBit(RTL8370_REG_SCAN0_LED_IO_EN,RTL8370_LED_SERI_CLK_EN_OFFSET, 1))!=  RT_ERR_OK)
		    return retVal;
        /*Enable serial DATA mode*/
        if((retVal = rtl8370_setAsicRegBit(RTL8370_REG_SCAN0_LED_IO_EN,RTL8370_LED_SERI_DATA_EN_OFFSET, 1))!=  RT_ERR_OK)
		    return retVal;
        
    }
    else
    {
        /*Disable serial CLK mode*/
        if((retVal = rtl8370_setAsicRegBit(RTL8370_REG_SCAN0_LED_IO_EN,RTL8370_LED_SERI_CLK_EN_OFFSET, 0))!=  RT_ERR_OK)
		    return retVal;
        /*Disable serial DATA mode*/
        if((retVal = rtl8370_setAsicRegBit(RTL8370_REG_SCAN0_LED_IO_EN,RTL8370_LED_SERI_DATA_EN_OFFSET, 0))!=  RT_ERR_OK)
		    return retVal;
    
    }
    
    return RT_ERR_OK;
}

/*
@func ret_t | rtl8370_setAsicLedOperationMode | Set LED operation mode
@parm uint32 | mode | LED mode. 1:scan mode 1, 2:parallel mode, 3:mdx mode (serial mode) 
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@rvalue RT_ERR_INPUT | Invalid input value.
@comm
    The API can turn on/off led serial mode and set signal to active high/low.
 */
ret_t rtl8370_setAsicLedOperationMode(uint32 mode)
{
    ret_t retVal;
    
    /* Invalid input parameter */
    if( mode >= LEDOP_MAX)
        return RT_ERR_INPUT; 

    if( mode == LEDOP_SCAN0)
        return RT_ERR_INPUT;   

    switch(mode)
    {
        case LEDOP_SCAN0:
            break;
        case LEDOP_SCAN1:
            if((retVal = rtl8370_setAsicReg(RTL8370_REG_LED_SYS_CONFIG,0x1471))!=  RT_ERR_OK)
		    return retVal;
            if((retVal = rtl8370_setAsicReg(RTL8370_REG_SCAN1_LED_IO_EN,0xFFBF))!=  RT_ERR_OK)
		        return retVal;       
            break;
        case LEDOP_PARALLEL:
            if((retVal = rtl8370_setAsicReg(RTL8370_REG_LED_SYS_CONFIG,0x1472))!=  RT_ERR_OK)
		        return retVal;
            break;
        case LEDOP_SERIAL:
            if((retVal = rtl8370_setAsicReg(RTL8370_REG_LED_SYS_CONFIG,0x14F7))!=  RT_ERR_OK)
		        return retVal;        
            break;
        default:
            break;
    }
    
    return RT_ERR_OK;
}

/*
@func ret_t | rtl8370_setAsicLedIndicateInfoConfig | Set Leds indicated information mode
@parm uint32 | ledno | LED group number. There are 1 to 1 led mapping to each port in each led group. 
@parm enum RTL8370_LEDCONF | config | Support 16 types configuration.
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@comm
    The API can set LED indicated information configuration for each LED group with 1 to 1 led mapping to each port.
    Definition        LED Statuses            Description
    0000        LED_Off                LED pin Tri-State.
    0001        Dup/Col                Collision, Full duplex Indicator. Blinking every 43ms when collision happens. Low for full duplex, and high for half duplex mode.
    0010        Link/Act               Link, Activity Indicator. Low for link established. Link/Act Blinks every 43ms when the corresponding port is transmitting or receiving.
    0011        Spd1000                1000Mb/s Speed Indicator. Low for 1000Mb/s.
    0100        Spd100                 100Mb/s Speed Indicator. Low for 100Mb/s.
    0101        Spd10                  10Mb/s Speed Indicator. Low for 10Mb/s.
    0110        Spd1000/Act            1000Mb/s Speed/Activity Indicator. Low for 1000Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
    0111        Spd100/Act             100Mb/s Speed/Activity Indicator. Low for 100Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
    1000        Spd10/Act              10Mb/s Speed/Activity Indicator. Low for 10Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
    1001        Spd100 (10)/Act        10/100Mb/s Speed/Activity Indicator. Low for 10/100Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
    1010        Fiber                  Fiber link Indicator. Low for Fiber.
    1011        Fault                  Auto-negotiation     Fault Indicator. Low for Fault.
    1100        Link/Rx                Link, Activity Indicator. Low for link established. Link/Rx Blinks every 43ms when the corresponding port is transmitting.
    1101        Link/Tx                Link, Activity Indicator. Low for link established. Link/Tx Blinks every 43ms when the corresponding port is receiving.
    1110        Master                 Link on Master Indicator. Low for link Master established.
    1111        Act                    Activity Indicator. Low for link established. 
 */
ret_t rtl8370_setAsicLedIndicateInfoConfig(uint32 ledno, enum RTL8370_LEDCONF config)
{
    ret_t retVal;
    uint32 regData;
    const uint16 bits[RTL8370_LEDGROUPMAX+1]= { RTL8370_LED0_CFG_MASK, RTL8370_LED1_CFG_MASK, RTL8370_LED2_CFG_MASK};
    const uint16 offsets[RTL8370_LEDGROUPMAX+1]= { RTL8370_LED0_CFG_OFFSET, RTL8370_LED1_CFG_OFFSET, RTL8370_LED2_CFG_OFFSET};

    if(ledno > RTL8370_LEDGROUPMAX)
        return RT_ERR_INPUT;

    if(config > LEDCONF_ACT)    
        return RT_ERR_INPUT;

    retVal = rtl8370_getAsicReg(RTL8370_REG_LED_CONFIGURATION,&regData);  
	if( retVal !=  RT_ERR_OK)
		return retVal;

    regData = regData & (~RTL8370_LED_CONFIG_SEL_MASK);
    regData = regData & (~bits[ledno]);
    regData = regData | ((config & RTL8370_LED0_CFG_MASK)<<offsets[ledno]);

    retVal = rtl8370_setAsicReg(RTL8370_REG_LED_CONFIGURATION,regData);     

    return retVal;
}

/* Function Name:
 *      rtk_led_operation_set
 * Description:
 *      Set Led operation mode
 * Input:
 *      mode - LED operation mode.
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      The API can set Led operation mode.
 *      The modes that can be set are as following:
 *      LED_OP_SCAN,
 *      LED_OP_PARALLEL,
 *      LED_OP_SERIAL,
 */
rtk_api_ret_t rtk_led_operation_set(rtk_led_operation_t mode)
{
    rtk_api_ret_t retVal;
    uint32 regData;

    if ( mode >= LED_OP_END)
      return RT_ERR_INPUT;

    switch (mode)
    {
        case LED_OP_SCAN:
            regData = 1;
            break;
         case LED_OP_PARALLEL:
            regData = 2;
            break;
        case LED_OP_SERIAL:
            regData = 3;
            if ((retVal = rtl8370_setAsicLedSerialModeConfig(0, 1))!=RT_ERR_OK)
                return retVal;
            if ((retVal = rtl8370_setAsicLedSerialEnable(ENABLED))!=RT_ERR_OK)
                return retVal;
            break;
        default:
            regData = 0;
            break;
    }

    if ((retVal = rtl8370_setAsicLedOperationMode(regData))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/* Function Name:
 *      rtk_led_mode_set
 * Description:
 *      Set Led to congiuration mode
 * Input:
 *      mode - Support LED mode.
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      There are three LED groups for each port for indicating information about dedicated port.
 *      LED groups are set to indicate different information of port in different mode.
 *
 *      Mode0
 *      LED0-Link, Activity Indicator. Low for link established. Link/Act Blinks every 43ms when the corresponding port is transmitting or receiving.
 *      LED1-1000Mb/s Speed Indicator. Low for 1000Mb/s.
 *      LED2-100Mb/s Speed Indicator. Low for 100Mb/s.
 *
 *      Mode1
 *      LED0-Link, Activity Indicator. Low for link established. Link/Act Blinks every 43ms when the corresponding port is transmitting or receiving.
 *      LED1-1000Mb/s Speed Indicator. Low for 1000Mb/s.
 *      LED2-Collision, Full duplex Indicator. Blinking every 43ms when collision happens. Low for full duplex, and high for half duplex mode.
 *
 *      Mode2
 *      LED0-Collision, Full duplex Indicator. Blinking every 43ms when collision happens. Low for full duplex, and high for half duplex mode.
 *      LED1-1000Mb/s Speed/Activity Indicator. Low for 1000Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
 *      LED2-10/100Mb/s Speed/Activity Indicator. Low for 10/100Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
 *
 *      Mode3
 *      LED0-10Mb/s Speed/Activity Indicator. Low for 10Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
 *      LED1-1000Mb/s Speed/Activity Indicator. Low for 1000Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
 *      LED2-100Mb/s Speed/Activity Indicator. Low for 100Mb/s. Blinks every 43ms when the corresponding port is transmitting or receiving.
 */

rtk_api_ret_t rtk_led_mode_set(rtk_led_mode_t mode)
{
    rtk_api_ret_t retVal;

    if (mode >= LED_MODE_END)
        return RT_ERR_FAILED;

    if ((retVal = rtl8370_setAsicLedGroupMode(mode))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/* Function Name:
 *      rtk_led_groupConfig_set
 * Description:
 *      Set per group Led to congiuration mode
 * Input:
 *      group - LED group.
 *      config - LED configuration
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      The API can set LED indicated information configuration for each LED group with 1 to 1 led mapping to each port.
 *      Definition  LED Statuses      Description
 *      0000        LED_Off           LED pin Tri-State.
 *      0001        Dup/Col           Collision, Full duplex Indicator.
 *      0010        Link/Act          Link, Activity Indicator.
 *      0011        Spd1000           1000Mb/s Speed Indicator.
 *      0100        Spd100            100Mb/s Speed Indicator.
 *      0101        Spd10             10Mb/s Speed Indicator.
 *      0110        Spd1000/Act       1000Mb/s Speed/Activity Indicator.
 *      0111        Spd100/Act        100Mb/s Speed/Activity Indicator.
 *      1000        Spd10/Act         10Mb/s Speed/Activity Indicator.
 *      1001        Spd100 (10)/Act   10/100Mb/s Speed/Activity Indicator.
 *      1010        Fiber             Fiber link Indicator.
 *      1011        Fault             Auto-negotiation Fault Indicator.
 *      1100        Link/Rx           Link, Activity Indicator.
 *      1101        Link/Tx           Link, Activity Indicator.
 *      1110        Master            Link on Master Indicator.
 *      1111        Act               Activity Indicator. Low for link established.
 */
rtk_api_ret_t rtk_led_groupConfig_set(rtk_led_group_t group, rtk_led_congig_t config)
{
    rtk_api_ret_t retVal;

    if ( LED_GROUP_END <= group)
        return RT_ERR_FAILED;

    if ( LED_CONFIG_END <= config)
        return RT_ERR_FAILED;

     if ((retVal = rtl8370_setAsicLedIndicateInfoConfig(group, config))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/*
@func ret_t | rtl8370_getAsicLedBlinkRate | Get led blinking rate ate mode 0 to mode 3
@parm enum RTL8370_LEDBLINKRATE* | blinkRate | Support 6 blink rates.
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@comm
    The API can set LED blink rate at 43ms, 84ms, 120ms, 170ms, 340ms and 670ms.
 */
ret_t rtl8370_getAsicLedBlinkRate(enum RTL8370_LEDBLINKRATE* blinkRate)
{
    return rtl8370_getAsicRegBits(RTL8370_REG_LED_MODE, RTL8370_SEL_LEDRATE_MASK,(uint32*)blinkRate);
}

/* Function Name:
 *      rtk_led_blinkRate_get
 * Description:
 *      Get LED blinking rate at mode 0 to mode 3
 * Input:
 *      None
 * Output:
 *      pBlinkRate - blinking rate.
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      There are  6 types of LED blinking rates at 43ms, 84ms, 120ms, 170ms, 340ms and 670ms.
 */
rtk_api_ret_t rtk_led_blinkRate_get(rtk_data_t *pBlinkRate)
{
    rtk_api_ret_t retVal;

    if ((retVal = rtl8370_getAsicLedBlinkRate(pBlinkRate))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/* for leds control  */
/* initial and enable led */
static int init_and_enable_leds(void)
{
    int retVal;
    rtl8370_port_status_t portstatus;
    rtk_portmask_t portmask;
    rtk_data_t BlinkRate;

    /* enable p0/p1 */
    portmask.bits[0] = 0x3;

    retVal = rtk_led_enable_set(LED_GROUP_0, portmask);
    //printf("rtk_led_enable_set(LED_GROUP_0...): return %d\n", retVal);
    retVal = rtk_led_enable_set(LED_GROUP_1, portmask);
    //printf("rtk_led_enable_set(LED_GROUP_1...): return %d\n", retVal);

    retVal = rtk_led_operation_set(LED_OP_PARALLEL);
    //printf("rtk_led_operation_set(): return %d\n", retVal);

    retVal = rtk_led_mode_set(LED_MODE_1);
    //printf("rtk_led_mode_set(): return %d\n", retVal);
    /*
    retVal = rtk_led_blinkRate_set(LED_BLINKRATE_256MS);
    printf("rtk_led_blinkRate_set(): return %d\n", retVal);
    */

    /* LED_CONFIG_SPD10010ACT - 1001 */
    retVal = rtk_led_groupConfig_set(LED_GROUP_0, LED_CONFIG_SPD1000);
    //printf("rtk_led_groupConfig_set(LED_GROUP_0,LED_CONFIG_SPD1000ACT): return %d\n", retVal);
    retVal = rtk_led_groupConfig_set(LED_GROUP_1, LED_CONFIG_SPD1000ACT);
    //printf("rtk_led_groupConfig_set(LED_GROUP_1,LED_CONFIG_SPD1000ACT): return %d\n", retVal);

        /* LED_CONFIG_SPD10010ACT - 1001 */
    retVal = rtk_led_groupConfig_set(LED_GROUP_0, LED_CONFIG_SPD1000);
    //printf("rtk_led_groupConfig_set(LED_GROUP_0,LED_CONFIG_LINK_ACT): return %d\n", retVal);
    retVal = rtk_led_groupConfig_set(LED_GROUP_1, LED_CONFIG_LINK_ACT);
    //printf("rtk_led_groupConfig_set(LED_GROUP_1,LED_CONFIG_LINK_ACT): return %d\n",retVal);

    rtk_led_blinkRate_get(&BlinkRate);
    //printf("current led blinkRate: %d\n", BlinkRate);

    if (bFixLed)
    {
        retVal = rtl8370_getAsicPortStatus(PORT0, &portstatus);
        if (RT_ERR_OK != retVal)
        {
            printf("%s: rtl8370_getAsicPortStatus failed! retVal=0x%x\n", __func__, retVal);
        }
        else
        {
            /* GE0未工作在1000M，强制P0黄灯为1(因为P0LED0黄灯设置为反的) */
            if (portstatus.speed != SPD_1000M)
            {
                /*
            	 * 00: normal mode(not force)
            	 * 01: cpu force led to blink
            	 * 10: cpu force led to 0
            	 * 11: cpu force led to 1
            	 */ 
                simple_phy_write(RTL8370_REG_CPU_FORCE_LED0_CFG0, 0x03);
            }
        }
    }    

    return retVal;
}

/*
@func ret_t | rtl8370_setAsicPortExtMode | Set external interface mode configuration.
@parm uint32 | id | external interface id (0~1).
@parm uint32 |mode | external interface mode.
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@rvalue RT_ERR_FAILED | Invalid parameter.
@comm
  This API can set external interface mode properties. 
    DISABLE,
    RGMII,
    MII_MAC,
    MII_PHY, 
    TMII_MAC,
    TMII_PHY, 
    GMII,
    RGMII_33V,    
 */
ret_t rtl8370_setAsicPortExtMode(uint32 id, uint32 mode)
{
    ret_t retVal;
    
    if(id >= RTL8370_EXTNO)
        return RT_ERR_INPUT;	

    if(mode > EXT_RGMII_33V)
        return RT_ERR_INPUT;	

    if( mode == EXT_RGMII_33V || mode == EXT_RGMII )
    {
        if((retVal= rtl8370_setAsicReg(RTL8370_REG_CHIP_DEBUG0,0x0367)) !=  RT_ERR_OK)
            return retVal;
        if((retVal= rtl8370_setAsicReg(RTL8370_REG_CHIP_DEBUG1,0x7777)) !=  RT_ERR_OK)
            return retVal;
    }
    else if((mode == EXT_TMII_MAC)||(mode == EXT_TMII_PHY))
    {
        if((retVal= rtl8370_setAsicRegBit(RTL8370_REG_BYPASS_LINE_RATE,(id+1)%2,1)) !=  RT_ERR_OK)
            return retVal;
    } 
    else if( mode == EXT_GMII )
    {
        if((retVal= rtl8370_setAsicRegBit(RTL8370_REG_CHIP_DEBUG0,RTL8370_CHIP_DEBUG0_DUMMY_0_OFFSET+id,1)) !=  RT_ERR_OK)
            return retVal;
        if((retVal= rtl8370_setAsicRegBit(RTL8370_REG_EXT0_RGMXF+id,6,1)) !=  RT_ERR_OK)
            return retVal;        
    } 
    else 
    {
        if((retVal= rtl8370_setAsicRegBit(RTL8370_REG_BYPASS_LINE_RATE,(id+1)%2,0)) !=  RT_ERR_OK)
            return retVal;
        if((retVal= rtl8370_setAsicRegBit(RTL8370_REG_EXT0_RGMXF+id,6,0)) !=  RT_ERR_OK)
            return retVal;     
    }      

    return rtl8370_setAsicRegBits(RTL8370_REG_DIGITIAL_INTERFACE_SELECT, RTL8370_SELECT_RGMII_0_MASK<<(id*RTL8370_SELECT_RGMII_1_OFFSET), mode);
}

/*
@func ret_t | rtl8370_getAsicPortForceLinkExt | Get external interface force linking configuration.
@parm uint32 | id | external interface id (0~1).
@parm rtl8370_port_ability_t* | portability | port ability configuration
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@rvalue RT_ERR_FAILED | Invalid parameter.
@comm
      This API can get external interface force mode properties. 
 */
ret_t rtl8370_getAsicPortForceLinkExt(uint32 id, rtl8370_port_ability_t *portability)
{
    ret_t retVal;
    uint32 regData;
    uint16 *accessPtr;
    rtl8370_port_ability_t ability;

    /* Invalid input parameter */
    if(id >= RTL8370_EXTNO)
        return RT_ERR_PORT_ID;
    
    memset(&ability,0x00,sizeof(rtl8370_port_ability_t));


    accessPtr =  (uint16*)&ability;
 
    retVal = rtl8370_getAsicReg(RTL8370_REG_DIGITIAL_INTERFACE0_FORCE + id, &regData);
    if(retVal !=  RT_ERR_OK)
        return retVal;
    
    *accessPtr = regData;

    memcpy(portability, &ability, sizeof(rtl8370_port_ability_t));        
    
    return RT_ERR_OK;  
}

/*
@func ret_t | rtl8370_setAsicPortForceLinkExt | Set external interface force linking configuration.
@parm uint32 | id | external interface id (0~1).
@parm rtl8370_port_ability_t* | portability | port ability configuration
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error.
@rvalue RT_ERR_FAILED | Invalid parameter.
@comm
      This API can set external interface force mode properties. 
 */
ret_t rtl8370_setAsicPortForceLinkExt(uint32 id, rtl8370_port_ability_t *portability)
{
    uint32 regData;
    uint16 *accessPtr;
    rtl8370_port_ability_t ability;

    /* Invalid input parameter */
    if(id >=RTL8370_EXTNO)
        return RT_ERR_PORT_ID;
    
    memset(&ability, 0x00, sizeof(rtl8370_port_ability_t));
    memcpy(&ability, portability, sizeof(rtl8370_port_ability_t));    

    accessPtr = (uint16*)&ability;
 
    regData = *accessPtr;

    return rtl8370_setAsicReg(RTL8370_REG_DIGITIAL_INTERFACE0_FORCE + id, regData);
}

/* Function Name:
 *      rtk_port_macForceLinkExt0_set
 * Description:
 *      Set external interface 0 force linking configuration.
 * Input:
 *      mode - external interface mode
 *      pPortability - port ability configuration
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      This API can set external interface 0 force mode properties.
 *      The external interface can be set to:
 *      MODE_EXT_DISABLE,
 *      MODE_EXT_RGMII,
 *      MODE_EXT_MII_MAC,
 *      MODE_EXT_MII_PHY,
 *      MODE_EXT_TMII_MAC,
 *      MODE_EXT_TMII_PHY,
 *      MODE_EXT_GMII,
 *      MODE_EXT_RGMII_33V,
 */
rtk_api_ret_t rtk_port_macForceLinkExt0_set(rtk_mode_ext_t mode, rtk_port_mac_ability_t *pPortability)
{
    rtk_api_ret_t retVal;
    rtl8370_port_ability_t ability;

    if (mode >=MODE_EXT_END)
        return RT_ERR_INPUT;

    if (pPortability->forcemode>1||pPortability->speed>2||pPortability->duplex>1||
       pPortability->link>1||pPortability->nway>1||pPortability->txpause>1||pPortability->rxpause>1)
        return RT_ERR_INPUT;

    if ((retVal = rtl8370_setAsicPortExtMode(RTK_EXT_0, mode))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_getAsicPortForceLinkExt(RTK_EXT_0,&ability))!=RT_ERR_OK)
        return retVal;

    ability.forcemode = pPortability->forcemode;
    ability.speed     = pPortability->speed;
    ability.duplex    = pPortability->duplex;
    ability.link      = pPortability->link;
    ability.nway      = pPortability->nway;
    ability.txpause   = pPortability->txpause;
    ability.rxpause   = pPortability->rxpause;

    if ((retVal = rtl8370_setAsicPortForceLinkExt(RTK_EXT_0,&ability))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/* Function Name:
 *      rtk_port_macForceLinkExt1_set
 * Description:
 *      Set external interface 1 force linking configuration.
 * Input:
 *      mode - external interface mode
 *      pPortability - port ability configuration
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      This API can set external interface 1 force mode properties.
 *      The external interface can be set to:
 *      MODE_EXT_DISABLE,
 *      MODE_EXT_RGMII,
 *      MODE_EXT_MII_MAC,
 *      MODE_EXT_MII_PHY,
 *      MODE_EXT_TMII_MAC,
 *      MODE_EXT_TMII_PHY,
 *      MODE_EXT_GMII,
 *      MODE_EXT_RGMII_33V,
 */
rtk_api_ret_t rtk_port_macForceLinkExt1_set(rtk_mode_ext_t mode, rtk_port_mac_ability_t *pPortability)
{
    rtk_api_ret_t retVal;
    rtl8370_port_ability_t ability;

    if (mode >=MODE_EXT_END)
        return RT_ERR_INPUT;

    if (pPortability->forcemode>1||pPortability->speed>2||pPortability->duplex>1||
       pPortability->link>1||pPortability->nway>1||pPortability->txpause>1||pPortability->rxpause>1)
        return RT_ERR_INPUT;

    if ((retVal = rtl8370_setAsicPortExtMode(RTK_EXT_1, mode))!=RT_ERR_OK)
        return retVal;

    if ((retVal = rtl8370_getAsicPortForceLinkExt(RTK_EXT_1,&ability))!=RT_ERR_OK)
        return retVal;

    ability.forcemode = pPortability->forcemode;
    ability.speed     = pPortability->speed;
    ability.duplex    = pPortability->duplex;
    ability.link      = pPortability->link;
    ability.nway      = pPortability->nway;
    ability.txpause   = pPortability->txpause;
    ability.rxpause   = pPortability->rxpause;

    if ((retVal = rtl8370_setAsicPortForceLinkExt(RTK_EXT_1,&ability))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

static int set_ext_mode(void)
{
    int retVal;
    rtk_port_mac_ability_t mac_cfg;
    rtk_mode_ext_t mode;

    mode = MODE_EXT_RGMII;
    mac_cfg.forcemode = MAC_FORCE;
    mac_cfg.speed = SPD_1000M;
    mac_cfg.duplex = FULL_DUPLEX;
    mac_cfg.link = PORT_LINKUP;
    mac_cfg.nway = DISABLED;
    mac_cfg.txpause = ENABLED;
    mac_cfg.rxpause = ENABLED;

    retVal = rtk_port_macForceLinkExt0_set(mode, &mac_cfg);
    //printf("rtk_port_macForceLinkExt0_set:set ext0 force 1000M speed,retVal %d\n", retVal);

    retVal = rtk_port_macForceLinkExt1_set(mode, &mac_cfg);
    //printf("rtk_port_macForceLinkExt1_set:set ext1 force 1000M speed,retVal %d\n", retVal);
    return retVal;
}


/* Function Name:
 *      rtk_port_rgmiiDelayExt0_set
 * Description:
 *      Set RGMII interface 0 delay value for TX and RX.
 * Input:
 *      txDelay - TX delay value, 1 for delay 2ns and 0 for no-delay
 *      rxDelay - RX delay value, 0~7 for delay setup.
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      This API can set external interface 0 RGMII delay.
 *      In TX delay, there are 2 selection: no-delay and 2ns delay.
 *      In RX dekay, there are 8 steps for delay tunning. 0 for no-delay, and 7 for maximum delay.
 */
rtk_api_ret_t rtk_port_rgmiiDelayExt0_set(rtk_data_t txDelay, rtk_data_t rxDelay)
{
    rtk_api_ret_t retVal;
    uint32 regData;

    if ((txDelay > 1)||(rxDelay > 7))
        return RT_ERR_INPUT;

    if ((retVal = rtl8370_getAsicReg(RTL8370_REG_EXT0_RGMXF, &regData))!=RT_ERR_OK)
        return retVal;

    regData = (regData&0xFFF0) | ((txDelay<<3)&0x0008) | (rxDelay&0x007);

    if ((retVal = rtl8370_setAsicReg(RTL8370_REG_EXT0_RGMXF, regData))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/* Function Name:
 *      rtk_port_rgmiiDelayExt1_set
 * Description:
 *      Set RGMII interface 1 delay value for TX and RX.
 * Input:
 *      txDelay - TX delay value, 1 for delay 2ns and 0 for no-delay
 *      rxDelay - RX delay value, 0~7 for delay setup.
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_INPUT - Invalid input parameters.
 * Note:
 *      This API can set external interface 1 RGMII delay.
 *      In TX delay, there are 2 selection: no-delay and 2ns delay.
 *      In RX dekay, there are 8 steps for delay tunning. 0 for n0-delay, and 7 for maximum delay.
 */
rtk_api_ret_t rtk_port_rgmiiDelayExt1_set(rtk_data_t txDelay, rtk_data_t rxDelay)
{
    rtk_api_ret_t retVal;
    uint32 regData;

    if ((txDelay > 1)||(rxDelay > 7))
        return RT_ERR_INPUT;

    if ((retVal = rtl8370_getAsicReg(RTL8370_REG_EXT1_RGMXF, &regData))!=RT_ERR_OK)
        return retVal;

    regData = (regData&0xFFF0) | ((txDelay<<3)&0x0008) | (rxDelay&0x007);

    if ((retVal = rtl8370_setAsicReg(RTL8370_REG_EXT1_RGMXF, regData))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

static int init_ext_interface(void)
{
   int retVal;

   /* set external interface 0 rgmii mode*/
   retVal = rtl8370_setAsicPortExtMode(RTK_EXT_0, MODE_EXT_RGMII); //RTK_EXT_0 - PORT9
   //printf("rtl8370_setAsicPortExtMode:set ext0 RGMII mode,retVal %d\n", retVal);

   /* set external interface 0 rgmii mode*/
   retVal = rtl8370_setAsicPortExtMode(RTK_EXT_1, MODE_EXT_RGMII);   //RTK_EXT_1 - PORT8
   //printf("rtl8370_setAsicPortExtMode:set ext1 RGMII mode,retVal %d\n", retVal);

///-
#if 0
   retVal = rtk_port_rgmiiDelayExt0_set(1, 4);
   printf("rtk_port_rgmiiDelayExt0_set:set ext0 RGMII delay tx:1,rx:0,retVal %d\n", retVal);

   retVal = rtk_port_rgmiiDelayExt1_set(1, 4);
   printf("rtk_port_rgmiiDelayExt1_set:set ext1 RGMII delay tx:1,rx:0,retVal %d\n", retVal);
#else
    retVal = rtk_port_rgmiiDelayExt0_set(1, 5);
    //printf("rtk_port_rgmiiDelayExt0_set:set ext0 RGMII delay tx:1,rx:5,retVal %d\n", retVal);

    retVal = rtk_port_rgmiiDelayExt1_set(1, 5);
    //printf("rtk_port_rgmiiDelayExt1_set:set ext1 RGMII delay tx:1,rx:5,retVal %d\n", retVal);
#endif


   return retVal;
}

/*
@func ret_t | rtl8370_getAsicMIBsCounter | Get MIBs counter.
@parm uint32 | port | Physical port number (0~5).
@num RTL8370_MIBCOUNTER | mibIdx | MIB counter index.
@parm uint64* | counter | MIB retrived counter.
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_PORT_ID | Invalid port number.
@rvalue RT_ERR_STAT_INVALID_PORT_CNTR | Invalid MIBs index.
@rvalue RT_ERR_BUSYWAIT_TIMEOUT | MIB is busy at retrieving
@rvalue RT_ERR_STAT_PORT_CNTR_FAIL | MIB is resetting.
@comm
     Before MIBs counter retrieving, writting accessing address to ASIC at first and check the MIB control register status. If busy bit of MIB control is set, that
     mean MIB counter have been waiting for preparing, then software must wait atfer this busy flag reset by ASIC. This driver did not recycle reading user desired
     counter. Software must use driver again to get MIB counter if return value is not RT_ERR_OK.

*/
static ret_t rtl8370_getAsicMIBsCounter(uint32 port,enum RTL8370_MIBCOUNTER mibIdx,uint64_t * counter)
{
    ret_t retVal;
    uint32 regAddr;
    uint32 regData;
    uint32 mibAddr;
    uint32 mibOff = 0;

    /* address offset to MIBs counter */
    const uint16 mibLength[RTL8370_MIBS_NUMBER]= {
        4,2,2,2,2,2,2,2,2,
        4,2,2,2,2,2,2,2,2,2,2,
        4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2};

    uint16 i;
    uint64_t mibCounter;


    if(port > RTL8370_PORTIDMAX)
        return RT_ERR_PORT_ID;

    if(mibIdx >= RTL8370_MIBS_NUMBER)
        return RT_ERR_STAT_INVALID_PORT_CNTR;

    if(Dot1dTpLearnEntryDiscard == mibIdx)
    {
        mibAddr = RTL8370_MIB_LEARNENTRYDISCARD_OFFSET;
    }
    else
    {
        i = 0;
        mibOff = RTL8370_MIB_PORT_OFFSET*(port);

        while(i < mibIdx)
        {
            mibOff += mibLength[i];
            i++;
        }        
        
        mibAddr = mibOff;
    }
    

    /*writing access counter address first*/
    /*This address is SRAM address, and SRAM address = MIB register address >> 2*/
    /*then ASIC will prepare 64bits counter wait for being retrived*/
    /*Write Mib related address to access control register*/
    retVal = rtl8370_setAsicReg(RTL8370_REG_MIB_ADDRESS,(mibAddr>>2));
    if(retVal !=  RT_ERR_OK)
        return retVal;

    /* polling busy flag */
    i = 100;
    while(i > 0)
    {
        /*read MIB control register*/
        retVal = rtl8370_getAsicReg(RTL8370_MIB_CTRL_REG,&regData);
    
        if((regData & RTL8370_BUSY_FLAG_MASK) == 0)
        {
            break;
        }
    
        i--;
    }

    if(regData & RTL8370_BUSY_FLAG_MASK)
        return RT_ERR_BUSYWAIT_TIMEOUT;

    if(regData & RTL8370_RESET_FLAG_MASK)
        return RT_ERR_STAT_PORT_CNTR_FAIL;

    mibCounter = 0;
    i = mibLength[mibIdx];
    if(4 == i)
        regAddr = RTL8370_MIB_COUNTER_BASE_REG + 3;
    else
        regAddr = RTL8370_MIB_COUNTER_BASE_REG + ((mibOff+1)%4);
    
    while(i)
    {
        retVal = rtl8370_getAsicReg(regAddr,&regData);
        if(retVal != RT_ERR_OK)
            return retVal;

        mibCounter = (mibCounter << 16) | (regData & 0xFFFF);

        regAddr --;
        i --;
        
    }
    
    *counter = mibCounter;    
    
    return RT_ERR_OK;
}

/*
@func ret_t | rtl8370_setAsicPortIsolationPermittedPortmask | Set permitted port isolation portmask
@parm uint32 | port | Physical port number (0~15).
@parm uint32 | permitPortmask | portmask (0~0xFFFF)
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error. 
@rvalue RT_ERR_PORT_ID | Invalid port number.
@rvalue RT_ERR_PORT_MASK | Invalid portmask.
@comm
    This API set the port mask that a port can trasmit packet to of each port
    A port can only transmit packet to ports included in permitted portmask
*/
ret_t rtl8370_setAsicPortIsolationPermittedPortmask(uint32 port, uint32 permitPortmask)
{
    if(port >= RTL8370_PORTNO)
        return RT_ERR_PORT_ID;

    if(permitPortmask > RTL8370_PORTMASK)
        return RT_ERR_PORT_MASK;
    
    return rtl8370_setAsicReg(RTL8370_PORT_ISOLATION_PORT_MASK_REG(port), permitPortmask);
}

/* Function Name:
 *      rtk_port_isolation_set
 * Description:
 *      Set permitted port isolation portmask
 * Input:
 *      port - port id.
 *      portmask - Permit port mask
 * Output:
 *      None
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_PORT_ID - Invalid port number.
 *      RT_ERR_PORT_MASK - Invalid portmask.
 * Note:
 *      This API set the port mask that a port can trasmit packet to of each port
 *      A port can only transmit packet to ports included in permitted portmask
 */
rtk_api_ret_t rtk_port_isolation_set(rtk_port_t port, rtk_portmask_t portmask)
{
    rtk_api_ret_t retVal;

    if (port > RTK_PORT_ID_MAX)
        return RT_ERR_PORT_ID;

    if ( portmask.bits[0] > RTK_MAX_PORT_MASK)
        return RT_ERR_PORT_MASK;

    if ((retVal = rtl8370_setAsicPortIsolationPermittedPortmask(port,portmask.bits[0]))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

/******************************************************************
  * Function: rtk8370_set_phy_powerdown
  * Desc: 1) uboot下8370未划分VLAN，增加对网管口、CPU1、业务口、CPU0隔离，可以避免业务口与网管口同时接入后网络故障，
  *          但uboot下业务口与网管口同时接入，影响通过串口升级(不能ping通server)，在此powerdown网管口，在8370ko中恢复
  *          (仅业务口接入可以ping通server，无需powerdown网管口)
  * Note: 
  * Input:        
  * Output: 
  * Return: 
  */
void rtk8370_set_phy_powerdown(uint32 port, uint32 bEnable)
{
    uint32              phyData;
    int                 retVal = RT_ERR_OK;
    
    if ((retVal = rtl8370_setAsicPHYReg(port,PHY_PAGE_ADDRESS,0))!=RT_ERR_OK)
    {
        printf("%s: rtl8370_setAsicPHYReg failed! port=%d retVal=0x%x\n", __func__, port, retVal);
        return;
    }

    if ((retVal = rtl8370_getAsicPHYReg(port,PHY_CONTROL_REG,&phyData))!=RT_ERR_OK)
    {
        printf("%s: rtl8370_getAsicPHYReg failed! port=%d retVal=0x%x\n", __func__, port, retVal);
        return;
    }

    if (bEnable)
    {
        phyData |= (1 << 11);
    }
    else
    {
        phyData &= (~(1 << 11));
    }
    if ((retVal = rtl8370_setAsicPHYReg(port,PHY_CONTROL_REG,phyData))!=RT_ERR_OK)
    {
        printf("%s: rtl8370_setAsicPHYReg failed! port=%d phyData=0x%x retVal=0x%x\n", __func__, port, phyData, retVal);
    }
    else
    {
        printf("%s: rtl8370_setAsicPHYReg succ! port=%d phyData=0x%x\n", __func__, port, phyData);
    }
}

/******************************************************************
  * Function: rtk8370_isolation_cfg(参考4.15 Port Isolation)
  * Desc: 1) dtu2业务板初始化完成后，此时eth0 mac未知，只能以广播报文形式上报槽位号，为避免广播报文发送到设备外，
  *          在uboot中做了限制(接口板对应网口发出的所有报文，只允许转发到CPU0对应网口)，等8370ko中acl配置完成后，
  *          必须打开此限制(rtk8370_acl_broadcast_from_dtu可以仅限制来自接口板广播报文到达eth0)，否则来自业务板的rtp报文也不能送到外网
  *       2) uboot下8370未划分VLAN，避免业务口与网管口同时接入，增加对网管口、CPU1、业务口、CPU0隔离 
  * Note: 
  * Input:        
  * Output: 
  * Return: 
  */
int rtk8370_isolation_cfg(void)
{
    rtk_portmask_t      portmask;
    int                 i;
    int                 retVal = RT_ERR_OK;
    uint32              error = 0;

    {
        /* 1) 隔离网管口、CPU1、业务口、CPU0 */
        /* a) 隔离网管口收到的报文 */
        portmask.bits[0] = 0x00;
        retVal = rtk_port_isolation_set(PORT0, portmask);
        if( retVal != RT_ERR_OK )
        {
            printf("%s: rtk_port_isolation_set failed! port=%d retVal=0x%x\n", __func__, PORT0, retVal);
        }
        /* 0) 网管口powerdown */
        rtk8370_set_phy_powerdown(PORT0, TRUE);        
        /* b) 隔离CPU1网口发出的报文 */
        portmask.bits[0] = 0x00;
        retVal = rtk_port_isolation_set(PORT9, portmask);
        if( retVal != RT_ERR_OK )
        {
            printf("%s: rtk_port_isolation_set failed! port=%d retVal=0x%x\n", __func__, PORT9, retVal);
        }
       
        /* c) 业务口只允许到达CPU1 */
        portmask.bits[0] = PORT8_MASK;
        retVal = rtk_port_isolation_set(PORT1, portmask);
        if( retVal != RT_ERR_OK )
        {
            printf("%s: rtk_port_isolation_set failed! port=%d retVal=0x%x\n", __func__, PORT1, retVal);
        }
        /* d) CPU0只允许到达业务口 */
        portmask.bits[0] = PORT1_MASK;
        retVal = rtk_port_isolation_set(PORT8, portmask);
        if( retVal != RT_ERR_OK )
        {
            printf("%s: rtk_port_isolation_set failed! port=%d retVal=0x%x\n", __func__, PORT8, retVal);
        }
    }
    
    /* e) 与接口板对接的6个网口都隔离 */
    portmask.bits[0] = 0;
    for (i = 0; i < ulMaxDtuNum; i++)
    {
        /* 2) 隔离从接口板出来的报文 */
        retVal = rtk_port_isolation_set(slot_port[i], portmask);
        if( retVal != RT_ERR_OK )
        {
            printf("%s: rtk_port_isolation_set failed! slot=%d retVal=0x%x\n", __func__, i, retVal);
            error = 1;
        }
        rtk8370_set_phy_powerdown(slot_port[i],TRUE);
    }

    if (error)
    {
        printf("rtk8370_isolation_cfg failed!\n");
    }
    else
    {
        printf("rtk8370_isolation_cfg succ!\n");
    }

    return retVal;
}

/*
@func ret_t | rtl8370_getAsicPortIsolationPermittedPortmask | Get permitted port isolation portmask
@parm uint32 | port | Physical port number (0~15).
@parm uint32* | permitPortmask | portmask (0~0xFFFF)
@rvalue RT_ERR_OK | Success.
@rvalue RT_ERR_SMI | SMI access error. 
@rvalue RT_ERR_PORT_ID | Invalid port number.
@comm
    This API get the port mask that a port can trasmit packet to of each port
    A port can only transmit packet to ports included in permitted portmask
*/
ret_t rtl8370_getAsicPortIsolationPermittedPortmask(uint32 port, uint32 *permitPortmask)
{
    if(port >= RTL8370_PORTNO)
        return RT_ERR_PORT_ID;
    
    return rtl8370_getAsicReg(RTL8370_PORT_ISOLATION_PORT_MASK_REG(port), permitPortmask);
}

/* Function Name:
 *      rtk_port_isolation_get
 * Description:
 *      Get permitted port isolation portmask
 * Input:
 *      port - Port id.
 * Output:
 *      pPortmask - Permit port mask
 * Return:
 *      RT_ERR_OK              - OK
 *      RT_ERR_FAILED          - FAILED
 *      RT_ERR_SMI             - SMI access error
 *      RT_ERR_PORT_ID - Invalid port number.
 * Note:
 *      This API get the port mask that a port can trasmit packet to of each port
 *      A port can only transmit packet to ports included in permitted portmask
 */
rtk_api_ret_t rtk_port_isolation_get(rtk_port_t port, rtk_portmask_t *pPortmask)
{
    rtk_api_ret_t retVal;

    if (port > RTK_PORT_ID_MAX)
        return RT_ERR_PORT_ID;

    if ((retVal = rtl8370_getAsicPortIsolationPermittedPortmask(port,&pPortmask->bits[0]))!=RT_ERR_OK)
        return retVal;

    return RT_ERR_OK;
}

static int rtk8370_print_isolation_cfg(void)
{
    rtk_portmask_t      portmask;
    int                 i;
    int                 retVal = RT_ERR_OK;

    /* 1)读取网管口、CPU1、业务口、CPU0隔离状态 */
    retVal = rtk_port_isolation_get(PORT0, &portmask);
    if( retVal != RT_ERR_OK )
    {
        printf("%s: rtk_port_isolation_get failed! port=%d retVal=0x%x\n", __func__, PORT0, retVal);
    }
    else
    {
        printf("  rtk_port_isolation_get: port=%u portmask=0x%x\n", PORT0, portmask.bits[0]);
    }
    retVal = rtk_port_isolation_get(PORT9, &portmask);
    if( retVal != RT_ERR_OK )
    {
        printf("%s: rtk_port_isolation_get failed! port=%d retVal=0x%x\n", __func__, PORT9, retVal);
    }
    else
    {
        printf("  rtk_port_isolation_get: port=%u portmask=0x%x\n", PORT9, portmask.bits[0]);
    }

    retVal = rtk_port_isolation_get(PORT1, &portmask);
    if( retVal != RT_ERR_OK )
    {
        printf("%s: rtk_port_isolation_get failed! port=%d retVal=0x%x\n", __func__, PORT1, retVal);
    }
    else
    {
        printf("  rtk_port_isolation_get: port=%u portmask=0x%x\n", PORT1, portmask.bits[0]);
    }

    retVal = rtk_port_isolation_get(PORT8, &portmask);
    if( retVal != RT_ERR_OK )
    {
        printf("%s: rtk_port_isolation_get failed! port=%d retVal=0x%x\n", __func__, PORT8, retVal);
    }
    else
    {
        printf("  rtk_port_isolation_get: port=%u portmask=0x%x\n", PORT8, portmask.bits[0]);
    }

    for (i = PORT0; i <= PORT9; i++)
    {
        retVal = rtk_port_isolation_get(i, &portmask);
        if( retVal != RT_ERR_OK )
        {
            printf("%s: rtk_port_isolation_get failed! port=%d retVal=0x%x\n", __func__, i, retVal);
        }
        else
        {
            printf("  rtk_port_isolation_get:  port=%u portmask=0x%x\n", i,  portmask.bits[0]);
        }
    }
    return retVal;
}

static int gpio_test_open(struct inode *ino, struct file *filp)
{
    return 0;
}

static int gpio_test_close(struct inode *ino, struct file *filp)
{
    return 0;
}

static ssize_t gpio_test_write(struct file *filp, const char __user *buf, size_t count, loff_t *off)
{
	char c;
	int rc;

	rc = get_user(c, buf);
	if (rc)
		return rc;
	if (c == '1')
    {
        int val = 0;
        while(1)
        {
            if(val)
            {
                _rtl865x_setGpioDataBit(smi_SCK, 1);
                val = 0;
            }
            else
            {
                val = 1;
                _rtl865x_setGpioDataBit(smi_SCK, 0);
            }
        }
    }

	return count;

}

static struct file_operations gpio_test_fops =
{
    .open = gpio_test_open,
    .release = gpio_test_close,
    .write = gpio_test_write,
};


int mii_phy_init(void *base)
{
    unsigned int data = 0;
    unsigned int reg_val, retVal;
    u16 phy_val;

    if(NULL == base)
    {
        printk(KERN_ERR "mii_phy_init error\n");
        return -1;
    }
    gpiobase = base;
    
    phy_val = geth_phy_read(4, 0x130f) & 0xffff;
    printf(KERN_WARNING "phy 8370 reg 0x%x val 0x%x\n", 0x130f, phy_val);
    
    
    rtl8370_setAsicPortEnableAll(DISABLED);
    rtl8370_setAsicPortEnableAll(DISABLED);
    rtl8370_getAsicPortEnableAll(&data);
    //printf("disable getAsicPortEnableAll:0x%x\n", data);    
    
    /*after reset, switch need to delay 1 ms
        if not, SMI may send out unknown data
    */
    udelay(1000);
    
    retVal = rtk_switch_init();
    if (retVal  != RT_ERR_OK)
    {
         return retVal;
    }
    
    /* 1) 隔离接口板与外网 */
    //rtk8370_isolation_cfg();
    //rtk8370_print_isolation_cfg();
    
    test_smi_signal_and_wait();
    
    /* tom: for test */
    //smi_write(0x13a0, 0x123);
    data = geth_phy_read(0, 0x2022);
    //printf("debug,reg PHY ID value=0x%x\n", data);
    
    /* led enable */
    init_and_enable_leds();
    
    /* force cpu 1000M mode */
    // bit13 要为0 6282 page 579 
    //MV_REG_WRITE(0x7243C, 0x00a4060f);//rnii0 ge1 1000m
    
    /* force 8370M 1000M node */
    set_ext_mode();
    
    init_ext_interface();
    // 使能所有网口 前面被powerdowm的不会工作
    rtl8370_setAsicPortEnableAll(ENABLED);
    rtl8370_setAsicPortEnableAll(ENABLED);
    rtl8370_getAsicPortEnableAll(&data);
    //printf("Enable getAsicPortEnableAll:0x%x\n", data);

    /* ACL配置为8370核心功能 */
    retVal = rtk8370_acl_cfg();
    if( retVal != RT_ERR_OK )
    {	
    	printk(KERN_ERR "RTK8370M config acl failed !!! .\n");
    }

    proc_create("gpio_test", 0, NULL, &gpio_test_fops);

    return 0;
}

